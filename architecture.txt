# KAJISU Code Architecture

## Overview

KAJISU is a Vampire Survivors-style game using Japanese kanji characters as all visual assets. Built with Phaser 3, HTML/CSS/JS, using a component-based architecture for modular game mechanics.

**Key Design Philosophy:**
- Explicit over clever: Systems are kept separate for clarity
- Component-based: Reusable behaviors attached to entities
- Registry pattern: Perks connect to systems through registries
- AI-maintainable: Code structure optimized for AI-assisted development

## Core Concepts

### Component-Based Architecture

The game uses **Component Systems** that manage reusable behaviors:

1. **Component**: A self-contained unit of behavior (e.g., `slowEffect`, `poisonEffect`)
2. **Component System**: Manages lifecycle of components (create, update, cleanup)
3. **Registry**: Connects perks to components, enabling automatic application

**Example Flow:**
```
Player picks "Azure Frost" perk
  → ProjectilePerkRegistry checks if player has AZURE_FROST
  → Adds 'slowEffect' component to fired projectiles
  → Component applies slow effect when projectile hits enemy
```

### The Five Main Systems

Each system handles a distinct game mechanic. They are **intentionally separate** for clarity:

#### 1. **Projectile System** (artillery.js + ballistics.js)
- **Purpose**: Fired projectiles from player's weapon
- **Components**: slowEffect, poisonEffect, fireEffect, splitEffect, etc.
- **Registry**: ProjectilePerkRegistry
- **Key Feature**: Chance-based application using player luck

#### 2. **Dropper System** (droppers.js + entrapments.js)  
- **Purpose**: Objects placed in the world (landmines, afterimages)
- **Components**: Behavior-based (explosive, persistent, areaEffect)
- **Registry**: DropperPerkRegistry
- **Key Feature**: Position strategies (player, random, trail)

#### 3. **Orbital System** (orbitals.js + nexus.js)
- **Purpose**: Entities that orbit/follow the player
- **Components**: Movement patterns (standard, spiralOut, figureEight)
- **Registry**: OrbitalPerkRegistry  
- **Key Feature**: Count-based spawning, periodic creation

#### 4. **Player Status System** (hero.js)
- **Purpose**: Status effects on the player character
- **Components**: berserkerState, shieldAbility, eternalRhythmState, etc.
- **Registry**: PlayerPerkRegistry
- **Key Feature**: Condition-based activation/deactivation

#### 5. **On-Hit System** (onhit.js)
- **Purpose**: Effects triggered when player is hit by enemies
- **Components**: defensiveBurst, stormVengeance, timeDilation, etc.
- **Registry**: OnHitPerkRegistry
- **Key Feature**: Automatic triggering on player damage

## File Organization

### Core Game Files

**index.html**
- Main game file with Phaser initialization
- Core game loop (create, update functions)
- Global variable declarations
- System coordination

**weapons.js** - WeaponSystem
- Player's primary weapon firing logic
- Manages firing timer (scales with fire rate)
- Target selection (closest enemy)
- Projectile creation

**hero.js**
- Player character constants (kanji, stats, base values)
- PlayerComponentSystem (manages player status effects)
- PlayerPerkRegistry (connects perks to player components)
- ShieldSystem (manages shield visuals and state)

**bestiary.js**
- Enemy type definitions (kanji, translations, readings)
- Rank-based defaults (health, speed, size)
- Enemy data retrieval utilities

**enemy.js** - EnemySystem  
- Enemy spawning and movement
- Attack patterns
- Difficulty scaling over time
- Rank progression

### Component Systems

**artillery.js** - ProjectileComponentSystem
- Framework for projectile components
- Component lifecycle: initialize, update, onHit, cleanup
- Built-in components: distanceDamage, slowEffect, poisonEffect, splitEffect, fireEffect, etc.

**ballistics.js** - ProjectilePerkRegistry
- Maps perks to projectile components
- Handles luck-based chance calculations
- Automatic component application to projectiles
- Config generators for component parameters

**droppers.js** - DropperSystem
- Creates and manages world drops
- Drop behaviors: explosive, persistent, areaEffect
- Periodic effect system
- Position-based spawning

**entrapments.js** - DropperPerkRegistry
- Maps perks to dropper configurations
- Position modes: player, random, trail
- Cooldown-based spawning
- Drop lifecycle management

**orbitals.js** - OrbitalSystem
- Creates entities that orbit the player
- Movement patterns: standard, spiralOut, figureEight, elliptical
- Collision types: persistent, projectile, explosive
- Orbital lifecycle and updates

**nexus.js** - OrbitalPerkRegistry
- Maps perks to orbital configurations  
- Count-based spawning (create N orbitals)
- Timer-based periodic creation
- Familiar system integration

**onhit.js** - OnHitEffectSystem + OnHitPerkRegistry
- Components triggered when player is hit
- Examples: defensiveBurst, stormVengeance, timeDilation
- Automatic event triggering

### Supporting Systems

**beacons.js** - BeaconSystem
- Collectible pickups that grant temporary buffs
- Factory function: `createBeaconComponent(config)`
- Integrated with PlayerComponentSystem
- Beacon configs: DIVINE_BEACON, ANGEL_HONEY, ALIEN_CLOCK, etc.

**shrines.js** - ShrineSystem
- Immovable world objects with aura effects
- Factory function: `createShrineComponent(config)`
- Aura-based triggering (player enters/exits)
- Shrine configs: BERSERK_SHRINE, ARCHER_SHRINE, HEALING_SHRINE, etc.

**cooldown.js** - CooldownManager
- Manages timers that scale with player stats
- Formulas: 'fixed', 'sqrt', 'divide', 'multiply'
- Automatic timer updates when stats change significantly (10%+)
- Central cleanup system for timers

**familiars.js** - EntityFiringSystem
- Handles entities that fire projectiles (familiars, shrines, etc.)
- Firing behaviors: closest, random, aimed, multiShot, beam, etc.
- Integrates with CooldownManager for stat-scaled firing
- Unified projectile creation from entities

**beamLogic.js** - BeamSystem
- Creates directional beam attacks
- Beam directions: NORTH, SOUTH, EAST, WEST
- Component support for beam effects
- Collision detection and damage

**visuals.js** - VisualEffects
- Reusable visual effect functions
- Effects: explosions, damage flashes, pulsing, lightning, etc.
- Called by other systems for feedback

**onetime.js** - OneTimeEffects
- Single-use effects triggered by specific perks
- Examples: screen-clearing blasts, stat scrambles
- `triggerOneTimeEffect(effectName)` interface

### UI and Utilities

**menu.js** - GameUI
- Health bar and experience bar
- Status display (time, score)
- Stat circles display
- UI creation and updates

**cards.js** - CardSystem
- Perk card UI creation
- Card styling and interaction
- Reusable card components

**challenge.js** - RomajiChallengeSystem
- Romaji typing challenge during level-up
- Input validation and rewards
- Alternative to simple card selection

**pause.js** - PauseSystem
- Game pausing and overlay UI
- Perk display during pause
- State management

**debug.js** - DebugSystem
- Debug utilities and shortcuts
- Performance monitoring
- Phase skipping for testing

**life.js** - LifeSystem
- Player health regeneration
- Healing effects and timers
- Visual feedback for healing

**input.js** - InputSystem
- Enhanced input handling
- Cursor visibility management
- Focus state handling

**playerhit.js** - PlayerHitSystem
- Manages player damage
- Invincibility frames
- Blood vignette effects
- Death conditions

**perks.js** - PERKS Object
- Definitions of all perks
- Kanji, translations, descriptions
- `onAcquire` functions
- PerkSystem helper utilities

## How to Add New Perks

### Pattern 1: Simple Stat Modification

```javascript
// In perks.js
"MY_PERK": {
    kanji: "力",
    kana: "ちから",
    romaji: "chikara",
    english: "Strength",
    description: "+2 POW",
    color: "#ff0000",
    hoverColor: 0xcc0000,
    onAcquire: function() {
        window.modifyStat('damage', 2);
    }
}
```

### Pattern 2: Projectile Component Perk

```javascript
// 1. Define component in artillery.js
ProjectileComponentSystem.registerComponent('myEffect', {
    initialize: function(projectile) {
        // Setup when component is added
    },
    onHit: function(projectile, enemy, scene) {
        // Behavior when projectile hits enemy
    }
});

// 2. Register in ballistics.js
ProjectilePerkRegistry.registerPerkEffect('MY_PERK', {
    componentName: 'myEffect',
    applyChance: true // Use luck-based chance
});

// 3. Define perk in perks.js
"MY_PERK": {
    kanji: "...",
    // ... other fields
    onAcquire: function() {
        // Usually empty - registry handles it
    }
}
```

### Pattern 3: Orbital Perk

```javascript
// 1. Register in nexus.js
OrbitalPerkRegistry.registerPerkOrbital('MY_ORBITAL', {
    getConfig: function() {
        return {
            symbol: '★',
            color: '#ffff00',
            fontSize: 32,
            radius: 100,
            speed: 1,
            pattern: 'standard',
            collisionType: 'persistent',
            damage: playerDamage,
            damageInterval: 500,
            lifespan: null // Permanent
        };
    },
    count: 3, // Create 3 orbitals
    cooldown: 4000,
    cooldownStat: 'luck',
    cooldownFormula: 'sqrt',
    activationMethod: 'timer'
});

// 2. Create activation function
window.activateMyOrbital = function() {
    const scene = game.scene.scenes[0];
    if (!scene) return;
    
    // Create initial orbital(s)
    const config = OrbitalPerkRegistry.perkOrbitalConfigs['MY_ORBITAL'].getConfig();
    for (let i = 0; i < 3; i++) {
        OrbitalSystem.create(scene, config);
    }
    
    // Start periodic spawning
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'MY_ORBITAL');
};

// 3. Define perk in perks.js
"MY_ORBITAL": {
    kanji: "...",
    // ... other fields
    onAcquire: function() {
        window.activateMyOrbital();
    }
}
```

### Pattern 4: Dropper Perk

```javascript
// 1. Register in entrapments.js
DropperPerkRegistry.registerDropperPerk('MY_DROPPER', {
    getConfig: function() {
        return {
            symbol: '●',
            color: '#ff0000',
            behavior: 'explosive',
            damage: playerDamage * 2,
            blastRadius: 100
        };
    },
    cooldown: 2000,
    cooldownStat: 'fireRate',
    cooldownFormula: 'sqrt',
    positionMode: 'trail', // 'player', 'random', or 'trail'
    activationMethod: 'immediate'
});

// 2. Create activation function
window.activateMyDropper = function() {
    const scene = game.scene.scenes[0];
    if (!scene) return;
    DropperPerkRegistry.applyDropperPerk(scene, 'MY_DROPPER');
};

// 3. Define perk in perks.js
"MY_DROPPER": {
    kanji: "...",
    // ... other fields
    onAcquire: function() {
        window.activateMyDropper();
    }
}
```

### Pattern 5: Player Status Perk

```javascript
// 1. Register component in hero.js
PlayerComponentSystem.registerComponent('myStatusEffect', {
    multiplier: 1.0,
    
    initialize: function(player) {
        // Setup when component is added
    },
    
    update: function(player) {
        // Called every frame - update multipliers here
        // E.g., berserkMultiplier = 1.5;
    },
    
    cleanup: function(player) {
        // Reset state when component is removed
    }
});

// 2. Register with PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('MY_STATUS', {
    componentName: 'myStatusEffect',
    condition: function() {
        return true; // Or conditional logic
    }
});

// 3. Define perk in perks.js
"MY_STATUS": {
    kanji: "...",
    // ... other fields
    onAcquire: function() {
        // Registry handles component addition
    }
}
```

### Pattern 6: Beacon/Shrine Perk (Factory Pattern)

```javascript
// 1. Define config in beacons.js or shrines.js
const BeaconConfigs = {
    MY_BEACON: {
        symbol: '✦',
        color: '#00FF00',
        spawnCooldown: 8000,
        cooldownStat: 'luck',
        cooldownFormula: 'sqrt',
        maxBeacons: 5,
        lifespan: null,
        onCollect: function(beacon, player, scene) {
            // Effect when player collects beacon
            window.modifyStat('damage', 1);
        }
    }
};

// 2. Use factory in hero.js
PlayerComponentSystem.registerComponent('myBeaconAbility',
    BeaconSystem.createBeaconComponent(BeaconConfigs.MY_BEACON)
);

PlayerPerkRegistry.registerPerkEffect('MY_BEACON', {
    componentName: 'myBeaconAbility',
    condition: function() { return true; }
});

// 3. Define perk in perks.js
"MY_BEACON": {
    kanji: "...",
    // ... other fields
    onAcquire: function() {
        // Registry handles component addition
    }
}
```

## Common Patterns and Utilities

### Cooldown Configuration

All systems use standardized cooldown configs:

```javascript
{
    cooldown: 4000,              // Base cooldown in milliseconds
    cooldownStat: 'luck',        // Stat that affects cooldown ('luck', 'fireRate', 'damage', 'health')
    cooldownFormula: 'sqrt'      // Formula: 'fixed', 'sqrt', 'divide', 'multiply'
}
```

**Formula explanations:**
- `'fixed'`: Cooldown never changes (ignores stat)
- `'sqrt'`: `baseCooldown / sqrt(currentStat / baseStat)` - gentle scaling
- `'divide'`: `baseCooldown / currentStat` - strong scaling  
- `'multiply'`: `baseCooldown * currentStat` - inverse scaling (longer with higher stat)

### Global Helper Functions

**Stat Modification:**
```javascript
window.modifyStat(statName, amount)
// statName: 'damage', 'fireRate', 'luck', 'health', 'speed'
```

**Effect Registration (for cleanup):**
```javascript
window.registerEffect(type, object)
// type: 'timer', 'entity', 'tween'
// Ensures proper cleanup on game restart
```

**Pause-Aware Delays:**
```javascript
window.createPauseAwareDelay(scene, delay, callback, callbackScope)
// Like scene.time.delayedCall but respects pause state
```

**Common Visual Effects:**
```javascript
VisualEffects.createExplosion(scene, x, y, color, radius)
VisualEffects.createLightning(scene, startX, startY, endX, endY, color)
VisualEffects.createPulsing(scene, entity)
VisualEffects.damageFlash(entity, color)
```

### Component Lifecycle

All component systems follow this pattern:

```javascript
{
    initialize: function(entity) {
        // Called when component is added
        // Setup timers, store references, etc.
    },
    
    update: function(entity, ...args) {
        // Called every frame (if system processes updates)
        // Update state, check conditions, etc.
    },
    
    onHit: function(entity, target, scene) {
        // Called when entity hits target (projectiles, orbitals)
        // Apply effects, spawn other entities, etc.
    },
    
    cleanup: function(entity) {
        // Called when component is removed
        // Clear timers, reset state, destroy entities
    }
}
```

## Registry Pattern Details

### Why Separate Registries?

Each registry handles fundamentally different concerns:

**ProjectilePerkRegistry:**
- Components attach to bullets
- Chance-based application (luck scaling)
- Triggered per shot
- Example: Slow, poison, fire effects

**DropperPerkRegistry:**
- Create world objects
- Position strategies matter
- Periodic spawning at locations
- Example: Landmines, afterimages

**OrbitalPerkRegistry:**
- Entities orbit player
- Movement patterns and spawn counts
- Periodic creation over time
- Example: Spinning projectiles, satellites

**PlayerPerkRegistry:**
- Status effects on player
- Condition-based activation
- State management
- Example: Shields, multipliers, buffs

**OnHitPerkRegistry:**
- Triggered when player is damaged
- Event-based, not continuous
- Defensive effects
- Example: Counter-attacks, defensive bursts

### Registry Method Naming

```javascript
ProjectilePerkRegistry.registerPerkEffect(perkId, config)
DropperPerkRegistry.registerDropperPerk(perkId, config)
OrbitalPerkRegistry.registerPerkOrbital(perkId, config)
PlayerPerkRegistry.registerPerkEffect(perkId, config)    // Note: Same name as Projectile
OnHitPerkRegistry.registerPerkEffect(perkId, config)     // Note: Same name as Projectile
```

This naming overlap is acceptable because context (file) makes it clear.

## Design Principles for AI Maintenance

### 1. Explicit Over Clever
Each system is self-contained and explicit. No complex inheritance or abstractions that require deep understanding.

### 2. Example-Driven Development  
When adding features, copy existing examples from the same registry and modify. This is why registries have many similar entries.

### 3. Consistent Patterns
Similar concerns are handled similarly across systems. Cooldown config, lifecycle methods, and naming follow predictable patterns.

### 4. Separation of Concerns
Different game mechanics live in different files. Don't mix projectile logic with orbital logic.

## Common Workflows

### Adding a Simple Perk
1. Add definition to perks.js
2. Implement `onAcquire` function (usually just stat modification or activation function call)

### Adding a Projectile Effect
1. Create component in artillery.js
2. Register in ballistics.js  
3. Add perk definition in perks.js

### Adding an Orbital/Dropper/Player Status Effect
1. Register configuration in appropriate registry (nexus.js, entrapments.js, hero.js)
2. Create activation function if needed
3. Add perk definition in perks.js

### Modifying Existing Perk
1. Find perk definition in perks.js
2. Follow `onAcquire` function to find implementation
3. For component-based perks, find component definition in appropriate system file

## Technical Constraints

- **No localStorage/sessionStorage**: Not supported in Claude.ai artifact environment
- **Canvas textures for performance**: Used for enemies and projectiles in late game
- **Phaser 3**: Physics and rendering engine
- **Nullish coalescing (??)**: Preferred over logical OR (||) for defaults
- **Global variables**: player, gameOver, gamePaused, etc. are intentionally global for simplicity

## Important Global Variables

```javascript
// Player stats
playerHealth, maxPlayerHealth
playerDamage
playerSpeed, basePlayerSpeed  
playerLuck
playerFireRate
heroExp, playerLevel

// Game state
gameOver, gamePaused, gameStarted
elapsedTime, gameStartTime

// Base values
BASE_STATS = { POW: 4, AGI: 4, LUK: 4, END: 4 }

// Player character
player // Phaser text object

// Entity groups
projectiles, piercingProjectiles
EnemySystem.enemiesGroup

// Multipliers (modified by perks)
berserkMultiplier, archerMultiplier
```

## Testing and Debugging

**Debug Mode (D key):**
- Shows performance stats
- Displays current stats
- Enables additional debugging

**Quick Testing:**
- R key: Restart game
- T key: Skip to next phase
- K key: Kill all enemies
- O key: Spawn specific enemy

**Common Issues:**
- Timer leaks: Use CooldownManager and registerEffect
- Component cleanup: Always implement cleanup function
- Stat updates: Call `CooldownManager.update()` after stat changes
- Pause handling: Use `createPauseAwareDelay` for delays

## Run Commands

Development:
```bash
live-server --open=index.html
```

Kajisuli Mode (simplified variant):
```bash
live-server --open=kajisuli.min.html
```

## Summary

KAJISU's architecture prioritizes **clarity and maintainability for AI-assisted development**. Each system is self-contained with clear examples. When adding features, find similar existing features and copy their pattern. The component-based architecture and registry pattern provide structure without requiring deep understanding of complex abstractions.

**Key mental model:** Perks are defined in perks.js, registered with system-specific registries, which connect to component systems that implement the actual behavior. Each system handles one game mechanic clearly and explicitly.