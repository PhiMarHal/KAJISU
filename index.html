<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Survivors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="bestiary.js"></script>
    <script src="perks.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #game-container {
            width: 1200px;
            height: 800px;
            position: relative;
            margin: 0 auto;
            /* Center horizontally */
        }

        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            z-index: 10;
            pointer-events: none;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="game-ui">
            <div id="level">Time Survived: 00:00:00</div>
            <div id="kills">Enemies killed: 0</div>
        </div>
    </div>

    <script>
        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 800,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Game variables
        let player;
        let enemies;
        let projectiles;
        let cursors;
        let wasdKeys;
        let keyboardLayout = 'qwerty'; // Default to QWERTY

        // Global variables for pause system
        let pauseScreen = null;
        let resumeButton = null;
        let pauseMessage = null;
        let pauseKeyP = null;

        // Add these variables for stats tracking
        let statsText = null;
        let statsVisible = false;
        let debugModeEnabled = false;


        let activeEffects = {
            timers: [],         // Store all active timers
            entities: [],       // Store all entities created by perks (landmines, afterimages, etc.)
            activePerks: []     // Store all acquired perks
        };

        const HEALTH_SCALE_FACTOR = 100; // Multiply all health values by 100 internally
        let playerHealthDisplay = 0; // For displaying to player

        // Initial player stats
        let basePlayerHealth = BASE_STATS.END;
        let baseMaxHealth = BASE_STATS.END;
        let basePlayerSpeed = 8;
        let basePlayerDamage = BASE_STATS.POW;
        let basePlayerLuck = BASE_STATS.LUK;
        let basePlayerFireRate = BASE_STATS.AGI;
        let baseShootingDelay = 2000;
        let baseHeroExpToLevel = 5;
        let acquiredPerks = [];
        let playerHealth = basePlayerHealth;
        let maxPlayerHealth = baseMaxHealth;
        let playerSpeed = basePlayerSpeed;
        let playerDamage = basePlayerDamage;
        let playerLuck = basePlayerLuck;
        let shootingDelay = baseShootingDelay; // ms between shots
        let playerFireRate = basePlayerFireRate; // Multiplier for shooting rate
        let projectileSizeFactor = 4; // Multiply player damage by this to get proj size
        let healthBar;
        let healthBarBg;
        let healthText;
        let expBar;
        let expBarBg;
        let expText;
        let playerStatsText;
        let score = 0;
        let level = 1;
        let touchInput = { x: 0, y: 0, isActive: false };
        let gameOver = false;
        let gameOverText;
        let restartButton;
        let killCountText;
        let enemyDamage = 1;
        let playerInvincible = false;

        // Track elapsed time
        let elapsedTime = 0; // in seconds

        // Game timers
        let enemySpawner = null;
        let projectileFirer = null;

        // Difficulty scaling factors
        let enemyHealthScaleFactor = 1.0;
        let enemyCountScaleFactor = 1.25;
        let gameStartTime = 0;
        let baseEnemyHealth = 40;
        let currentEnemyHealth = 40;
        let baseSpawnDelay = 4000; // 8 seconds between spawns initially

        // Hero experience system
        let playerLevel = 1;
        let heroExp = 0;
        let heroExpToLevel = 5;
        let heroLevelText;
        let levelUpCards = [];
        let gamePaused = false;

        // Helper function to calculate XP needed for next level
        function xpForNextLevel(heroLevel) {
            return Math.ceil(baseHeroExpToLevel * Math.pow(1.2, heroLevel - 1));
        }

        // Format time to hh:mm:ss
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Perk system variables
        let playerPerks = {};
        let shieldVisual = null;
        let shieldCooldownTimer = null;
        let shieldActive = false;
        let orbitingProjectiles = [];
        let orbitingProjectileTimer = null;
        let landmineTimer = null;
        let afterImages = [];
        let afterImageEnabled = false;
        let afterImageTimer = null;
        let playerPositionHistory = [];
        let healthRegenTimer = null;

        // Setup pause system
        function setupPauseSystem() {
            const scene = this;

            // Create pause key (P)
            pauseKeyP = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pauseKeyP.on('down', function () {
                if (!gameOver) {
                    if (gamePaused) {
                        resumeGame();
                    } else {
                        pauseGameWithOverlay();
                    }
                }
            });

            // Setup visibility change detection
            document.addEventListener('visibilitychange', function () {
                if (document.hidden && !gameOver && !gamePaused) {
                    // Tab/window is hidden, pause the game
                    pauseGameWithOverlay();
                }
                // We don't auto-resume when tab becomes visible again
            });

            // Create pause overlay elements (initially hidden)
            createPauseScreen.call(this);

            console.log("Pause system initialized");
        }

        function createPauseScreen() {
            // Create semi-transparent background
            pauseScreen = this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.7);
            pauseScreen.setVisible(false);
            pauseScreen.setDepth(1000); // Make sure it appears on top

            // Create pause message
            pauseMessage = this.add.text(
                600, 200,
                'GAME PAUSED',
                { fontFamily: 'Arial', fontSize: '40px', color: '#ffffff', fontStyle: 'bold' }
            ).setOrigin(0.5);
            pauseMessage.setVisible(false);
            pauseMessage.setDepth(1001);

            // Create resume button
            resumeButton = this.add.text(
                600, 650,
                'RESUME GAME',
                {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    color: '#ffffff',
                    backgroundColor: '#008800',
                    padding: { left: 15, right: 15, top: 10, bottom: 10 }
                }
            ).setOrigin(0.5);
            resumeButton.setVisible(false);
            resumeButton.setDepth(1001);
            resumeButton.setInteractive();

            // Add resume button functionality
            resumeButton.on('pointerdown', resumeGame);
            resumeButton.on('pointerover', function () {
                this.setStyle({ backgroundColor: '#00aa00' });
            });
            resumeButton.on('pointerout', function () {
                this.setStyle({ backgroundColor: '#008800' });
            });

            // Create container for perks display
            this.pausePerksContainer = this.add.container(0, 0);
            this.pausePerksContainer.setDepth(1001);
            this.pausePerksContainer.setVisible(false);

            // Create perks title
            const perksTitle = this.add.text(
                600, 300,
                'ACQUIRED PERKS',
                { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff', fontStyle: 'bold' }
            ).setOrigin(0.5);

            // Add to container
            this.pausePerksContainer.add(perksTitle);

            // We'll add perk icons when the pause screen is shown
        }


        // Pause the game and show overlay
        function pauseGameWithOverlay() {
            if (gameOver) return;

            // Pause game systems
            pauseGame();

            // Show pause screen elements
            pauseScreen.setVisible(true);
            pauseMessage.setVisible(true);
            resumeButton.setVisible(true);

            // Update and show perks
            updatePauseScreenPerks.call(this);

            console.log("Game paused with overlay");
        }

        function updatePauseScreenPerks() {
            const scene = game.scene.scenes[0];

            // Clear existing perk icons first
            if (scene.perkIcons) {
                scene.perkIcons.forEach(icon => {
                    icon.destroy();
                });
            }

            // Clear existing perk card if any
            if (scene.activePerkCard) {
                scene.activePerkCard.forEach(element => {
                    element.destroy();
                });
                scene.activePerkCard = null;
            }

            // Initialize perk icons array
            scene.perkIcons = [];

            // Set container visible
            scene.pausePerksContainer.setVisible(true);

            // If no perks, show a message
            if (acquiredPerks.length === 0) {
                const noPerkText = scene.add.text(
                    600, 350,
                    'No perks acquired yet',
                    { fontFamily: 'Arial', fontSize: '20px', color: '#aaaaaa' }
                ).setOrigin(0.5);
                scene.perkIcons.push(noPerkText);
                scene.pausePerksContainer.add(noPerkText);
                return;
            }

            // Create temporary text objects to measure each kanji's width
            const measurements = [];
            acquiredPerks.forEach(perkId => {
                const perk = PERKS[perkId];
                if (!perk) return;

                // Create temp text for measurement
                const tempText = scene.add.text(0, 0, perk.kanji, {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    fontStyle: 'bold'
                });

                // Store the width and perk info
                measurements.push({
                    perkId: perkId,
                    width: tempText.width
                });

                // Remove the temp text
                tempText.destroy();
            });

            // Configuration for multi-row layout
            const spacing = 20; // Pixels between kanji horizontally
            const perksPerRow = 8; // Maximum perks per row
            const rowHeight = 70; // Vertical spacing between rows
            const startY = 320; // Starting Y position for the first row

            // Split perks into rows
            const rows = [];
            for (let i = 0; i < measurements.length; i += perksPerRow) {
                rows.push(measurements.slice(i, i + perksPerRow));
            }

            // Process each row
            rows.forEach((row, rowIndex) => {
                // Calculate total width of this row with spacing
                const rowWidth = row.reduce((sum, item) => sum + item.width, 0) +
                    (spacing * (row.length - 1));

                // Calculate starting X position to center this row
                let currentX = 600 - (rowWidth / 2);
                const y = startY + (rowIndex * rowHeight);

                // Create perk icons for this row
                row.forEach(item => {
                    const perkId = item.perkId;
                    const perk = PERKS[perkId];

                    // Position this kanji centered on its width
                    const centerX = currentX + (item.width / 2);

                    // Create the perk icon (kanji)
                    const perkIcon = scene.add.text(
                        centerX, y,
                        perk.kanji,
                        {
                            fontFamily: 'Arial',
                            fontSize: '32px',
                            color: perk.color,
                            fontStyle: 'bold',
                            stroke: '#000000',
                            strokeThickness: 4
                        }
                    ).setOrigin(0.5);

                    // Make interactive
                    perkIcon.setInteractive();

                    // Add hover effects - adjusting card position based on row
                    perkIcon.on('pointerover', function () {
                        this.setScale(1.2);

                        // If this is the bottom row and there are multiple rows,
                        // show the card above instead of below
                        const cardY = (rowIndex >= rows.length - 1 && rows.length > 1)
                            ? y - 150 // Place card above
                            : y + 150; // Place card below

                        showPerkCard.call(scene, perkId, centerX, cardY);
                    });

                    perkIcon.on('pointerout', function () {
                        this.setScale(1);
                        hidePerkCard.call(scene);
                    });

                    // Store reference
                    scene.perkIcons.push(perkIcon);

                    // Add to container
                    scene.pausePerksContainer.add(perkIcon);

                    // Move currentX position for the next kanji
                    currentX += item.width + spacing;
                });
            });
        }

        // Function to show detailed perk card
        function showPerkCard(perkId, x, y) {
            const scene = this;
            const perk = PERKS[perkId];

            // Clear any existing perk card
            hidePerkCard.call(scene);

            // Create card elements
            scene.activePerkCard = [];

            // Card background
            const cardBg = scene.add.rectangle(x, y, 220, 320, 0x444444, 1)
                .setStrokeStyle(2, 0x000000);
            scene.activePerkCard.push(cardBg);

            // Kanji (larger font)
            const kanjiText = scene.add.text(
                x, y - 60,
                perk.kanji,
                { fontFamily: 'Arial', fontSize: '36px', color: perk.color, fontStyle: 'bold' }
            ).setOrigin(0.5);
            scene.activePerkCard.push(kanjiText);

            // Hiragana - romaji
            const readingText = scene.add.text(
                x, y - 15,
                `${perk.hiragana} - ${perk.romaji}`,
                { fontFamily: 'Arial', fontSize: '18px', color: '#ffffff' }
            ).setOrigin(0.5);
            scene.activePerkCard.push(readingText);

            // English
            const englishText = scene.add.text(
                x, y + 15,
                perk.english,
                { fontFamily: 'Arial', fontSize: '20px', color: perk.color }
            ).setOrigin(0.5);
            scene.activePerkCard.push(englishText);

            // Description
            const descText = scene.add.text(
                x, y + 65,
                perk.description,
                { fontFamily: 'Arial', fontSize: '16px', color: '#ffffff', align: 'center' }
            ).setOrigin(0.5);
            scene.activePerkCard.push(descText);

            // Add all card elements to the container
            scene.activePerkCard.forEach(element => {
                scene.pausePerksContainer.add(element);
            });
        }

        // Function to hide perk card
        function hidePerkCard() {
            const scene = this;

            if (scene.activePerkCard) {
                scene.activePerkCard.forEach(element => {
                    element.destroy();
                });
                scene.activePerkCard = null;
            }
        }


        // Perk system helper functions
        function initializePerks() {
            playerPerks = {};
        }

        // Update the acquirePerk function to register perks
        function acquirePerk(scene, perkId) {
            // Skip if already acquired
            if (acquiredPerks.includes(perkId)) return false;

            // Add to acquired perks list
            acquiredPerks.push(perkId);
            activeEffects.activePerks.push(perkId);

            // Apply the perk
            return PerkSystem.applyPerk(scene, perkId);
        }

        // Add this helper function to register effects
        window.registerEffect = function (type, item) {
            if (type === 'timer' && item) {
                activeEffects.timers.push(item);
            } else if (type === 'entity' && item) {
                activeEffects.entities.push(item);
            }
        };

        // Add this cleanup function to your startGame function
        function clearAllPerkEffects() {
            // Clear all timers
            activeEffects.timers.forEach(timer => {
                if (timer) {
                    timer.remove();
                }
            });

            // Clear all entities
            activeEffects.entities.forEach(entity => {
                if (entity && entity.active) {
                    entity.destroy();
                }
            });

            // Reset active effects
            activeEffects.timers = [];
            activeEffects.entities = [];
            activeEffects.activePerks = [];

            // Reset other specific effect variables
            afterImageEnabled = false;
            afterImages = [];
            landmines = [];
            shieldActive = false;
            if (shieldVisual) {
                shieldVisual.setVisible(false);
            }

            // Any other effect-specific cleanup
            orbitingProjectiles = [];
        }

        function resetAllPerks() {
            // Call onReset for all perks that were acquired
            for (const perkId in playerPerks) {
                if (perkRegistry[perkId] && perkRegistry[perkId].onReset) {
                    perkRegistry[perkId].onReset();
                }
            }
            // Reset the perks object
            playerPerks = {};
        }

        function hasPerk(perkId) {
            return acquiredPerks.includes(perkId);
        }

        // Create the game instance
        const game = new Phaser.Game(config);

        function preload() {
            // No image assets to preload
        }

        // debug funcs
        function setupPerformanceMonitor() {
            // Create stats text display (initially hidden)
            statsText = this.add.text(1000, 10, 'FPS: 0', {
                fontFamily: 'Arial',
                fontSize: '14px',
                color: '#00ff00',
                backgroundColor: '#000000',
                padding: { x: 5, y: 5 }
            });
            statsText.setDepth(1000);
            statsText.visible = false;
            statsVisible = false;

            // Add key listener for O key to toggle stats and debug mode
            const keyO = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.O);
            keyO.on('down', function () {
                // Toggle debug mode and stats visibility
                toggleDebugMode.call(this);
            }, this);

            console.log("Performance monitor initialized (press O to toggle)");
        }

        // Function to toggle debug mode and stats
        function toggleDebugMode() {
            // Toggle debug mode
            debugModeEnabled = !debugModeEnabled;

            // Toggle stats visibility
            if (statsText) {
                statsText.visible = debugModeEnabled;
                statsVisible = debugModeEnabled;
            }

            // Toggle physics debug rendering
            this.physics.world.drawDebug = debugModeEnabled;

            // When enabling debug mode, we need to create the debug graphics if it doesn't exist
            if (debugModeEnabled && !this.physics.world.debugGraphic) {
                this.physics.world.createDebugGraphic();
            }

            // Toggle the visibility of the debug graphics
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = debugModeEnabled;
            }

            console.log(`Debug mode ${debugModeEnabled ? 'enabled' : 'disabled'}`);
        }

        // Add this to your update function
        function updatePerformanceStats(time, delta) {
            if (statsText && statsVisible) {
                const fps = Math.round(this.game.loop.actualFps);

                // Get physics bodies count
                let bodyCount = 0;
                if (this.physics && this.physics.world) {
                    bodyCount = this.physics.world.bodies.size;
                }

                // Count active game objects by type
                const totalObjects = this.children.list.length;
                let enemyCount = 0;
                let projectileCount = 0;

                if (enemies) {
                    enemyCount = enemies.getChildren().length;
                }
                if (projectiles) {
                    projectileCount = projectiles.getChildren().length;
                }

                // Calculate frame time from delta
                const frameTime = delta.toFixed(2);

                // Get memory usage if available
                let memoryUsage = "N/A";
                if (window.performance && window.performance.memory) {
                    memoryUsage = Math.round(window.performance.memory.usedJSHeapSize / 1048576) + " MB";
                }

                // Update stats text
                statsText.setText(
                    `DEBUG MODE ON\n` +
                    `FPS: ${fps}\n` +
                    `Frame Time: ${frameTime}ms\n` +
                    `Memory: ${memoryUsage}\n` +
                    `Total Objects: ${totalObjects}\n` +
                    `Enemies: ${enemyCount}\n` +
                    `Projectiles: ${projectileCount}\n` +
                    `Physics Bodies: ${bodyCount}`
                );
            }
        }


        function create() {
            // Initialize perk system first
            initializePerks();

            // Record game start time for difficulty scaling
            gameStartTime = this.time.now;

            // Detect keyboard layout
            detectKeyboardLayout.call(this);

            setupPauseSystem.call(this);
            setupPerformanceMonitor.call(this);

            // Create player text - using kanji character
            player = this.add.text(600, 400, HERO_CHARACTER, {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Store all language and educational properties
            player.hiragana = HERO_HIRAGANA;
            player.romaji = HERO_ROMAJI;
            player.english = HERO_ENGLISH;

            // Add physics to player
            this.physics.world.enable(player);
            player.body.setCollideWorldBounds(true);

            // Create health bar background
            healthBarBg = this.add.rectangle(600, 25, 200, 10, 0x333333);

            // Create health bar
            healthBar = this.add.rectangle(600, 25, 200, 10, 0x00ff00);

            // Create exp bar background
            expBarBg = this.add.rectangle(600, 40, 200, 5, 0x333333);

            // Create exp bar
            expBar = this.add.rectangle(600, 40, 0, 5, 0x00ffff);

            // Create health text
            healthText = this.add.text(
                600, 15,
                `Health: ${playerHealth}/${maxPlayerHealth}`,
                { fontFamily: 'Arial', fontSize: '12px', color: '#ffffff' }
            ).setOrigin(0.5);

            // Create exp text
            expText = this.add.text(
                600, 50,
                `XP: ${heroExp}/${heroExpToLevel}`,
                { fontFamily: 'Arial', fontSize: '12px', color: '#00ffff' }
            ).setOrigin(0.5);

            // Create player stats text
            playerStatsText = this.add.text(
                10, 100,
                `Speed: ${playerSpeed}\nDamage: ${playerDamage}\nLuck: ${playerLuck}`,
                { fontFamily: 'Arial', fontSize: '12px', color: '#ffffff' }
            );

            // Create shield visual (initially invisible)
            shieldVisual = this.add.circle(player.x, player.y, 30, 0x3498db, 0.4);
            shieldVisual.setStrokeStyle(3, 0x0088ff);
            shieldVisual.setVisible(false);

            // Add health regeneration
            setupHealthRegeneration.call(this);

            // Create enemy group
            enemies = this.physics.add.group();

            // Create projectile group
            projectiles = this.physics.add.group();

            // Set up collision between projectiles and enemies
            this.physics.add.collider(projectiles, enemies, projectileHitEnemy, null, this);

            // Set up collision between player and enemies
            this.physics.add.overlap(player, enemies, playerHitEnemy, null, this);

            // Set up cursor keys for movement
            cursors = this.input.keyboard.createCursorKeys();

            // Set up WASD keys for movement based on detected layout
            updateWASDKeys.call(this);

            // Set up touch controls
            this.input.on('pointerdown', (pointer) => {
                touchInput.isActive = true;
                touchInput.x = pointer.x;
                touchInput.y = pointer.y;
            });

            this.input.on('pointermove', (pointer) => {
                if (touchInput.isActive) {
                    touchInput.x = pointer.x;
                    touchInput.y = pointer.y;
                }
            });

            this.input.on('pointerup', () => {
                touchInput.isActive = false;
            });

            // Debug function to lvl up
            setupDebugKeys.call(this);

            // Kill count text (on-screen)
            killCountText = this.add.text(
                600, 65,
                'Enemies killed: 0',
                { fontFamily: 'Arial', fontSize: '14px', color: '#ffffff' }
            ).setOrigin(0.5);

            // Hero level text
            heroLevelText = this.add.text(
                600, 85,
                'Hero Level: 1',
                { fontFamily: 'Arial', fontSize: '14px', color: '#00ffff' }
            ).setOrigin(0.5);

            // Create the game over screen (hidden initially)
            gameOverText = this.add.text(
                600, 400,
                'GAME OVER',
                { fontFamily: 'Arial', fontSize: '40px', color: '#ff0000', fontStyle: 'bold' }
            ).setOrigin(0.5).setVisible(false);

            // Create restart button (hidden initially)
            restartButton = this.add.text(
                600, 600,
                'PLAY AGAIN',
                { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff', backgroundColor: '#880000', padding: { left: 15, right: 15, top: 10, bottom: 10 } }
            ).setOrigin(0.5).setVisible(false).setInteractive();

            // Add restart button functionality
            restartButton.on('pointerdown', startGame, this);

            // Create learning feedback text (initially empty)
            this.learningFeedback = this.add.text(
                600, 770,
                '',
                { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff' }
            ).setOrigin(0.5);

            // Start the game by calling startGame (replaces the need for duplicate initialization)
            startGame.call(this);
        }

        // Modified update function to properly handle difficulty scaling during pauses

        function update(time, delta) {
            if (gameOver) return;
            if (gamePaused) return; // Skip updates when game is paused for level up

            updatePerformanceStats.call(this, time, delta);

            // Increment elapsed time
            elapsedTime += delta / 1000; // delta is in milliseconds

            // Update the level display to show time survived
            const levelDisplay = document.getElementById('level');
            levelDisplay.innerText = `Time Survived: ${formatTime(elapsedTime)}`;

            // Player movement with keyboard
            player.body.setVelocity(0);

            if (cursors.left.isDown || wasdKeys.left.isDown) {
                player.body.setVelocityX(-playerSpeed * 50);
            } else if (cursors.right.isDown || wasdKeys.right.isDown) {
                player.body.setVelocityX(playerSpeed * 50);
            }

            if (cursors.up.isDown || wasdKeys.up.isDown) {
                player.body.setVelocityY(-playerSpeed * 50);
            } else if (cursors.down.isDown || wasdKeys.down.isDown) {
                player.body.setVelocityY(playerSpeed * 50);
            }

            // Player movement with touch
            if (touchInput.isActive) {
                // Calculate direction vector
                const dx = touchInput.x - player.x;
                const dy = touchInput.y - player.y;

                // Normalize and scale
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) {  // Add a small threshold to prevent jitter
                    player.body.setVelocityX((dx / distance) * playerSpeed * 50);
                    player.body.setVelocityY((dy / distance) * playerSpeed * 50);
                }
            }

            // Update enemies to follow player
            enemies.getChildren().forEach(enemy => {
                this.physics.moveToObject(enemy, player, enemy.speed);
            });

            // Keep shield visual positioned on player
            if (shieldVisual) {
                shieldVisual.x = player.x;
                shieldVisual.y = player.y;
            }

            // Update orbiting projectiles
            orbitingProjectiles.forEach(projectile => {
                if (projectile && projectile.active) {
                    updateOrbitingProjectile(projectile, player);
                }
            });

            // Update projectiles (destroy if out of bounds)
            projectiles.getChildren().forEach(projectile => {
                if (projectile.y < -50 || projectile.y > 850 ||
                    projectile.x < -50 || projectile.x > 1250) {
                    projectile.destroy();
                }
            });

            // Update health bar
            updateHealthBar();

            // Update UI
            document.getElementById('kills').textContent = `Enemies killed: ${score}`;

            // Update in-game kill count
            killCountText.setText(`Enemies killed: ${score}`);

            // Update health and exp text
            healthText.setText(`Health: ${Math.ceil(playerHealth)}/${maxPlayerHealth}`);
            expText.setText(`XP: ${heroExp}/${heroExpToLevel}`);

            // Calculate difficulty scaling based on elapsed time instead of raw time
            const minutesElapsed = elapsedTime / 60;

            // Update the spawn rate gradually by modifying the existing timer
            if (enemySpawner) {
                // Calculate new delay based on time played
                const newSpawnDelay = Math.max(200, baseSpawnDelay / Math.pow(enemyCountScaleFactor, minutesElapsed));

                // If the timer needs updating, adjust it
                if (Math.abs(enemySpawner.delay - newSpawnDelay) > (enemySpawner.delay * 0.1)) {
                    // Gradually transition to the new delay rather than recreating the timer
                    enemySpawner.delay = newSpawnDelay;
                    enemySpawner.reset({
                        delay: newSpawnDelay,
                        callback: spawnEnemy,
                        callbackScope: this,
                        loop: true
                    });
                }
            }

            // Update current enemy health based on elapsed time (optional scaling)
            currentEnemyHealth = baseEnemyHealth * Math.pow(enemyHealthScaleFactor, minutesElapsed);

            // Update player stats text
            updatePlayerStatsText();

            // Update player level
            if (heroExp >= heroExpToLevel) {
                levelUp.call(this);
            }
        }

        // Modified spawnEnemy function to use the currentEnemyHealth value calculated in update
        function spawnEnemy() {
            if (gameOver) return;

            // Choose a random enemy type
            const enemyType = getRandomEnemyType();

            // Get the enemy data with defaults applied
            const enemyData = getEnemyData(enemyType);

            // Choose a random spawn position outside the screen
            let x, y;
            if (Math.random() < 0.5) {
                // Spawn on left or right side
                x = Math.random() < 0.5 ? -50 : 1250;
                y = Phaser.Math.Between(50, 750);
            } else {
                // Spawn on top or bottom
                x = Phaser.Math.Between(50, 1150);
                y = Math.random() < 0.5 ? -50 : 850;
            }

            // Create the enemy with data-driven properties
            const enemy = this.add.text(x, y, enemyType, {
                fontFamily: 'Arial',
                fontSize: `${enemyData.size}px`,
                color: enemyData.color,
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Add to physics group
            enemies.add(enemy);

            // Set enemy properties
            enemy.body.setSize(enemy.width, enemy.height);
            enemy.body.setCollideWorldBounds(false);

            // Set enemy health based on data and current scaling
            // Use the currentEnemyHealth value that's updated in the update function
            enemy.health = Math.ceil(currentEnemyHealth * enemyData.healthMultiplier);

            // Set enemy speed based on data
            enemy.speed = Phaser.Math.Between(enemyData.speedMin, enemyData.speedMax);

            // Store additional properties from data
            enemy.damage = enemyData.damage;
            enemy.rank = enemyData.rank;
            enemy.expValue = enemyData.expValue || 1;

            // Store all language and educational properties
            enemy.hiragana = enemyData.hiragana;
            enemy.romaji = enemyData.romaji;
            enemy.english = enemyData.english;
        }

        // Store all game timers in a central array
        let gameTimers = [];

        // Register a timer with the central system
        function registerTimer(timer) {
            gameTimers.push(timer);
            return timer; // Return the timer for convenience
        }

        // Enhanced pauseGame function
        function pauseGame() {
            // Set the flag
            gamePaused = true;

            // Pause physics
            const activeScene = game.scene.scenes[0];
            if (activeScene && activeScene.physics) {
                activeScene.physics.pause();
            }

            // Pause all timers
            gameTimers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = true;
                }
            });
        }

        // Resume the game and hide overlay
        function resumeGame() {
            if (gameOver) return;

            // Hide pause screen elements
            if (pauseScreen) pauseScreen.setVisible(false);
            if (pauseMessage) pauseMessage.setVisible(false);
            if (resumeButton) resumeButton.setVisible(false);

            // Hide perks container
            const scene = game.scene.scenes[0];
            if (scene && scene.pausePerksContainer) {
                scene.pausePerksContainer.setVisible(false);
            }

            // Set pause flag
            gamePaused = false;

            // Resume physics
            const activeScene = game.scene.scenes[0];
            if (activeScene && activeScene.physics) {
                activeScene.physics.resume();
            }

            // Resume all timers
            gameTimers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = false;
                }
            });

            console.log("Game resumed");
        }


        // Clean up timers that are no longer active
        function cleanupTimers() {
            gameTimers = gameTimers.filter(timer =>
                timer && !timer.hasOwnProperty('removed') && !timer.removed);
        }

        // Setup health regeneration
        function setupHealthRegeneration() {
            // Calculate delay based on max health (100s / maxHealth)
            const regenDelay = Math.ceil(100000 / maxPlayerHealth); // In milliseconds

            // Remove any existing regen timer
            if (healthRegenTimer) {
                healthRegenTimer.remove();
            }

            // Create and register health regeneration timer
            healthRegenTimer = registerTimer(this.time.addEvent({
                delay: regenDelay,
                callback: regenerateHealth,
                callbackScope: this,
                loop: true
            }));

            console.log(`Health regeneration timer set: +1 HP every ${regenDelay / 1000} seconds`);
        }

        function regenerateHealth() {
            if (gameOver || gamePaused) return;

            // Only regenerate if health is below max
            if (playerHealth < maxPlayerHealth) {
                // Add 1 HP
                playerHealth = Math.min(playerHealth + 1, maxPlayerHealth);

                // Update health bar and text
                updateHealthBar();

                // Show visual effect
                showRegenEffect(this);
            }
        }

        function showRegenEffect(scene) {
            // Create a healing indicator
            const healEffect = scene.add.text(player.x, player.y - 20, '+1', {
                fontFamily: 'Arial',
                fontSize: '16px',
                color: '#00ff00'
            }).setOrigin(0.5);

            // Animate the healing indicator
            scene.tweens.add({
                targets: healEffect,
                y: healEffect.y - 15,
                alpha: 0,
                duration: 800,
                onComplete: function () {
                    healEffect.destroy();
                }
            });
        }

        function updateHealthBar() {
            const healthPercentage = playerHealth / maxPlayerHealth;
            healthBar.width = healthPercentage * 200;
            healthBar.x = 500 + (healthBar.width / 2);

            // Show only integer health in display, but use decimal precision internally
            healthText.setText(`Health: ${Math.floor(playerHealth)}/${maxPlayerHealth}`);
        }

        function updateExpBar() {
            const expPercentage = heroExp / heroExpToLevel;
            expBar.width = expPercentage * 200;
            expBar.x = 500 + (expBar.width / 2);
            expText.setText(`XP: ${heroExp}/${heroExpToLevel}`);
        }

        function levelUp() {
            playerLevel++; // Level up
            heroExpToLevel = xpForNextLevel(playerLevel); // Update XP needed for the next level
            heroExp = 0; // Reset XP
            heroLevelText.setText(`Hero Level: ${playerLevel}`);
            showLevelUpCards.call(this);
        }

        function updatePlayerStatsText() {
            // Build the stats text based on current stats, without listing perks
            let statsText = `POW: ${playerDamage}\nAGI: ${playerFireRate}\nLUK: ${playerLuck}\nEND: ${maxPlayerHealth}`;

            // Update the text
            playerStatsText.setText(statsText);
        }

        function fireProjectile() {
            if (gameOver) return;

            // Find the closest enemy within 400px
            let closestEnemy = null;
            let closestDistance = 400;

            enemies.getChildren().forEach(enemy => {
                if (!enemy) return; // Skip if enemy is null or undefined

                const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEnemy = enemy;
                }
            });

            if (closestEnemy) {
                // Calculate direction to the enemy
                const angle = Phaser.Math.Angle.Between(player.x, player.y, closestEnemy.x, closestEnemy.y);

                // Create the main projectile
                createSingleProjectile.call(this, angle);

                // Check for double shot if we have that perk
                if (hasPerk('PURPLE_OWL')) {
                    const doubleChance = playerLuck / BASE_STATS.LUK * 0.08; // 8% base chance scaled by luck
                    if (Math.random() < doubleChance) {
                        // Fire a second projectile with slight angle variation
                        const angleVariation = (Math.random() - 0.5) * 0.2; // Small random angle variation
                        createSingleProjectile.call(this, angle + angleVariation);
                    }
                }
            }
        }

        // Dedicated function for creating projectiles
        function createProjectileBase(scene, x, y, color = '#ffff00', symbol = 'â˜…') {
            // Create the projectile
            const projectile = scene.add.text(x, y, symbol, {
                fontFamily: 'Arial',
                fontSize: `${projectileSizeFactor * playerDamage}px`,
                color: color,
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Add to physics group
            projectiles.add(projectile);

            // Set projectile properties (smaller hitbox for better visual feel)
            projectile.body.setSize(projectile.width / 2, projectile.height / 2);

            // Set base damage value
            projectile.damage = playerDamage;

            // Return the created projectile
            return projectile;
        }

        function createSingleProjectile(angle) {
            // Create base projectile
            const projectile = createProjectileBase(this, player.x, player.y);

            // Set projectile velocity based on angle
            const speed = 400;
            projectile.body.setVelocity(
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
            );

            // Apply slow effect if we have that perk
            projectile.isSlowShot = false;
            if (hasPerk('SLOW_SHOT')) {
                const slowChance = playerLuck / BASE_STATS.LUK * 0.05; // 5% base chance scaled by luck
                projectile.isSlowShot = Math.random() < slowChance;
                if (projectile.isSlowShot) {
                    projectile.setColor('#00ffff'); // Cyan color for slow shots
                }
            }
        }

        // Unified projectile hit enemy function
        function projectileHitEnemy(projectile, enemy) {
            // Skip if projectile is already destroyed
            if (!projectile.active || !enemy.active) return;

            // Apply damage to enemy
            enemy.health -= projectile.damage;

            // Apply slow effect if it's a slow shot
            if (projectile.isSlowShot) {
                // Slow the enemy by half
                enemy.speed = Math.max(10, enemy.speed * 0.5);

                // Add visual indication of slowed enemy
                enemy.setColor('#00ffff'); // Cyan color for slowed enemies

                // For longer slow duration, you could add a timer to reset color
                this.time.delayedCall(2000, function () {
                    if (enemy && enemy.active) {
                        enemy.setColor('#ff5555');
                    }
                });
            }

            // Only destroy enemy if health is 0 or below
            if (enemy.health <= 0) {
                // Display kanji information in the learning feedback area
                if (this.learningFeedback) {
                    this.learningFeedback.setText(
                        `Defeated ${enemy.text} (${enemy.hiragana}) [${enemy.romaji}] - ${enemy.english}`
                    );

                    // Flash or highlight the text to draw attention
                    this.tweens.add({
                        targets: this.learningFeedback,
                        alpha: { from: 0.5, to: 1 },
                        duration: 300,
                        ease: 'Cubic.out'
                    });
                }

                enemy.destroy();

                // Increment score
                score++;

                // Add experience
                heroExp++;

                // Update exp bar
                updateExpBar();
            } else {
                // Flash the enemy when hit but not destroyed
                this.tweens.add({
                    targets: enemy,
                    alpha: 0.3,
                    duration: 50,
                    yoyo: true,
                    repeat: 1
                });
            }

            // Handle projectile destruction
            if (!projectile.isLandmine) {
                // Handle special projectile removal (orbiting, etc.)
                if (projectile.isOrbiting) {
                    // Remove from orbiting projectiles array
                    const index = orbitingProjectiles.indexOf(projectile);
                    if (index !== -1) {
                        orbitingProjectiles.splice(index, 1);
                    }
                }

                // Standard projectile removal
                projectile.destroy();
            } else {
                // Landmines are destroyed after they hit something
                projectile.destroy();
            }

        }

        function playerHitEnemy(player, enemy) {
            // Check if player was already hit
            if (playerInvincible) return;

            // Make the player invincible to damage while flashing
            playerInvincible = true;

            // Flash the player when hit
            this.tweens.add({
                targets: player,
                alpha: 0.5,
                scale: 1.2,
                duration: 250,
                yoyo: true,
                repeat: 1,
                onComplete: function () {
                    // Ensure alpha is reset properly
                    player.alpha = 1;
                    player.scale = 1;
                }
            });

            // Remove invincibility after 500ms
            this.time.delayedCall(500, function () {
                playerInvincible = false;

                // Double-check alpha is reset even if tween was interrupted
                if (player.active) {
                    player.alpha = 1;
                    player.scale = 1;
                }
            });

            // Check for Purple Hedgehog perk and trigger defensive burst
            if (hasPerk('PURPLE_HEDGEHOG')) {
                triggerDefensiveBurst.call(this);
            }

            if (shieldActive) {
                // Shield absorbs the hit
                shieldActive = false;
                shieldVisual.setVisible(false);

                // Flash the shield effect
                this.tweens.add({
                    targets: player,
                    alpha: 0.5,
                    scale: 1.2,
                    duration: 100,
                    yoyo: true,
                    repeat: 1
                });

                // Start shield cooldown with the base duration (16 seconds)
                // The function will apply the Luck multiplier internally
                window.startShieldCooldown(16000);

                return;

                // Show cooldown notification
                const cooldownSeconds = (cooldownTime / 1000).toFixed(1);
                const cooldownNotification = this.add.text(player.x, player.y - 40, `SHIELD COOLDOWN: ${cooldownSeconds}s`, {
                    fontFamily: 'Arial',
                    fontSize: '14px',
                    color: '#e74c3c'
                }).setOrigin(0.5);

                // Animate the notification
                this.tweens.add({
                    targets: cooldownNotification,
                    y: cooldownNotification.y - 20,
                    alpha: 0,
                    duration: 1000,
                    onComplete: function () {
                        cooldownNotification.destroy();
                    }
                });

                return;
            }

            // Apply damage to player
            playerHealth -= enemyDamage;

            // Update health text and bar
            updateHealthBar();

            // Check if player is dead
            if (playerHealth < 1) {
                playerDeath.call(this);
            }
        }

        // Function to create the defensive burst effect (simplified)
        function triggerDefensiveBurst() {
            // Calculate number of projectiles based on luck (2 * LUCK)
            const projectileCount = playerLuck * 2;

            // Visual effect at player position
            const burstEffect = this.add.circle(player.x, player.y, 40, 0x9370db, 0.5);
            this.tweens.add({
                targets: burstEffect,
                alpha: 0,
                scale: 2,
                duration: 300,
                onComplete: function () {
                    burstEffect.destroy();
                }
            });

            // Create each projectile in the burst
            for (let i = 0; i < projectileCount; i++) {
                // Calculate angle for even distribution (in radians)
                const angle = (i / projectileCount) * Math.PI * 2;

                // Create projectile using shared base
                const projectile = createProjectileBase(this, player.x, player.y, '#9370db');

                // Set velocity based on angle
                const speed = 400;
                projectile.body.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );

                // Add special property
                projectile.isDefensiveBurst = true;
            }
        }

        function playerDeath() {
            // Set game over state
            gameOver = true;

            // Pause the game physics to stop all movement
            pauseGame();

            // Show game over text and restart button
            gameOverText.setText(`GAME OVER\nTime Survived: ${formatTime(elapsedTime)}\nEnemies killed: ${score}`);
            gameOverText.setVisible(true);
            restartButton.setVisible(true);
        }

        function showLevelUpCards() {
            // Pause the game
            pauseGame();

            // Create semi-transparent background
            const levelUpBackground = this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.7);

            // Create level up title
            const levelUpTitle = this.add.text(
                600, 250,
                'LEVEL UP! Choose a perk:',
                { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff', fontStyle: 'bold' }
            ).setOrigin(0.5);

            // Get random perks (excluding already acquired ones)
            const selectedPerks = PerkSystem.getRandomPerks(3, acquiredPerks);

            // Create three card choices
            const card1 = this.add.rectangle(300, 400, 200, 300, 0x444444, 1).setStrokeStyle(2, 0x000000);
            const card2 = this.add.rectangle(600, 400, 200, 300, 0x444444, 1).setStrokeStyle(2, 0x000000);
            const card3 = this.add.rectangle(900, 400, 200, 300, 0x444444, 1).setStrokeStyle(2, 0x000000);

            // Add card titles and descriptions based on selected perks
            const cardElements = [];

            for (let i = 0; i < 3; i++) {
                const cardX = 300 + (i * 300);
                const perk = selectedPerks[i];

                if (!perk) continue; // Skip if we have fewer than 3 available perks

                // Create kanji (larger font)
                const kanjiText = this.add.text(
                    cardX, 340,
                    perk.kanji,
                    { fontFamily: 'Arial', fontSize: '36px', color: perk.color, fontStyle: 'bold' }
                ).setOrigin(0.5);

                // Create hiragana - romaji
                const readingText = this.add.text(
                    cardX, 385,
                    `${perk.hiragana} - ${perk.romaji}`,
                    { fontFamily: 'Arial', fontSize: '18px', color: '#ffffff' }
                ).setOrigin(0.5);

                // Create english
                const englishText = this.add.text(
                    cardX, 415,
                    perk.english,
                    { fontFamily: 'Arial', fontSize: '20px', color: perk.color }
                ).setOrigin(0.5);

                // Create description (with a line break)
                const descText = this.add.text(
                    cardX, 465,
                    perk.description,
                    { fontFamily: 'Arial', fontSize: '16px', color: '#ffffff', align: 'center' }
                ).setOrigin(0.5);

                // Add to elements array
                cardElements.push(kanjiText, readingText, englishText, descText);

                // Set card data
                const card = [card1, card2, card3][i];
                card.perkId = perk.id;

                // Add hover effects
                card.setInteractive()
                    .on('pointerover', function () {
                        this.fillColor = perk.hoverColor;
                    })
                    .on('pointerout', function () {
                        this.fillColor = 0x444444;
                    })
                    .on('pointerdown', () => selectCard.call(this, perk.id));
            }

            // Store all level up UI elements
            levelUpCards = [
                levelUpBackground, levelUpTitle,
                card1, card2, card3,
                ...cardElements
            ];
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function selectCard(perkType) {
            // Acquire the selected perk
            acquirePerk(this, perkType);

            // Update player stats text
            updatePlayerStatsText();

            // Update health bar
            updateHealthBar();

            // Close the cards and resume the game
            closeLevelUpCards.call(this);

            // Flash the hero when completing level up
            this.tweens.add({
                targets: player,
                alpha: 0.2,
                scale: 1.5,
                duration: 200,
                yoyo: true,
                repeat: 1,
                onComplete: function () {
                    player.setScale(1);
                    player.alpha = 1;
                }
            });
        }

        function closeLevelUpCards() {
            // Remove all level up UI elements
            levelUpCards.forEach(element => element.destroy());
            levelUpCards = [];

            resumeGame();
        }

        function detectKeyboardLayout() {
            // Detect keyboard layout
            try {
                // Check for navigator.keyboard API support (modern browsers)
                if (navigator.keyboard && navigator.keyboard.getLayoutMap) {
                    navigator.keyboard.getLayoutMap()
                        .then(keyboardLayoutMap => {
                            // Check for AZERTY layout by looking at the key for 'KeyQ'
                            const qKey = keyboardLayoutMap.get('KeyQ');
                            if (qKey === 'a' || qKey === 'A') {
                                // AZERTY detected
                                keyboardLayout = 'azerty';
                                updateWASDKeys.call(this);
                            }
                        })
                        .catch(error => {
                            console.log('Error detecting keyboard layout:', error);
                        });
                } else {
                    // Fallback method: check browser language
                    const language = navigator.language || navigator.userLanguage;
                    if (language && (language.startsWith('fr') || language.startsWith('be'))) {
                        // French or Belgian language often uses AZERTY
                        keyboardLayout = 'azerty';
                        updateWASDKeys.call(this);
                    }
                }
            } catch (error) {
                console.log('Error in keyboard layout detection:', error);
            }

            // Update the controls text
            updateControlsText.call(this);
        }

        function updateWASDKeys() {
            // Update keys based on detected layout
            if (keyboardLayout === 'azerty') {
                // AZERTY layout uses ZQSD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.Z,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.Q,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            } else {
                // QWERTY layout uses WASD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.W,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.A,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            }
        }

        function updateControlsText() {
            // Update the controls text based on the detected keyboard layout
            let controlsInfo = 'Controls: Arrow Keys';

            if (keyboardLayout === 'azerty') {
                controlsInfo += ' or ZQSD';
            } else {
                controlsInfo += ' or WASD';
            }

            controlsInfo += ' or Touch/Click to move';

            if (this.controlsText) {
                this.controlsText.setText(controlsInfo);
            }
        }

        // Updated modifyStat function that handles negative values
        window.modifyStat = function (statName, amount) {
            switch (statName) {
                case 'damage':
                    playerDamage += amount;
                    // Ensure damage doesn't go below 1
                    playerDamage = Math.max(1, playerDamage);
                    break;
                case 'speed':
                    playerSpeed += amount;
                    // Ensure speed doesn't go below 1
                    playerSpeed = Math.max(1, playerSpeed);
                    break;
                case 'health':
                    maxPlayerHealth += amount;
                    // Ensure maxHealth doesn't go below 1
                    maxPlayerHealth = Math.max(1, maxPlayerHealth);
                    // If reducing max health, also cap current health
                    if (amount < 0 && playerHealth > maxPlayerHealth) {
                        playerHealth = maxPlayerHealth;
                    } else if (amount > 0) {
                        // If increasing max health, also increase current health
                        playerHealth += amount;
                    }
                    const scene = game.scene.scenes[0];
                    if (scene) {
                        setupHealthRegeneration.call(scene);
                    }
                    break;
                case 'luck':
                    playerLuck += amount;
                    // Ensure luck doesn't go below 1
                    playerLuck = Math.max(1, playerLuck);
                    break;
                case 'fireRate':
                    playerFireRate += amount;

                    // Ensure fire rate doesn't go below 1
                    playerFireRate = Math.max(1, playerFireRate);

                    // Update the projectile timer if it exists
                    if (projectileFirer) {
                        const newDelay = shootingDelay / playerFireRate;
                        projectileFirer.delay = newDelay;

                        // Reset with proper callback scope
                        projectileFirer.reset({
                            delay: newDelay,
                            callback: fireProjectile,
                            callbackScope: game.scene.scenes[0],
                            loop: true
                        });
                    }
                    break;
            }
            // Update UI
            updatePlayerStatsText();
        };

        // Add shield cooldown functionality
        window.activateShield = function () {
            // Get the current active scene
            const scene = game.scene.scenes[0];

            // Activate the shield
            shieldActive = true;
            if (shieldVisual) {
                shieldVisual.setVisible(true);

                // Add a visual effect
                scene.tweens.add({
                    targets: shieldVisual,
                    scale: { from: 0.5, to: 1 },
                    alpha: { from: 0.8, to: 0.4 },
                    duration: 500,
                    ease: 'Cubic.out'
                });
            }
        };

        // Function to start shield cooldown
        window.startShieldCooldown = function (baseDuration = 16000) {
            // Get the current active scene
            const scene = game.scene.scenes[0];

            // Calculate actual duration based on Luck (higher luck = lower multiplier)
            const luckMultiplier = BASE_STATS.LUK / playerLuck;
            const duration = baseDuration * luckMultiplier;

            // Set up a new cooldown timer
            shieldCooldownTimer = scene.time.delayedCall(
                duration,
                function () {
                    window.activateShield();

                    // Add a text notification
                    const notification = scene.add.text(player.x, player.y - 50, 'SHIELD READY!', {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        color: '#3498db'
                    }).setOrigin(0.5);

                    // Animate the notification
                    scene.tweens.add({
                        targets: notification,
                        y: notification.y - 30,
                        alpha: 0,
                        duration: 1500,
                        onComplete: function () { notification.destroy(); }
                    });

                    // Clear the cooldown timer reference
                    shieldCooldownTimer = null;
                },
                [],
                scene
            );

            // Show cooldown notification
            const cooldownSeconds = (duration / 1000).toFixed(1);
            const cooldownNotification = scene.add.text(player.x, player.y - 40, `SHIELD COOLDOWN: ${cooldownSeconds}s`, {
                fontFamily: 'Arial',
                fontSize: '14px',
                color: '#e74c3c'
            }).setOrigin(0.5);

            // Animate the notification
            scene.tweens.add({
                targets: cooldownNotification,
                y: cooldownNotification.y - 20,
                alpha: 0,
                duration: 1000,
                onComplete: function () {
                    cooldownNotification.destroy();
                }
            });
        };

        window.activateOrbitingProjectile = function () {
            // Get the current active scene
            const scene = game.scene.scenes[0];
            if (scene) {
                // First spawn one immediately
                spawnOrbitingProjectile.call(scene);

                // Then set up the timer for regular spawning
                if (orbitingProjectileTimer) {
                    orbitingProjectileTimer.remove();
                }

                // Calculate cooldown based on Luck
                const baseCooldown = 4000; // 4 seconds base cooldown
                const luckMultiplier = BASE_STATS.AGI / playerLuck;
                const actualCooldown = baseCooldown * luckMultiplier;

                // Create and properly register the timer
                orbitingProjectileTimer = registerTimer(scene.time.addEvent({
                    delay: actualCooldown,
                    callback: spawnOrbitingProjectile,
                    callbackScope: scene,
                    loop: true
                }));

                // Also register with perk effects system
                window.registerEffect('timer', orbitingProjectileTimer);
            }
        };

        window.activateLandmines = function () {
            // Get the current active scene
            const scene = game.scene.scenes[0];
            if (scene) {
                // First drop one immediately
                dropLandmine.call(scene);

                // Then set up the timer for regular drops
                if (landmineTimer) {
                    landmineTimer.remove();
                }

                // Calculate cooldown based on Agility
                const baseCooldown = 4000; // 4 seconds base cooldown
                const luckMultiplier = BASE_STATS.AGI / playerFireRate;
                const actualCooldown = baseCooldown * luckMultiplier;

                // Create and properly register the timer
                landmineTimer = registerTimer(scene.time.addEvent({
                    delay: actualCooldown,
                    callback: dropLandmine,
                    callbackScope: scene,
                    loop: true
                }));

                // Also register with perk effects system
                window.registerEffect('timer', landmineTimer);
            }
        };

        function dropLandmine() {
            // Create a landmine at the player's current position with gold color
            const landmine = createProjectileBase(this, player.x, player.y, '#ffbf00');

            // Special landmine properties
            landmine.body.immovable = true; // Landmine doesn't move when hit
            landmine.isLandmine = true;

            // Register entity for cleanup
            window.registerEffect('entity', landmine);

            // Flash effect when spawning
            this.tweens.add({
                targets: landmine,
                scale: { from: 0.5, to: 1 },
                alpha: { from: 0.2, to: 1 },
                duration: 300,
                ease: 'Bounce.out'
            });
        }

        // Function to fully heal the player
        window.fullHeal = function () {
            playerHealth = maxPlayerHealth;

            // Update the health bar
            updateHealthBar();

            // Visual effect to show healing
            const scene = game.scene.scenes[0];
            if (scene) {
                // Show healing particles or effect
                const healEffect = scene.add.text(player.x, player.y - 40, '+HEAL', {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#00ff00'
                }).setOrigin(0.5);

                // Animate the effect
                scene.tweens.add({
                    targets: healEffect,
                    y: healEffect.y - 30,
                    alpha: 0,
                    duration: 1000,
                    onComplete: function () {
                        healEffect.destroy();
                    }
                });
            }
        };

        function spawnOrbitingProjectile() {
            // Create an orbiting projectile with orange color
            const projectile = createProjectileBase(this, player.x, player.y, '#ff9900');

            // Set as orbiting projectile
            projectile.isOrbiting = true;
            projectile.orbitAngle = Math.random() * Math.PI * 2; // Random starting angle
            projectile.orbitRadius = 12 * playerLuck; // Distance from player
            projectile.orbitSpeed = 0.01; // Speed of orbit

            // Add to orbiting projectiles array
            orbitingProjectiles.push(projectile);

            // Register entity for cleanup
            window.registerEffect('entity', projectile);

            // Flash effect when spawning
            this.tweens.add({
                targets: projectile,
                scale: { from: 2, to: 1 },
                alpha: { from: 0.8, to: 1 },
                duration: 300,
                ease: 'Cubic.out'
            });
        }

        // Ensure the updateOrbitingProjectile function is called in the update loop
        function updateOrbitingProjectile(projectile, playerObj) {
            if (!projectile || !projectile.active) return;

            // Update the orbit angle
            projectile.orbitAngle += projectile.orbitSpeed;

            // Calculate new position based on player position and orbit angle
            const x = playerObj.x + Math.cos(projectile.orbitAngle) * projectile.orbitRadius;
            const y = playerObj.y + Math.sin(projectile.orbitAngle) * projectile.orbitRadius;

            // Update projectile position
            projectile.setPosition(x, y);
        }

        window.activateAfterImages = function () {
            // Get the current active scene
            const scene = game.scene.scenes[0];
            if (scene) {
                console.log("Activating after-images with transparency fix");
                afterImageEnabled = true;

                // Clear any existing after images
                afterImages.forEach(image => {
                    if (image && image.active) {
                        image.destroy();
                    }
                });
                afterImages = [];

                // Reset position history with current position
                playerPositionHistory = [];

                // Fill history with current position
                for (let i = 0; i < 80; i++) {
                    playerPositionHistory.push({ x: player.x, y: player.y });
                }

                // Create after images with proper alpha values
                for (let i = 0; i < 4; i++) {
                    const alphaValue = 0.4;

                    // Create the text object with explicit alpha setting
                    const afterImage = scene.add.text(player.x, player.y, HERO_CHARACTER, {
                        fontFamily: 'Arial',
                        fontSize: '32px',
                        color: '#00cc66'
                    }).setOrigin(0.5);

                    // Set alpha as a separate property to ensure it's applied
                    afterImage.alpha = alphaValue;

                    // Ensure these render behind the player
                    afterImage.setDepth(player.depth - 1);

                    // Add to physics group for collision detection
                    scene.physics.world.enable(afterImage);
                    afterImage.body.setSize(afterImage.width, afterImage.height);

                    // Add damage property
                    afterImage.damage = playerDamage;

                    // Register entity for cleanup
                    window.registerEffect('entity', afterImage);

                    // Add to array
                    afterImages.push(afterImage);
                }

                // Remove any existing timer
                if (afterImageTimer) {
                    afterImageTimer.remove();
                    afterImageTimer = null;
                }

                // Create a new timer and register it properly
                afterImageTimer = registerTimer(scene.time.addEvent({
                    delay: 20,
                    callback: updateAfterImages,
                    callbackScope: scene,
                    loop: true
                }));

                // Also register with perk effects system
                window.registerEffect('timer', afterImageTimer);

                // Add overlap detection with enemies
                scene.physics.add.overlap(afterImages, enemies, afterImageHitEnemy, null, scene);

                // Visual effect for activation
                const activationEffect = scene.add.text(player.x, player.y - 50, 'AFTER-IMAGES ACTIVATED!', {
                    fontFamily: 'Arial',
                    fontSize: '16px',
                    color: '#00cc66'
                }).setOrigin(0.5);

                scene.tweens.add({
                    targets: activationEffect,
                    y: activationEffect.y - 30,
                    alpha: 0,
                    duration: 1500,
                    onComplete: function () {
                        activationEffect.destroy();
                    }
                });
            }
        };

        // Separate update function outside the timer callback
        function updateAfterImages() {
            // Verify that the feature is enabled and we have a player
            if (!afterImageEnabled || !player || !player.active) {
                return;
            }

            // Add current position to history
            playerPositionHistory.unshift({ x: player.x, y: player.y });

            // Limit history size
            if (playerPositionHistory.length > 80) {
                playerPositionHistory = playerPositionHistory.slice(0, 80);
            }

            // Update after-image positions
            for (let i = 0; i < afterImages.length; i++) {
                const image = afterImages[i];
                if (image && image.active) {
                    // Use fixed spacing for each image
                    const posIndex = 16 + (i * 16);

                    // Always use a valid index
                    const safeIndex = Math.min(posIndex, playerPositionHistory.length - 1);

                    // Set position and log first image position occasionally
                    image.setPosition(
                        playerPositionHistory[safeIndex].x,
                        playerPositionHistory[safeIndex].y
                    );
                }
            }
        }

        function cleanupAfterImages() {
            console.log("Cleaning up after-images");

            // Stop the timer first
            if (afterImageTimer) {
                console.log("Removing after-image timer");
                afterImageTimer.remove();
                afterImageTimer = null;
            }

            // Then destroy all images
            afterImages.forEach((image, index) => {
                if (image && image.active) {
                    console.log(`Destroying after-image ${index}`);
                    image.destroy();
                }
            });

            // Clear arrays
            afterImages = [];
            playerPositionHistory = [];

            // Reset flag
            afterImageEnabled = false;

            console.log("After-image cleanup complete");
        }

        function afterImageHitEnemy(afterImage, enemy) {
            // Skip if either object is already destroyed
            if (!afterImage.active || !enemy.active) return;

            // Apply damage to enemy (once per second to avoid rapid damage)
            if (!enemy.lastAfterImageHit || (this.time.now - enemy.lastAfterImageHit > 1000)) {
                enemy.health -= afterImage.damage;
                enemy.lastAfterImageHit = this.time.now;

                // Visual effect for damage
                this.tweens.add({
                    targets: enemy,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 1
                });

                // Check if enemy is defeated
                if (enemy.health <= 0) {
                    // Display kanji information
                    if (this.learningFeedback) {
                        this.learningFeedback.setText(
                            `Defeated ${enemy.text} (${enemy.hiragana}) [${enemy.romaji}] - ${enemy.english}`
                        );

                        this.tweens.add({
                            targets: this.learningFeedback,
                            alpha: { from: 0.5, to: 1 },
                            duration: 300,
                            ease: 'Cubic.out'
                        });
                    }

                    enemy.destroy();
                    score++;
                    heroExp++;
                    updateExpBar();
                }
            }
        }

        // DEBUG FUNCTIONS
        function setupDebugKeys() {
            // Add debug key (R key for instant level up)
            this.input.keyboard.on('keydown-R', function (event) {
                if (!gamePaused && !gameOver) {
                    // Add enough XP to level up
                    const xpNeeded = heroExpToLevel - heroExp;
                    heroExp += xpNeeded;
                    updateExpBar();
                    console.log("Debug: Instant level up triggered");
                }
            });
        }


        function startGame() {
            // Reset game state variables
            gameOver = false;
            gamePaused = false;
            elapsedTime = 0;
            score = 0;
            level = 1;

            // Clean up old timers
            cleanupTimers();

            // Hide pause screen if it was visible
            if (pauseScreen) pauseScreen.setVisible(false);
            if (pauseMessage) pauseMessage.setVisible(false);
            if (resumeButton) resumeButton.setVisible(false);

            // Reset player stats to base values
            playerHealth = basePlayerHealth;
            maxPlayerHealth = baseMaxHealth;
            playerSpeed = basePlayerSpeed;
            playerDamage = basePlayerDamage;
            playerLuck = basePlayerLuck;
            playerFireRate = basePlayerFireRate;

            // Reset XP and level
            heroExp = 0;
            playerLevel = 1;
            heroExpToLevel = xpForNextLevel(playerLevel);

            // Reset player position
            player.x = 600;
            player.y = 400;

            // Reset UI
            heroLevelText.setText('Hero Level: 1');
            player.setFontSize(32);
            healthBar.width = 200;
            healthBar.x = 600;
            healthBar.fillColor = 0x00ff00;
            healthText.setText(`Health: ${playerHealth}/${maxPlayerHealth}`);
            expBar.width = 0;
            expBar.x = 500;
            expText.setText(`XP: 0/${heroExpToLevel}`);
            killCountText.setText('Enemies killed: 0');

            // Reset all perk effects
            clearAllPerkEffects();
            acquiredPerks = [];

            // Reset player stats to base values
            playerHealth = basePlayerHealth;
            maxPlayerHealth = baseMaxHealth;
            playerSpeed = basePlayerSpeed;
            playerDamage = basePlayerDamage;
            playerLuck = basePlayerLuck;
            playerFireRate = basePlayerFireRate;

            // Clear learning feedback
            if (this.learningFeedback) {
                this.learningFeedback.setText('');
            }

            // Restart health regeneration
            setupHealthRegeneration.call(this);

            // Reset difficulty scaling
            gameStartTime = this.time.now;
            currentEnemyHealth = baseEnemyHealth;

            // Clear enemies and projectiles
            enemies.clear(true, true);
            projectiles.clear(true, true);

            // Hide game over elements
            gameOverText.setVisible(false);
            restartButton.setVisible(false);

            // Resume physics
            this.physics.resume();

            // Update enemy spawner creation
            enemySpawner = registerTimer(this.time.addEvent({
                delay: baseSpawnDelay,
                callback: spawnEnemy,
                callbackScope: this,
                loop: true
            }));

            // Update projectile firer creation
            projectileFirer = registerTimer(this.time.addEvent({
                delay: shootingDelay / playerFireRate,
                callback: fireProjectile,
                callbackScope: this,
                loop: true
            }));

            // Reset perks system
            resetAllPerks();
            // If using the new perks system
            if (typeof acquiredPerks !== 'undefined') {
                acquiredPerks = [];
            }

            // Update player stats text
            updatePlayerStatsText();
        }</script>
</body>

</html>