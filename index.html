<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Survivors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <!-- Assuming bestiary.js defines: HERO_CHARACTER, HERO_HIRAGANA, HERO_ROMAJI, HERO_ENGLISH, BASE_STATS, getRandomEnemyType(), getEnemyData() -->
    <script src="bestiary.js"></script>
    <!-- Assuming perks.js defines: PERKS, PerkSystem.applyPerk(), PerkSystem.getRandomPerks() -->
    <script src="perks.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }

        #game-container {
            width: 1200px;
            height: 800px;
            position: relative;
            margin: 0 auto;
        }

        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            z-index: 10;
            pointer-events: none;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="game-ui">
            <div id="level">Time Survived: 00:00:00</div>
            <div id="kills">Enemies killed: 0</div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const SCREEN_WIDTH = 1200;
        const SCREEN_HEIGHT = 800;
        const HEALTH_BAR_WIDTH = 200;
        const HEALTH_BAR_HEIGHT = 10;
        const EXP_BAR_HEIGHT = 5;
        const BASE_SHOOTING_DELAY = 2000;
        const BASE_HERO_EXP_TO_LEVEL = 5;
        const BASE_ENEMY_HEALTH = 40;
        const BASE_SPAWN_DELAY = 4000;
        const ENEMY_HEALTH_SCALE_FACTOR = 1.0;
        const ENEMY_COUNT_SCALE_FACTOR = 1.25;
        const PROJECTILE_SPEED = 400;
        const PLAYER_INVINCIBILITY_DURATION = 500;
        const DEBUG_MODE_KEY = Phaser.Input.Keyboard.KeyCodes.O;
        const PAUSE_KEY = Phaser.Input.Keyboard.KeyCodes.P;
        const LEVEL_UP_DEBUG_KEY = Phaser.Input.Keyboard.KeyCodes.R;

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: SCREEN_WIDTH,
            height: SCREEN_HEIGHT,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // --- Global Game Variables (Original Structure) ---
        let player;
        let enemies;
        let projectiles;
        let cursors;
        let wasdKeys;
        let keyboardLayout = 'qwerty';

        let pauseScreen = null;
        let resumeButton = null;
        let pauseMessage = null;
        let pauseKeyP = null;

        let statsText = null;
        let statsVisible = false;
        let debugModeEnabled = false;

        let activeEffects = {
            timers: [],
            entities: [],
            activePerks: []
        };

        let basePlayerHealth = BASE_STATS.END;
        let baseMaxHealth = BASE_STATS.END;
        let basePlayerSpeed = 8;
        let basePlayerDamage = BASE_STATS.POW;
        let basePlayerLuck = BASE_STATS.LUK;
        let basePlayerFireRate = BASE_STATS.AGI;
        let baseShootingDelay = BASE_SHOOTING_DELAY;
        let baseHeroExpToLevel = BASE_HERO_EXP_TO_LEVEL;
        let acquiredPerks = [];

        let playerHealth = basePlayerHealth;
        let maxPlayerHealth = baseMaxHealth;
        let playerSpeed = basePlayerSpeed;
        let playerDamage = basePlayerDamage;
        let playerLuck = basePlayerLuck;
        let shootingDelay = baseShootingDelay;
        let playerFireRate = basePlayerFireRate;
        let projectileSizeFactor = 4;

        let healthBar;
        let healthBarBg;
        let healthText;
        let expBar;
        let expBarBg;
        let expText;
        let playerStatsText;
        let killCountText;
        let heroLevelText;
        let learningFeedback;

        let score = 0;
        let touchInput = { x: 0, y: 0, isActive: false };
        let gameOver = false;
        let gameOverText;
        let restartButton;
        let playerInvincible = false;
        let elapsedTime = 0;
        let gamePaused = false;

        let enemySpawner = null;
        let projectileFirer = null;
        let healthRegenTimer = null;
        let shieldCooldownTimer = null;
        let orbitingProjectileTimer = null;
        let landmineTimer = null;
        let afterImageTimer = null;

        let enemyHealthScaleFactor = ENEMY_HEALTH_SCALE_FACTOR;
        let enemyCountScaleFactor = ENEMY_COUNT_SCALE_FACTOR;
        let gameStartTime = 0;
        let lastDifficultyUpdateTime = 0;
        let baseEnemyHealth = BASE_ENEMY_HEALTH;
        let currentEnemyHealth = baseEnemyHealth;
        let baseSpawnDelay = BASE_SPAWN_DELAY;

        let playerLevel = 1;
        let heroExp = 0;
        let heroExpToLevel = baseHeroExpToLevel;
        let levelUpCards = [];

        let shieldVisual = null;
        let shieldActive = false;
        let orbitingProjectiles = [];
        let landmines = [];
        let afterImages = [];
        let afterImageEnabled = false;
        let playerPositionHistory = [];

        // --- Helper Functions ---
        function xpForNextLevel(heroLevel) { return Math.ceil(baseHeroExpToLevel * Math.pow(1.2, heroLevel - 1)); }
        function formatTime(seconds) { const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = Math.floor(seconds % 60); return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }

        // --- Timer Management (Refactored) ---
        function pauseGame(isLevelUpPause = false) { const scene = this; if (gamePaused) return; console.log(`Pausing game... (Level Up Pause: ${isLevelUpPause})`); gamePaused = true; if (scene.physics) scene.physics.pause(); if (enemySpawner) enemySpawner.paused = true; if (projectileFirer) projectileFirer.paused = true; if (healthRegenTimer) healthRegenTimer.paused = true; if (shieldCooldownTimer) shieldCooldownTimer.paused = true; if (orbitingProjectileTimer) orbitingProjectileTimer.paused = true; if (landmineTimer) landmineTimer.paused = true; if (afterImageTimer) afterImageTimer.paused = true; activeEffects.timers.forEach(timer => { if (timer) timer.paused = true; }); console.log("Game timers paused."); }
        function resumeGame() { const scene = this; if (!gamePaused || gameOver) return; if (levelUpCards && levelUpCards.length > 0) { console.log("Cannot resume, level up screen is active."); return; } console.log("Resuming game..."); gamePaused = false; if (pauseScreen) pauseScreen.setVisible(false); if (pauseMessage) pauseMessage.setVisible(false); if (resumeButton) resumeButton.setVisible(false); if (scene.pausePerksContainer) scene.pausePerksContainer.setVisible(false); hidePerkCard.call(scene); if (scene.physics) scene.physics.resume(); if (enemySpawner) enemySpawner.paused = false; if (projectileFirer) projectileFirer.paused = false; if (healthRegenTimer) healthRegenTimer.paused = false; if (shieldCooldownTimer) shieldCooldownTimer.paused = false; if (orbitingProjectileTimer) orbitingProjectileTimer.paused = false; if (landmineTimer) landmineTimer.paused = false; if (afterImageTimer) afterImageTimer.paused = false; activeEffects.timers.forEach(timer => { if (timer) timer.paused = false; }); console.log("Game timers resumed."); }

        // --- Pause System Functions ---
        function setupPauseSystem() { const scene = this; pauseKeyP = scene.input.keyboard.addKey(PAUSE_KEY); pauseKeyP.on('down', function () { if (!gameOver) { const isLevelUpActive = levelUpCards && levelUpCards.length > 0; if (gamePaused && !isLevelUpActive) { resumeGame.call(scene); } else if (!gamePaused) { pauseGameWithOverlay.call(scene); } } }); document.addEventListener('visibilitychange', function () { if (document.hidden && !gameOver && !gamePaused) { pauseGameWithOverlay.call(scene); } }); createPauseScreen.call(scene); console.log("Pause system initialized"); }
        function createPauseScreen() { const scene = this; pauseScreen = scene.add.rectangle(600, 400, SCREEN_WIDTH, SCREEN_HEIGHT, 0x000000, 0.7).setVisible(false).setDepth(1000).setInteractive(); pauseMessage = scene.add.text(600, 100, 'GAME PAUSED', { fontFamily: 'Arial', fontSize: '40px', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5).setVisible(false).setDepth(1001); resumeButton = scene.add.text(600, 700, 'RESUME GAME', { fontFamily: 'Arial', fontSize: '36px', color: '#ffffff', backgroundColor: '#008800', padding: { left: 15, right: 15, top: 10, bottom: 10 } }).setOrigin(0.5).setVisible(false).setDepth(1001).setInteractive({ useHandCursor: true }); resumeButton.on('pointerdown', () => resumeGame.call(scene)); resumeButton.on('pointerover', function () { this.setStyle({ backgroundColor: '#00aa00' }); }); resumeButton.on('pointerout', function () { this.setStyle({ backgroundColor: '#008800' }); }); scene.pausePerksContainer = scene.add.container(0, 0).setDepth(1001).setVisible(false); const perksTitle = scene.add.text(600, 200, 'MY PERKS', { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5); scene.pausePerksContainer.add(perksTitle); scene.perkIcons = []; scene.paginationControls = []; scene.activePerkCard = null; scene.currentPerkPage = 0; }
        function pauseGameWithOverlay() { const scene = this; if (gameOver) return; pauseGame.call(scene); if (pauseScreen) pauseScreen.setVisible(true); if (pauseMessage) pauseMessage.setVisible(true); if (resumeButton) resumeButton.setVisible(true); updatePauseScreenPerks.call(scene); console.log("Game paused with overlay."); }
        function updatePauseScreenPerks() { const scene = this; if (scene.perkIcons) scene.perkIcons.forEach(icon => icon.destroy()); scene.perkIcons = []; if (scene.paginationControls) scene.paginationControls.forEach(ctrl => ctrl.destroy()); scene.paginationControls = []; hidePerkCard.call(scene); if (!scene.pausePerksContainer) return; scene.pausePerksContainer.setVisible(true); if (acquiredPerks.length === 0) { const noPerkText = scene.add.text(600, 350, 'No perks acquired yet', { fontFamily: 'Arial', fontSize: '20px', color: '#aaaaaa' }).setOrigin(0.5); scene.perkIcons.push(noPerkText); scene.pausePerksContainer.add(noPerkText); return; } const measurements = []; acquiredPerks.forEach(perkId => { const perk = PERKS[perkId]; if (!perk) return; const tempText = scene.add.text(0, 0, perk.kanji, { fontFamily: 'Arial', fontSize: '32px', fontStyle: 'bold' }); measurements.push({ perkId: perkId, width: tempText.width }); tempText.destroy(); }); const perksPerPage = 32; const totalPages = Math.ceil(measurements.length / perksPerPage); scene.currentPerkPage = Math.max(0, Math.min(scene.currentPerkPage, totalPages - 1)); const startIndex = scene.currentPerkPage * perksPerPage; const endIndex = startIndex + perksPerPage; const perksToShow = measurements.slice(startIndex, endIndex); const perksPerRow = 8; const rowHeight = 70; const spacing = 20; const startY = 280; const rows = []; for (let i = 0; i < perksToShow.length; i += perksPerRow) { rows.push(perksToShow.slice(i, i + perksPerRow)); } rows.forEach((row, rowIndex) => { const rowWidth = row.reduce((sum, item) => sum + item.width, 0) + (spacing * (row.length - 1)); let currentX = 600 - (rowWidth / 2); const y = startY + (rowIndex * rowHeight); row.forEach(item => { const perkId = item.perkId; const perk = PERKS[perkId]; const centerX = currentX + (item.width / 2); const perkIcon = scene.add.text(centerX, y, perk.kanji, { fontFamily: 'Arial', fontSize: '32px', color: perk.color, fontStyle: 'bold', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5).setInteractive({ useHandCursor: true }); perkIcon.on('pointerover', function () { this.setScale(1.2); const cardY = y + 150; showPerkCard.call(scene, perkId, centerX, cardY); }); perkIcon.on('pointerout', function () { this.setScale(1.0); hidePerkCard.call(scene); }); scene.perkIcons.push(perkIcon); scene.pausePerksContainer.add(perkIcon); currentX += item.width + spacing; }); }); if (totalPages > 1) { const paginationY = 580; const pageText = scene.add.text(600, paginationY, `${scene.currentPerkPage + 1}/${totalPages}`, { fontFamily: 'Arial', fontSize: '40px', color: '#ffffff' }).setOrigin(0.5); scene.paginationControls.push(pageText); scene.pausePerksContainer.add(pageText); if (scene.currentPerkPage > 0) { const leftArrow = scene.add.text(520, paginationY, '◀', { fontFamily: 'Arial', fontSize: '48px', color: '#ffffff' }).setOrigin(0.5).setInteractive({ useHandCursor: true }); leftArrow.on('pointerdown', () => { scene.currentPerkPage--; updatePauseScreenPerks.call(scene); }); leftArrow.on('pointerover', function () { this.setColor('#aaffaa'); }); leftArrow.on('pointerout', function () { this.setColor('#ffffff'); }); scene.paginationControls.push(leftArrow); scene.pausePerksContainer.add(leftArrow); } if (scene.currentPerkPage < totalPages - 1) { const rightArrow = scene.add.text(680, paginationY, '▶', { fontFamily: 'Arial', fontSize: '48px', color: '#ffffff' }).setOrigin(0.5).setInteractive({ useHandCursor: true }); rightArrow.on('pointerdown', () => { scene.currentPerkPage++; updatePauseScreenPerks.call(scene); }); rightArrow.on('pointerover', function () { this.setColor('#aaffaa'); }); rightArrow.on('pointerout', function () { this.setColor('#ffffff'); }); scene.paginationControls.push(rightArrow); scene.pausePerksContainer.add(rightArrow); } } }
        function createPerkCard(scene, perkId, x, y, options = {}) { const defaults = { container: null, createBackground: true, backgroundColor: 0x444444, width: 220, height: 320, depth: 0, strokeWidth: 2, strokeColor: 0x000000, backgroundOnly: false }; const settings = { ...defaults, ...options }; const perk = PERKS[perkId]; if (!perk) return []; const cardElements = []; const cardWidth = settings.width; const cardHeight = settings.height; if (settings.createBackground) { const cardBg = scene.add.rectangle(x, y, cardWidth, cardHeight, settings.backgroundColor, 1).setStrokeStyle(settings.strokeWidth, settings.strokeColor).setDepth(settings.depth); cardElements.push(cardBg); if (settings.backgroundOnly) { if (settings.container) settings.container.add(cardBg); return [cardBg]; } } const contentWidth = cardWidth * 0.9; const kanjiY = y - cardHeight * 0.35; const kanjiText = scene.add.text(x, kanjiY, perk.kanji, { fontFamily: 'Arial', fontSize: '48px', color: perk.color, fontStyle: 'bold', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5).setDepth(settings.depth + 1); cardElements.push(kanjiText); const hiraganaY = kanjiY + 40; const hiraganaText = scene.add.text(x, hiraganaY, perk.hiragana, { fontFamily: 'Arial', fontSize: '18px', color: '#ffffff' }).setOrigin(0.5).setDepth(settings.depth + 1); cardElements.push(hiraganaText); const romajiY = hiraganaY + 25; const romajiText = scene.add.text(x, romajiY, perk.romaji, { fontFamily: 'Arial', fontSize: '16px', color: '#dddddd', fontStyle: 'italic' }).setOrigin(0.5).setDepth(settings.depth + 1); cardElements.push(romajiText); const englishY = romajiY + 35; const englishText = scene.add.text(x, englishY, perk.english, { fontFamily: 'Arial', fontSize: '22px', color: perk.color, fontStyle: 'bold' }).setOrigin(0.5).setDepth(settings.depth + 1); cardElements.push(englishText); const descY = englishY + 55; const descText = scene.add.text(x, descY, perk.description, { fontFamily: 'Arial', fontSize: '16px', color: '#ffffff', align: 'center', wordWrap: { width: contentWidth } }).setOrigin(0.5, 0).setDepth(settings.depth + 1); cardElements.push(descText); if (settings.container) { cardElements.forEach(element => settings.container.add(element)); } return cardElements; }
        function showPerkCard(perkId, x, y) { const scene = this; hidePerkCard.call(scene); scene.activePerkCard = createPerkCard(scene, perkId, x, y, { container: scene.pausePerksContainer, depth: 1100, backgroundColor: 0x333333, strokeColor: 0xeeeeee, strokeWidth: 2 }); }
        function hidePerkCard() { const scene = this; if (scene.activePerkCard) { scene.activePerkCard.forEach(element => element.destroy()); scene.activePerkCard = null; } }

        // --- Perk System Functions ---
        function initializePerks() { /* No state needed */ }
        function acquirePerk(scene, perkId) { if (acquiredPerks.includes(perkId)) return false; acquiredPerks.push(perkId); activeEffects.activePerks.push(perkId); return PerkSystem.applyPerk(scene, perkId); }
        window.registerEffect = function (type, item) { if (!item) return; if (type === 'timer' && item instanceof Phaser.Time.TimerEvent) { activeEffects.timers.push(item); const scene = game.scene.scenes[0]; if (scene && gamePaused) item.paused = true; } else if (type === 'entity' && item instanceof Phaser.GameObjects.GameObject) { activeEffects.entities.push(item); } else { console.warn("Unknown effect type or invalid item:", type, item); } };
        function clearAllPerkEffects() { activeEffects.timers.forEach(timer => { if (timer) timer.remove(); }); activeEffects.timers = []; activeEffects.entities.forEach(entity => { if (entity && entity.active) entity.destroy(); }); activeEffects.entities = []; afterImageEnabled = false; afterImages.forEach(img => { if (img && img.active) img.destroy(); }); afterImages = []; playerPositionHistory = []; landmines.forEach(mine => { if (mine && mine.active) mine.destroy(); }); landmines = []; orbitingProjectiles.forEach(orb => { if (orb && orb.active) orb.destroy(); }); orbitingProjectiles = []; shieldActive = false; if (shieldVisual) shieldVisual.setVisible(false); if (shieldCooldownTimer) { shieldCooldownTimer.remove(); shieldCooldownTimer = null; } if (orbitingProjectileTimer) { orbitingProjectileTimer.remove(); orbitingProjectileTimer = null; } if (landmineTimer) { landmineTimer.remove(); landmineTimer = null; } if (afterImageTimer) { afterImageTimer.remove(); afterImageTimer = null; } activeEffects.activePerks = []; console.log("Cleared all perk effects and timers."); }
        function hasPerk(perkId) { return acquiredPerks.includes(perkId); }

        // Create the game instance
        const game = new Phaser.Game(config);

        // --- Phaser Scene Methods ---
        function preload() { /* No assets */ }
        function create() { const scene = this; initializePerks(); gameStartTime = scene.time.now; lastDifficultyUpdateTime = scene.time.now; detectKeyboardLayout.call(scene); setupPauseSystem.call(scene); setupPerformanceMonitor.call(scene); player = scene.add.text(600, 400, HERO_CHARACTER, { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5); player.hiragana = HERO_HIRAGANA; player.romaji = HERO_ROMAJI; player.english = HERO_ENGLISH; scene.physics.world.enable(player); player.body.setCollideWorldBounds(true); healthBarBg = scene.add.rectangle(600, 25, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT, 0x333333).setOrigin(0.5); healthBar = scene.add.rectangle(500, 25, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT, 0x00ff00).setOrigin(0, 0.5); expBarBg = scene.add.rectangle(600, 40, HEALTH_BAR_WIDTH, EXP_BAR_HEIGHT, 0x333333).setOrigin(0.5); expBar = scene.add.rectangle(500, 40, 0, EXP_BAR_HEIGHT, 0x00ffff).setOrigin(0, 0.5); healthText = scene.add.text(600, 15, '', { fontFamily: 'Arial', fontSize: '12px', color: '#ffffff' }).setOrigin(0.5); expText = scene.add.text(600, 50, '', { fontFamily: 'Arial', fontSize: '12px', color: '#00ffff' }).setOrigin(0.5); playerStatsText = scene.add.text(10, 100, '', { fontFamily: 'Arial', fontSize: '12px', color: '#ffffff' }); shieldVisual = scene.add.circle(player.x, player.y, 30, 0x3498db, 0.4).setStrokeStyle(3, 0x0088ff).setVisible(false); enemies = scene.physics.add.group(); projectiles = scene.physics.add.group(); scene.physics.add.collider(projectiles, enemies, projectileHitEnemy, null, scene); scene.physics.add.overlap(player, enemies, playerHitEnemy, null, scene); cursors = scene.input.keyboard.createCursorKeys(); updateWASDKeys.call(scene); scene.input.on('pointerdown', (pointer) => { if (!gamePaused && !gameOver) { touchInput.isActive = true; touchInput.x = pointer.x; touchInput.y = pointer.y; } }); scene.input.on('pointermove', (pointer) => { if (touchInput.isActive && !gamePaused && !gameOver) { touchInput.x = pointer.x; touchInput.y = pointer.y; } }); scene.input.on('pointerup', (pointer) => { if (pointer.primaryDown === false) touchInput.isActive = false; }); scene.input.on('pointerupoutside', (pointer) => { if (pointer.primaryDown === false) touchInput.isActive = false; }); setupDebugKeys.call(scene); killCountText = scene.add.text(600, 65, '', { fontFamily: 'Arial', fontSize: '14px', color: '#ffffff' }).setOrigin(0.5); heroLevelText = scene.add.text(600, 85, '', { fontFamily: 'Arial', fontSize: '14px', color: '#00ffff' }).setOrigin(0.5); gameOverText = scene.add.text(600, 400, 'GAME OVER', { fontFamily: 'Arial', fontSize: '40px', color: '#ff0000', fontStyle: 'bold' }).setOrigin(0.5).setVisible(false).setDepth(2000); restartButton = scene.add.text(600, 600, 'PLAY AGAIN', { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff', backgroundColor: '#880000', padding: { left: 15, right: 15, top: 10, bottom: 10 } }).setOrigin(0.5).setVisible(false).setInteractive().setDepth(2000); restartButton.on('pointerdown', () => startGame.call(scene)); learningFeedback = scene.add.text(600, SCREEN_HEIGHT - 30, '', { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff' }).setOrigin(0.5).setAlpha(0.5); startGame.call(scene); }
        function update(time, delta) { const scene = this; if (gameOver || gamePaused) return; updatePerformanceStats.call(scene, time, delta); elapsedTime += delta / 1000; document.getElementById('level').innerText = `Time Survived: ${formatTime(elapsedTime)}`; document.getElementById('kills').textContent = `Enemies killed: ${score}`; killCountText.setText(`Enemies killed: ${score}`); player.body.setVelocity(0); let targetVelocityX = 0; let targetVelocityY = 0; const moveSpeed = playerSpeed * 50; if (cursors.left.isDown || (wasdKeys && wasdKeys.left.isDown)) targetVelocityX = -moveSpeed; else if (cursors.right.isDown || (wasdKeys && wasdKeys.right.isDown)) targetVelocityX = moveSpeed; if (cursors.up.isDown || (wasdKeys && wasdKeys.up.isDown)) targetVelocityY = -moveSpeed; else if (cursors.down.isDown || (wasdKeys && wasdKeys.down.isDown)) targetVelocityY = moveSpeed; if (touchInput.isActive) { const dx = touchInput.x - player.x; const dy = touchInput.y - player.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > 5) { targetVelocityX = (dx / distance) * moveSpeed; targetVelocityY = (dy / distance) * moveSpeed; } else { targetVelocityX = 0; targetVelocityY = 0; } } player.body.setVelocity(targetVelocityX, targetVelocityY); if (targetVelocityX !== 0 && targetVelocityY !== 0) player.body.velocity.normalize().scale(moveSpeed); enemies.getChildren().forEach(enemy => { if (enemy && enemy.active) scene.physics.moveToObject(enemy, player, enemy.speed); }); projectiles.getChildren().forEach(projectile => { if (projectile && projectile.active) { if (projectile.y < -50 || projectile.y > SCREEN_HEIGHT + 50 || projectile.x < -50 || projectile.x > SCREEN_WIDTH + 50) destroyProjectile(projectile); if (projectile.hasDistanceDamage) updateProjectileDistance(projectile); } }); updateOrbitingProjectiles(); updateActiveAfterImages(); if (shieldVisual && shieldVisual.visible) shieldVisual.setPosition(player.x, player.y); updateHealthBar(); updateExpBar(); updatePlayerStatsText(); if (time > lastDifficultyUpdateTime + 1000) { updateDifficultyScaling(); lastDifficultyUpdateTime = time; } if (heroExp >= heroExpToLevel) levelUp.call(scene); }

        // --- Debugging Functions ---
        function setupPerformanceMonitor() { const scene = this; statsText = scene.add.text(SCREEN_WIDTH - 10, 10, 'FPS: 0', { fontFamily: 'Arial', fontSize: '14px', color: '#00ff00', backgroundColor: '#000000cc', padding: { x: 5, y: 3 }, align: 'right' }).setOrigin(1, 0).setDepth(3000).setVisible(false); statsVisible = false; const keyO = scene.input.keyboard.addKey(DEBUG_MODE_KEY); keyO.on('down', function () { toggleDebugMode.call(this); }, scene); console.log("Performance monitor initialized (press O to toggle)"); }
        function toggleDebugMode() { const scene = this; debugModeEnabled = !debugModeEnabled; statsVisible = debugModeEnabled; if (statsText) statsText.visible = debugModeEnabled; scene.physics.world.drawDebug = debugModeEnabled; if (debugModeEnabled && !scene.physics.world.debugGraphic) scene.physics.world.createDebugGraphic(); if (scene.physics.world.debugGraphic) { scene.physics.world.debugGraphic.visible = debugModeEnabled; scene.physics.world.debugGraphic.clear(); } console.log(`Debug mode ${debugModeEnabled ? 'enabled' : 'disabled'}`); }
        function updatePerformanceStats(time, delta) { const scene = this; if (statsText && statsVisible) { const fps = Math.round(scene.game.loop.actualFps); let bodyCount = scene.physics.world.bodies.size; let enemyCount = enemies ? enemies.countActive(true) : 0; let projectileCount = projectiles ? projectiles.countActive(true) : 0; const frameTime = delta.toFixed(2); let memoryUsage = "N/A"; if (window.performance && window.performance.memory) { memoryUsage = Math.round(window.performance.memory.usedJSHeapSize / 1048576) + " MB"; } statsText.setText([`DEBUG MODE ON`, `FPS: ${fps}`, `Frame Time: ${frameTime}ms`, `Memory: ${memoryUsage}`, `Total Objects: ${scene.children.list.length}`, `Enemies: ${enemyCount}`, `Projectiles: ${projectileCount}`, `Physics Bodies: ${bodyCount}`].join('\n')); } if (debugModeEnabled && scene.physics.world.debugGraphic) scene.physics.world.debugGraphic.clear(); }
        function setupDebugKeys() { const scene = this; const keyR = scene.input.keyboard.addKey(LEVEL_UP_DEBUG_KEY); keyR.on('down', () => { if (!gamePaused && !gameOver && debugModeEnabled) { console.log("Debug: Triggering Level Up via R key."); const xpNeeded = heroExpToLevel - heroExp; heroExp += Math.max(1, xpNeeded); updateExpBar(); } }); }

        // --- Game Logic Functions ---
        function setupHealthRegeneration() { const scene = this; if (healthRegenTimer) { healthRegenTimer.remove(); healthRegenTimer = null; } if (maxPlayerHealth <= 0) return; const regenDelay = Math.max(50, 100000 / maxPlayerHealth); healthRegenTimer = scene.time.addEvent({ delay: regenDelay, callback: regenerateHealth, callbackScope: scene, loop: true }); console.log(`Health regen set: +1 HP every ${(regenDelay / 1000).toFixed(2)}s`); }
        function regenerateHealth() { const scene = this; if (gameOver || gamePaused) return; if (playerHealth < maxPlayerHealth) { playerHealth = Math.min(maxPlayerHealth, playerHealth + 1); updateHealthBar(); showRegenEffect.call(scene); } }
        function showRegenEffect() { const scene = this; if (!player || !player.active) return; const healEffect = scene.add.text(player.x, player.y - 20, '+1', { fontFamily: 'Arial', fontSize: '16px', color: '#00ff00', stroke: '#000000', strokeThickness: 2 }).setOrigin(0.5); scene.tweens.add({ targets: healEffect, y: healEffect.y - 25, alpha: 0, duration: 1000, ease: 'Cubic.easeOut', onComplete: () => healEffect.destroy() }); }
        function updateHealthBar() { const healthPercentage = Math.max(0, playerHealth) / maxPlayerHealth; healthBar.width = healthPercentage * HEALTH_BAR_WIDTH; healthBar.x = 500; healthText.setText(`Health: ${Math.ceil(playerHealth)} / ${maxPlayerHealth}`); }
        function updateExpBar() { const expPercentage = (heroExpToLevel > 0) ? (heroExp / heroExpToLevel) : 0; expBar.width = expPercentage * HEALTH_BAR_WIDTH; expBar.x = 500; expText.setText(`XP: ${heroExp} / ${heroExpToLevel}`); }
        function levelUp() { const scene = this; if (gamePaused) return; console.log(`Level Up! Reached Level ${playerLevel + 1}`); playerLevel++; heroExp -= heroExpToLevel; if (heroExp < 0) heroExp = 0; heroExpToLevel = xpForNextLevel(playerLevel); heroLevelText.setText(`Hero Level: ${playerLevel}`); updateExpBar(); showLevelUpCards.call(scene); const lvlUpEffect = scene.add.text(player.x, player.y - 40, 'LEVEL UP!', { fontFamily: 'Arial', fontSize: '24px', color: '#ffff00', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5); scene.tweens.add({ targets: lvlUpEffect, y: lvlUpEffect.y - 50, alpha: 0, duration: 1500, ease: 'Cubic.easeOut', onComplete: () => lvlUpEffect.destroy() }); }
        function updatePlayerStatsText() { let stats = [`POW: ${playerDamage}`, `AGI: ${playerFireRate}`, `END: ${maxPlayerHealth}`, `LUK: ${playerLuck}`]; if (playerStatsText) playerStatsText.setText(stats.join('\n')); }
        function spawnEnemy() { const scene = this; if (gameOver || gamePaused) return; const enemyType = getRandomEnemyType(); const enemyData = getEnemyData(enemyType); if (!enemyData) { console.warn("Could not get data for enemy type:", enemyType); return; } let x, y; if (Math.random() < 0.5) { x = Math.random() < 0.5 ? -50 : SCREEN_WIDTH + 50; y = Phaser.Math.Between(50, SCREEN_HEIGHT - 50); } else { x = Phaser.Math.Between(50, SCREEN_WIDTH - 50); y = Math.random() < 0.5 ? -50 : SCREEN_HEIGHT + 50; } const enemy = scene.add.text(x, y, enemyType, { fontFamily: 'Arial', fontSize: `${enemyData.size}px`, color: enemyData.color, fontStyle: 'bold' }).setOrigin(0.5); enemies.add(enemy); enemy.body.setSize(enemy.width, enemy.height); enemy.body.setCollideWorldBounds(false); enemy.body.immovable = false; enemy.health = Math.ceil(currentEnemyHealth * enemyData.healthMultiplier); enemy.speed = Phaser.Math.Between(enemyData.speedMin, enemyData.speedMax); enemy.damage = enemyData.damage; enemy.rank = enemyData.rank; enemy.expValue = enemyData.expValue || 1; enemy.hiragana = enemyData.hiragana; enemy.romaji = enemyData.romaji; enemy.english = enemyData.english; }
        function fireProjectile() { const scene = this; if (gameOver || gamePaused || !player || !player.active) return; let closestEnemy = null; let closestDistanceSq = 400 * 400; enemies.getChildren().forEach(enemy => { if (!enemy || !enemy.active) return; const distanceSq = Phaser.Math.Distance.Squared(player.x, player.y, enemy.x, enemy.y); if (distanceSq < closestDistanceSq) { closestDistanceSq = distanceSq; closestEnemy = enemy; } }); if (closestEnemy) { const angle = Phaser.Math.Angle.Between(player.x, player.y, closestEnemy.x, closestEnemy.y); createSingleProjectile.call(scene, angle); if (hasPerk('PURPLE_OWL')) { const doubleChance = (playerLuck / BASE_STATS.LUK) * 0.08; if (Math.random() < doubleChance) { console.log("Double Shot Triggered!"); const angleVariation = (Math.random() - 0.5) * 0.2; createSingleProjectile.call(scene, angle + angleVariation); } } } }

        // CORRECTED createProjectileBase hitbox
        function createProjectileBase(scene, x, y, color = '#ffff00', symbol = '★') {
            const size = Math.max(8, projectileSizeFactor * playerDamage);
            const projectile = scene.add.text(x, y, symbol, { fontFamily: 'Arial', fontSize: `${size}px`, color: color, fontStyle: 'bold' }).setOrigin(0.5);
            projectiles.add(projectile);
            // Use setSize centered based on original logic (half visual size)
            projectile.body.setSize(projectile.width / 2, projectile.height / 2);
            // Centering is handled by text origin 0.5
            projectile.damage = playerDamage;
            projectile.isOrbiting = false; projectile.isLandmine = false; projectile.isSlowShot = false; projectile.hasDistanceDamage = false; projectile.isDefensiveBurst = false;
            return projectile;
        }

        function createSingleProjectile(angle) { const scene = this; const projectile = createProjectileBase(scene, player.x, player.y); projectile.body.setVelocity(Math.cos(angle) * PROJECTILE_SPEED, Math.sin(angle) * PROJECTILE_SPEED); if (hasPerk('CRIMSON_SCATTER')) { projectile.startX = player.x; projectile.startY = player.y; projectile.hasDistanceDamage = true; projectile.baseDamage = playerDamage; projectile.damage = projectile.baseDamage * 2.0; projectile.setScale(2.0); } if (hasPerk('CYAN_SLOW')) { const slowChance = (playerLuck / BASE_STATS.LUK) * 0.05; projectile.isSlowShot = (Math.random() < slowChance); if (projectile.isSlowShot) projectile.setColor('#00ffff'); } return projectile; }
        function updateProjectileDistance(projectile) { if (!projectile || !projectile.active || !projectile.hasDistanceDamage) return; const dx = projectile.x - projectile.startX; const dy = projectile.y - projectile.startY; const distance = Math.sqrt(dx * dx + dy * dy); const maxDistance = 400; const scaleMultiplier = Math.max(0.4, 2.0 - (1.6 * Math.min(distance, maxDistance) / maxDistance)); projectile.damage = projectile.baseDamage * scaleMultiplier; projectile.setScale(scaleMultiplier); }
        function projectileHitEnemy(projectile, enemy) { const scene = this; if (!projectile.active || !enemy.active) return; const damageDealt = projectile.damage; enemy.health -= damageDealt; if (projectile.isSlowShot && !enemy.isSlowed) { enemy.isSlowed = true; const originalSpeed = enemy.speed; enemy.speed = Math.max(10, enemy.speed * 0.5); enemy.setColor('#00ffff'); scene.time.delayedCall(2000, () => { if (enemy && enemy.active) { const enemyData = getEnemyData(enemy.text); enemy.speed = originalSpeed; enemy.setColor(enemyData?.color || '#ff5555'); enemy.isSlowed = false; } }, [], scene); } if (enemy.health <= 0) { handleEnemyDefeat.call(scene, enemy); } else { scene.tweens.add({ targets: enemy, alpha: 0.3, duration: 50, yoyo: true, repeat: 1 }); } if (!projectile.isLandmine) { destroyProjectile(projectile); } else { destroyProjectile(projectile); } }
        function destroyProjectile(projectile) { if (!projectile || !projectile.active) return; if (projectile.isOrbiting) { const index = orbitingProjectiles.indexOf(projectile); if (index > -1) orbitingProjectiles.splice(index, 1); } if (projectile.isLandmine) { const index = landmines.indexOf(projectile); if (index > -1) landmines.splice(index, 1); } projectile.destroy(); }
        function handleEnemyDefeat(enemy) { const scene = this; if (!enemy || !enemy.active) return; if (learningFeedback) { const enemyData = getEnemyData(enemy.text); learningFeedback.setText(`Defeated ${enemy.text} (${enemyData?.hiragana || '?'}) [${enemyData?.romaji || '?'}] - ${enemyData?.english || '?'}`); learningFeedback.setAlpha(1); scene.time.delayedCall(3000, () => { if (learningFeedback) learningFeedback.setAlpha(0.5); }, [], scene); } score++; heroExp += enemy.expValue || 1; updateExpBar(); enemy.destroy(); }
        function playerHitEnemy(player, enemy) { const scene = this; if (playerInvincible || !player.active || !enemy.active) return; if (hasPerk('PURPLE_HEDGEHOG')) triggerDefensiveBurst.call(scene); if (shieldActive && hasPerk('BLUE_WHALE')) { shieldActive = false; if (shieldVisual) shieldVisual.setVisible(false); const baseCooldown = 16000; window.startShieldCooldown(baseCooldown); makePlayerInvincible.call(scene, 200); return; } const damageTaken = enemy.damage || 1; playerHealth -= damageTaken; updateHealthBar(); if (playerHealth <= 0) { playerHealth = 0; updateHealthBar(); playerDeath.call(scene); } else { makePlayerInvincible.call(scene, PLAYER_INVINCIBILITY_DURATION); } }
        function makePlayerInvincible(duration) { const scene = this; if (playerInvincible) return; playerInvincible = true; if (!player || !player.active) { playerInvincible = false; return; } scene.tweens.add({ targets: player, alpha: 0.3, duration: duration / 4, yoyo: true, repeat: 1, onComplete: () => { if (player && player.active) player.setAlpha(1); } }); scene.time.delayedCall(duration, () => { playerInvincible = false; if (player && player.active) player.setAlpha(1); }, [], scene); }
        function triggerDefensiveBurst() { const scene = this; const projectileCount = playerLuck * 2; const burstColor = '#9370db'; const burstEffect = scene.add.circle(player.x, player.y, 10, burstColor, 0.8); scene.tweens.add({ targets: burstEffect, radius: 60, alpha: 0, duration: 300, ease: 'Expo.easeOut', onComplete: () => burstEffect.destroy() }); for (let i = 0; i < projectileCount; i++) { const angle = (i / projectileCount) * Math.PI * 2; const projectile = createProjectileBase(scene, player.x, player.y, burstColor); projectile.isDefensiveBurst = true; const burstSpeed = PROJECTILE_SPEED * 0.8; projectile.body.setVelocity(Math.cos(angle) * burstSpeed, Math.sin(angle) * burstSpeed); } }
        function playerDeath() { const scene = this; if (gameOver) return; console.log("Player Died!"); gameOver = true; if (player && player.body) player.body.stop(); pauseGame.call(scene, true); scene.tweens.add({ targets: player, alpha: 0, scale: 0.5, angle: 180, duration: 500, ease: 'Linear', onComplete: () => { if (player) player.setVisible(false); } }); gameOverText.setText(`GAME OVER\nTime Survived: ${formatTime(elapsedTime)}\nEnemies killed: ${score}`); gameOverText.setVisible(true).setAlpha(0).setScale(0.5); restartButton.setVisible(true).setAlpha(0).setScale(0.5); scene.tweens.add({ targets: [gameOverText, restartButton], alpha: 1, scale: 1, duration: 500, delay: 300, ease: 'Cubic.easeOut' }); }
        function showLevelUpCards() { const scene = this; pauseGame.call(scene, true); const levelUpBackground = scene.add.rectangle(600, 400, SCREEN_WIDTH, SCREEN_HEIGHT, 0x000000, 0.85).setInteractive().setDepth(1500); const levelUpTitle = scene.add.text(600, 150, 'LEVEL UP!', { fontFamily: 'Arial', fontSize: '48px', color: '#ffff00', fontStyle: 'bold', stroke: '#000000', strokeThickness: 6 }).setOrigin(0.5).setDepth(1501); const subTitle = scene.add.text(600, 220, 'Choose a Kanji Power:', { fontFamily: 'Arial', fontSize: '28px', color: '#ffffff' }).setOrigin(0.5).setDepth(1501); const availablePerks = PerkSystem.getRandomPerks(3, acquiredPerks); const cardWidth = 220; const cardHeight = 320; const cardY = 400 + 50; const spacing = 50; const startX = 600 - (cardWidth + spacing); levelUpCards = [levelUpBackground, levelUpTitle, subTitle]; for (let i = 0; i < 3; i++) { const cardX = startX + i * (cardWidth + spacing); const cardBg = scene.add.rectangle(cardX, cardY, cardWidth, cardHeight, 0x2a2a2a).setStrokeStyle(3, 0xcccccc).setDepth(1501); levelUpCards.push(cardBg); if (i < availablePerks.length) { const perk = availablePerks[i]; if (!perk) continue; const perkElements = createPerkCard(scene, perk.id, cardX, cardY, { createBackground: false, width: cardWidth, height: cardHeight }); perkElements.forEach(el => { el.setDepth(1502); levelUpCards.push(el); }); cardBg.setData('perkId', perk.id); cardBg.setInteractive({ useHandCursor: true }); cardBg.on('pointerover', function () { this.setFillStyle(0x4a4a4a); this.setStrokeStyle(4, 0xffffff); scene.tweens.add({ targets: this, scale: 1.05, duration: 150, ease: 'Cubic.easeOut' }); }); cardBg.on('pointerout', function () { this.setFillStyle(0x2a2a2a); this.setStrokeStyle(3, 0xcccccc); scene.tweens.add({ targets: this, scale: 1.0, duration: 100, ease: 'Cubic.easeOut' }); }); cardBg.on('pointerdown', () => { if (!gamePaused) return; selectCard.call(scene, cardBg.getData('perkId')); }); } else { const noPerkText = scene.add.text(cardX, cardY, 'N/A', { fontFamily: 'Arial', fontSize: '24px', color: '#777777' }).setOrigin(0.5).setDepth(1502); levelUpCards.push(noPerkText); } } }
        function selectCard(perkType) { const scene = this; const acquiredSuccess = acquirePerk(scene, perkType); if (acquiredSuccess) { const perk = PERKS[perkType]; const feedbackText = scene.add.text(600, SCREEN_HEIGHT - 50, `Acquired: ${perk.kanji}!`, { fontFamily: 'Arial', fontSize: '28px', color: perk.color, stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5).setDepth(2000); scene.tweens.add({ targets: feedbackText, alpha: 0, y: feedbackText.y - 50, duration: 2000, onComplete: () => feedbackText.destroy() }); } updatePlayerStatsText(); updateHealthBar(); closeLevelUpCards.call(scene); }
        function closeLevelUpCards() { const scene = this; levelUpCards.forEach(element => element.destroy()); levelUpCards = []; resumeGame.call(scene); }
        function detectKeyboardLayout() { const scene = this; keyboardLayout = 'qwerty'; try { if (navigator.keyboard && navigator.keyboard.getLayoutMap) { navigator.keyboard.getLayoutMap().then(map => { if (map.get('KeyQ')?.toLowerCase() === 'a') { keyboardLayout = 'azerty'; console.log("AZERTY API"); updateWASDKeys.call(scene); } else { console.log("QWERTY API"); } }).catch(e => console.warn("Layout API failed:", e)); } else { const lang = (navigator.language || navigator.userLanguage || '').toLowerCase(); if (lang.startsWith('fr')) { keyboardLayout = 'azerty'; console.log("AZERTY lang"); updateWASDKeys.call(scene); } else { console.log("QWERTY lang"); } } } catch (e) { console.error("Layout detection error:", e); } }
        function updateWASDKeys() { const scene = this; if (keyboardLayout === 'azerty') { wasdKeys = scene.input.keyboard.addKeys({ up: Phaser.Input.Keyboard.KeyCodes.Z, down: Phaser.Input.Keyboard.KeyCodes.S, left: Phaser.Input.Keyboard.KeyCodes.Q, right: Phaser.Input.Keyboard.KeyCodes.D }); } else { wasdKeys = scene.input.keyboard.addKeys({ up: Phaser.Input.Keyboard.KeyCodes.W, down: Phaser.Input.Keyboard.KeyCodes.S, left: Phaser.Input.Keyboard.KeyCodes.A, right: Phaser.Input.Keyboard.KeyCodes.D }); } }
        function updateDifficultyScaling() { const minutesElapsed = elapsedTime / 60; if (enemySpawner) { const targetSpawnDelay = Math.max(200, baseSpawnDelay / Math.pow(enemyCountScaleFactor, minutesElapsed)); if (Math.abs(enemySpawner.delay - targetSpawnDelay) > (enemySpawner.delay * 0.05)) { enemySpawner.delay = targetSpawnDelay; } } currentEnemyHealth = baseEnemyHealth * Math.pow(enemyHealthScaleFactor, minutesElapsed); }

        // --- Perk Activation / Bridge Functions (Corrected Checks) ---
        window.activateShield = function () { console.log("Attempting to activate shield..."); const scene = game.scene.scenes[0]; if (!scene || gameOver || shieldActive) { console.log("Shield activation condition not met (scene/gameOver/active)."); return; } console.log("Activating Shield!"); shieldActive = true; if (shieldVisual) { shieldVisual.setPosition(player.x, player.y); shieldVisual.setVisible(true).setAlpha(0); scene.tweens.add({ targets: shieldVisual, alpha: { from: 0.8, to: 0.4 }, scale: { from: 0.5, to: 1 }, duration: 400, ease: 'Cubic.easeOut' }); } showTemporaryPlayerText.call(scene, 'SHIELD READY!', '#3498db'); };
        window.startShieldCooldown = function (baseDuration = 16000) { const scene = game.scene.scenes[0]; if (!scene || gameOver || !hasPerk('BLUE_WHALE')) return; if (shieldCooldownTimer) { shieldCooldownTimer.remove(); shieldCooldownTimer = null; } const luckMultiplier = Math.max(0.2, BASE_STATS.LUK / playerLuck); const duration = baseDuration * luckMultiplier; console.log(`Starting shield cooldown: ${duration.toFixed(0)}ms`); const cooldownSeconds = (duration / 1000).toFixed(1); showTemporaryPlayerText.call(scene, `SHIELD COOLDOWN: ${cooldownSeconds}s`, '#e74c3c', 1500); shieldCooldownTimer = scene.time.delayedCall(duration, window.activateShield, [], scene); };
        window.activateOrbitingProjectile = function () { console.log("Attempting to activate orbiting projectiles..."); const scene = game.scene.scenes[0]; if (!scene || gameOver) { console.log("Orbit activation condition not met (scene/gameOver)."); return; } console.log("Activating Orbit!"); if (orbitingProjectileTimer) { orbitingProjectileTimer.remove(); orbitingProjectileTimer = null; } spawnOrbitingProjectile.call(scene); const baseCooldown = 4000; const rateMultiplier = Math.max(0.2, BASE_STATS.AGI / playerFireRate); const actualCooldown = baseCooldown * rateMultiplier; console.log(`Setting orb timer: ${actualCooldown.toFixed(0)}ms`); orbitingProjectileTimer = scene.time.addEvent({ delay: actualCooldown, callback: spawnOrbitingProjectile, callbackScope: scene, loop: true }); };
        window.activateLandmines = function () { console.log("Attempting to activate landmines..."); const scene = game.scene.scenes[0]; if (!scene || gameOver) { console.log("Mine activation condition not met (scene/gameOver)."); return; } console.log("Activating Mines!"); if (landmineTimer) { landmineTimer.remove(); landmineTimer = null; } dropLandmine.call(scene); const baseCooldown = 5000; const rateMultiplier = Math.max(0.2, BASE_STATS.AGI / playerFireRate); const actualCooldown = baseCooldown * rateMultiplier; console.log(`Setting mine timer: ${actualCooldown.toFixed(0)}ms`); landmineTimer = scene.time.addEvent({ delay: actualCooldown, callback: dropLandmine, callbackScope: scene, loop: true }); };

        // CORRECTED window.activateAfterImages - Added callbackScope back
        window.activateAfterImages = function () {
            console.log("Attempting to activate after images...");
            const scene = game.scene.scenes[0];
            if (!scene || gameOver) { console.log("After image activation condition not met (scene/gameOver)."); return; }
            console.log("Activating after-images!");
            afterImageEnabled = true;
            cleanupAfterImages(false); // Use internal cleanup function
            playerPositionHistory = []; for (let i = 0; i < 80; i++) { playerPositionHistory.push({ x: player.x, y: player.y }); } // Original buffer size
            const numImages = 4; const baseAlpha = 0.4; // Original number and alpha
            for (let i = 0; i < numImages; i++) { const alpha = baseAlpha; /* Constant alpha from original? Let's use original calculation -> ((numImages - i) / numImages) * baseAlpha;*/ const afterImage = scene.add.text(player.x, player.y, HERO_CHARACTER, { fontFamily: 'Arial', fontSize: '32px', color: '#00cc66' }).setOrigin(0.5).setAlpha(alpha).setDepth(player.depth - 1); scene.physics.world.enable(afterImage); afterImage.body.setSize(afterImage.width, afterImage.height); afterImage.damage = playerDamage; window.registerEffect('entity', afterImage); afterImages.push(afterImage); }
            if (afterImageTimer) afterImageTimer.remove();
            afterImageTimer = scene.time.addEvent({
                delay: 20, // Original delay
                callback: updateActiveAfterImages,
                callbackScope: scene, // <<< ADDED BACK
                loop: true
            });
            window.registerEffect('timer', afterImageTimer); // Register for pausing
            // Ensure overlap exists (checking scene property to avoid duplicates)
            if (!scene.afterImageOverlap) { scene.afterImageOverlap = scene.physics.add.overlap(afterImages, enemies, afterImageHitEnemy, null, scene); }
            showTemporaryPlayerText.call(scene, 'AFTER-IMAGES ACTIVE!', '#00cc66');
        };

        window.fullHeal = function () { const scene = game.scene.scenes[0]; if (!scene || gameOver || gamePaused) return; const amountHealed = maxPlayerHealth - playerHealth; if (amountHealed <= 0) return; playerHealth = maxPlayerHealth; updateHealthBar(); if (!player || !player.active) return; const healEffect = scene.add.text(player.x, player.y - 40, `+${Math.round(amountHealed)} HEAL!`, { fontFamily: 'Arial', fontSize: '20px', color: '#00ff00', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5); scene.tweens.add({ targets: healEffect, y: healEffect.y - 40, alpha: 0, duration: 1500, ease: 'Cubic.easeOut', onComplete: () => healEffect.destroy() }); };

        // --- Perk Helper Functions ---

        // CORRECTED spawnOrbitingProjectile speed
        function spawnOrbitingProjectile() {
            const scene = this;
            if (gameOver || gamePaused || orbitingProjectiles.length >= 6) return;
            const projectile = createProjectileBase(scene, player.x, player.y, '#ff9900', '★');
            projectile.isOrbiting = true;
            projectile.orbitAngle = Math.random() * Math.PI * 2;
            projectile.orbitRadius = 12 * playerLuck;
            projectile.orbitSpeed = 0.01 + (playerLuck / BASE_STATS.LUK) * 0.005; // <<< CORRECTED
            projectile.damage *= 0.5;
            orbitingProjectiles.push(projectile);
            window.registerEffect('entity', projectile);
            scene.tweens.add({ targets: projectile, scale: { from: 2, to: 1 }, alpha: { from: 0.8, to: 1 }, duration: 300, ease: 'Cubic.out' });
        }
        function updateOrbitingProjectiles() { if (!player || !player.active || orbitingProjectiles.length === 0) return; orbitingProjectiles.forEach(projectile => { if (projectile && projectile.active && projectile.isOrbiting) { projectile.orbitAngle += projectile.orbitSpeed * (game.loop.delta / 16.666); const x = player.x + Math.cos(projectile.orbitAngle) * projectile.orbitRadius; const y = player.y + Math.sin(projectile.orbitAngle) * projectile.orbitRadius; projectile.setPosition(x, y); } }); }
        function dropLandmine() { const scene = this; if (gameOver || gamePaused || landmines.length >= 8) return; const landmine = createProjectileBase(scene, player.x, player.y, '#ffbf00', '★'); landmine.isLandmine = true; landmine.body.immovable = true; landmine.body.moves = false; landmine.damage *= 1.5; landmines.push(landmine); window.registerEffect('entity', landmine); scene.tweens.add({ targets: landmine, scale: { from: 0.5, to: 1 }, alpha: { from: 0.2, to: 1 }, duration: 300, ease: 'Bounce.easeOut' }); }

        // CORRECTED updateActiveAfterImages logic
        function updateActiveAfterImages() {
            if (!afterImageEnabled || !player || !player.active || gamePaused) return;
            playerPositionHistory.unshift({ x: player.x, y: player.y });
            // Use slice to limit buffer size
            if (playerPositionHistory.length > 80) {
                playerPositionHistory = playerPositionHistory.slice(0, 80);
            }
            for (let i = 0; i < afterImages.length; i++) {
                const image = afterImages[i];
                if (image && image.active) {
                    const posIndex = 16 + (i * 16); // Original index calculation
                    const safeIndex = Math.min(posIndex, playerPositionHistory.length - 1);
                    if (safeIndex >= 0) { image.setPosition(playerPositionHistory[safeIndex].x, playerPositionHistory[safeIndex].y); }
                }
            }
        }

        function cleanupAfterImages(log = true) { if (log) console.log("Cleaning up after-images..."); if (afterImageTimer) { afterImageTimer.remove(); afterImageTimer = null; } afterImages.forEach(image => { if (image && image.destroy) image.destroy(); }); afterImages = []; playerPositionHistory = []; afterImageEnabled = false; if (log) console.log("After-image cleanup complete."); }
        function afterImageHitEnemy(afterImage, enemy) { const scene = this; if (!afterImage.active || !enemy.active) return; const now = scene.time.now; const lastHitTime = enemy.getData('lastAfterImageHit') || 0; const cooldown = 1000; if (now - lastHitTime > cooldown) { const damageDealt = afterImage.damage; enemy.health -= damageDealt; enemy.setData('lastAfterImageHit', now); scene.tweens.add({ targets: enemy, alpha: 0.3, duration: 100, yoyo: true, repeat: 1 }); if (enemy.health <= 0) handleEnemyDefeat.call(scene, enemy); } }
        function showTemporaryPlayerText(text, color = '#ffffff', duration = 1500) { const scene = this; if (!player || !player.active) return; const notification = scene.add.text(player.x, player.y - 50, text, { fontFamily: 'Arial', fontSize: '16px', color: color, stroke: '#000000', strokeThickness: 3 }).setOrigin(0.5).setDepth(2000); scene.tweens.add({ targets: notification, y: notification.y - 30, alpha: 0, duration: duration, ease: 'Cubic.easeOut', onComplete: () => notification.destroy() }); }

        // --- Game Start ---
        function startGame() { const scene = this; console.log("Starting/Restarting Game..."); gameOver = false; gamePaused = false; elapsedTime = 0; score = 0; if (enemySpawner) { enemySpawner.remove(); enemySpawner = null; } if (projectileFirer) { projectileFirer.remove(); projectileFirer = null; } if (healthRegenTimer) { healthRegenTimer.remove(); healthRegenTimer = null; } clearAllPerkEffects(); if (pauseScreen) pauseScreen.setVisible(false); if (pauseMessage) pauseMessage.setVisible(false); if (resumeButton) resumeButton.setVisible(false); if (scene.pausePerksContainer) scene.pausePerksContainer.setVisible(false); playerHealth = basePlayerHealth; maxPlayerHealth = baseMaxHealth; playerSpeed = basePlayerSpeed; playerDamage = basePlayerDamage; playerLuck = basePlayerLuck; playerFireRate = basePlayerFireRate; shootingDelay = baseShootingDelay; heroExp = 0; playerLevel = 1; heroExpToLevel = xpForNextLevel(playerLevel); if (player) { player.setPosition(600, 400); player.setAlpha(1); player.setScale(1); player.setActive(true); player.setVisible(true); } else { console.error("Player not found!"); return; } acquiredPerks = []; updateHealthBar(); updateExpBar(); heroLevelText.setText(`Hero Level: ${playerLevel}`); killCountText.setText('Enemies killed: 0'); updatePlayerStatsText(); if (learningFeedback) learningFeedback.setText(''); gameStartTime = scene.time.now; currentEnemyHealth = baseEnemyHealth; lastDifficultyUpdateTime = scene.time.now; enemies.clear(true, true); projectiles.clear(true, true); orbitingProjectiles = []; landmines = []; afterImages = []; gameOverText.setVisible(false); restartButton.setVisible(false); scene.physics.resume(); enemySpawner = scene.time.addEvent({ delay: baseSpawnDelay, callback: spawnEnemy, callbackScope: scene, loop: true }); projectileFirer = scene.time.addEvent({ delay: shootingDelay / playerFireRate, callback: fireProjectile, callbackScope: scene, loop: true }); setupHealthRegeneration.call(scene); console.log("Game Started!"); }

        // --- Bridge for modifyStat ---
        function _modifyStatInternal(statName, amount) { console.log(`Modifying stat: ${statName} by ${amount}`); switch (statName) { case 'damage': playerDamage = Math.max(1, playerDamage + amount); break; case 'speed': playerSpeed = Math.max(1, playerSpeed + amount); break; case 'health': const oldMax = maxPlayerHealth; maxPlayerHealth = Math.max(10, maxPlayerHealth + amount); const diff = maxPlayerHealth - oldMax; playerHealth = Math.min(maxPlayerHealth, playerHealth + Math.max(0, diff)); setupHealthRegeneration.call(this); break; case 'luck': playerLuck = Math.max(1, playerLuck + amount); break; case 'fireRate': playerFireRate = Math.max(0.1, playerFireRate + amount); if (projectileFirer) { const newDelay = shootingDelay / playerFireRate; projectileFirer.delay = newDelay; console.log(`Projectile firer delay updated to ${newDelay.toFixed(0)}ms`); } break; default: console.warn("Attempted to modify unknown stat:", statName); return; } updatePlayerStatsText(); updateHealthBar(); }
        window.modifyStat = function (statName, amount) { const scene = game.scene.scenes[0]; if (scene) _modifyStatInternal.call(scene, statName, amount); else console.error("Bridge modifyStat: Scene not found"); };

    </script>
</body>

</html>