<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KAJISU</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="cooldown.js"></script>
    <script src="hero.js"></script>
    <script src="artillery.js"></script>
    <script src="bestiary.js"></script>
    <script src="droppers.js"></script>
    <script src="entrapments.js"></script>
    <script src="perks.js"></script>
    <script src="ballistics.js"></script>
    <script src="menu.js"></script>
    <script src="orbitals.js"></script>
    <script src="nexus.js"></script>
    <script src="onetime.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #game-container {
            width: 1200px;
            height: 800px;
            position: relative;
            margin: 0 auto;
            /* Center horizontally */
        }

        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            z-index: 10;
            pointer-events: none;
            font-size: 14px;
        }

        /* Game border decorations */
        .border-decoration {
            position: absolute;
            background-color: transparent;
            border-style: solid;
            border-color: #FFD700;
            /* Golden color */
            z-index: 5;
        }

        /* Top-left L */
        #border-top-left {
            top: -8px;
            left: -8px;
            width: 200px;
            height: 100px;
            border-width: 8px 0 0 8px;
        }

        /* Top-right L */
        #border-top-right {
            top: -8px;
            right: -8px;
            width: 100px;
            height: 200px;
            border-width: 8px 8px 0 0;
        }

        /* Bottom-left L */
        #border-bottom-left {
            bottom: -8px;
            left: -8px;
            width: 100px;
            height: 200px;
            border-width: 0 0 8px 8px;
        }

        /* Bottom-right L */
        #border-bottom-right {
            bottom: -8px;
            right: -8px;
            width: 200px;
            height: 100px;
            border-width: 0 8px 8px 0;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <!-- L-shaped border decorations -->
        <div id="border-top-left" class="border-decoration"></div>
        <div id="border-top-right" class="border-decoration"></div>
        <div id="border-bottom-left" class="border-decoration"></div>
        <div id="border-bottom-right" class="border-decoration"></div>

        <div id="game-ui">
            <div id="level">Time Survived: 00:00:00</div>
            <div id="kills">Enemies killed: 0</div>
        </div>
    </div>

    <script>
        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 800,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Game variables
        let player;
        let enemies;
        let projectiles;
        let cursors;
        let wasdKeys;
        let keyboardLayout = 'qwerty'; // Default to QWERTY

        // Global variables for pause system
        let pauseScreen = null;
        let resumeButton = null;
        let pauseMessage = null;
        let pauseKeyP = null;

        // Add these variables for stats tracking
        let statsText = null;
        let statsVisible = false;
        let debugModeEnabled = false;

        // Store all game timers in a central array
        let gameTimers = [];

        // Register a timer with the central system
        function registerTimer(timer) {
            if (timer && timer instanceof Phaser.Time.TimerEvent) {
                gameTimers.push(timer);
                // If game is currently paused, pause the new timer too
                if (gamePaused && timer.paused !== undefined) {
                    timer.paused = true;
                }
            }
            return timer; // Return the timer for convenience
        }

        // Clean up timers that are no longer active
        function cleanupTimers() {
            gameTimers = gameTimers.filter(timer =>
                timer && !timer.hasOwnProperty('removed') && !timer.removed);
        }

        let activeEffects = {
            timers: [],         // Store all active timers
            entities: [],       // Store all entities created by perks 
            activePerks: []     // Store all acquired perks
        };

        const HEALTH_SCALE_FACTOR = 100; // Multiply all health values by 100 internally
        let playerHealthDisplay = 0; // For displaying to player

        // Initial player stats
        let basePlayerHealth = BASE_STATS.END;
        let baseMaxHealth = BASE_STATS.END;
        let basePlayerSpeed = 8;
        let basePlayerDamage = BASE_STATS.POW;
        let basePlayerLuck = BASE_STATS.LUK;
        let basePlayerFireRate = BASE_STATS.AGI;
        let baseProjectileMass = 10;
        let baseProcChance = 0.2;
        let baseShootingDelay = 2000;
        let baseHeroExpToLevel = 5;
        let acquiredPerks = [];
        let playerHealth = basePlayerHealth;
        let maxPlayerHealth = baseMaxHealth;
        let playerSpeed = basePlayerSpeed;
        let playerDamage = basePlayerDamage;
        let playerLuck = basePlayerLuck;
        let shootingDelay = baseShootingDelay; // ms between shots
        let playerFireRate = basePlayerFireRate; // Multiplier for shooting rate
        let projectileSizeFactor = 4; // Multiply player damage by this to get proj size
        let berserkMultiplier = 1.0;
        let archerMultiplier = 1.0;
        let healthBar;
        let healthBarBg;
        let expBar;
        let expBarBg;
        let expText;
        let playerStatsText;
        let score = 0;
        let level = 1;
        let touchInput = { x: 0, y: 0, isActive: false };
        let gameOver = false;
        let gameOverText;
        let restartButton;
        let playerInvincible = false;

        // Track elapsed time
        let elapsedTime = 0; // in seconds
        let currentEnemyRank = 1;

        // Game timers
        let enemySpawner = null;
        let projectileFirer = null;

        // Difficulty scaling factors
        let enemyCountScaleFactor = 1.25;
        let gameStartTime = 0;
        let baseEnemyHealth = 40;
        let currentEnemyHealth = 40;
        let baseSpawnDelay = 4000; // 4 seconds between spawns initially

        // Hero experience system
        let playerLevel = 1;
        let heroExp = 0;
        let heroExpToLevel = 5;
        let levelUpCards = [];
        let gamePaused = false;

        // Quest variables
        let questMode = false;
        let questStartTime = 600 * 60; // Time in seconds before quests start
        let currentQuest = null;
        let previousQuestType = null;
        let questTransitionShown = false;
        let questCount = 0; // Counter for completed quests
        const BASE_QUEST_DIFFICULTY = 4; // Base requirement of 4 kills

        // Helper function to calculate XP needed for next level
        function xpForNextLevel(heroLevel) {
            return Math.ceil(baseHeroExpToLevel * Math.pow(1.2, heroLevel - 1));
        }

        // Format time to hh:mm:ss
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Perk system variables
        let playerPerks = {};
        let shieldVisual = null;
        let healthRegenTimer = null;

        // Enemies
        let enemySpawners = {}; // Object to store spawners for different ranks
        let rankEnemyStartTimes = {
            1: 0, // Rank 1 enemies start immediately
            2: 12 * 60, // Rank 2 enemies start after 12 minutes
            3: 24 * 60,
            4: 36 * 60,
            5: 48 * 60,
            6: 60 * 60
            // Add more ranks and their start times here
        };
        let rankSpawnDelays = {
            1: {
                base: 4000,
                min: 400
            },
            2: {
                base: 8000,
                min: 800
            },
            3: {
                base: 16000,
                min: 1600
            },
            4: {
                base: 32000,
                min: 3200
            },
            5: {
                base: 64000,
                min: 6400
            },
            6: {
                base: 128000,
                min: 12800
            }
            // Add more ranks and their spawn configurations here
        };

        function spawnEnemyOfRank(rank) {
            // Keep original game state checks
            if (gameOver || gamePaused) return;

            // Keep original enemy type selection and data retrieval
            const enemyType = getRandomEnemyTypeByRank(rank);
            const enemyData = getEnemyData(enemyType);

            // Keep original spawn position calculation
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? Phaser.Math.Between(-100, -50) : Phaser.Math.Between(1250, 1300);
                y = Phaser.Math.Between(-50, 850);
            } else {
                x = Phaser.Math.Between(-50, 1250);
                y = Math.random() < 0.5 ? Phaser.Math.Between(-100, -50) : Phaser.Math.Between(850, 900);
            }

            // *** THIS IS THE CORRECTED LINE ***
            // Apply font size and color from enemyData correctly
            const enemy = this.add.text(x, y, enemyType, {
                fontFamily: 'Arial', // Assuming Arial was your default or intended font
                fontSize: `${enemyData.size}px`, // Use size from enemyData
                color: enemyData.color,          // Use color from enemyData
                fontStyle: 'bold'                // Keep bold style if intended
            });
            // *** END OF CORRECTED LINE ***

            // Keep original origin setting and group adding
            enemy.setOrigin(0.5);
            enemies.add(enemy);

            // Keep original physics setup (if body exists)
            if (enemy.body) {
                enemy.body.setSize(enemy.width, enemy.height);
                enemy.body.setCollideWorldBounds(false);
                enemy.body.setImmovable(false); // Restore your original settings
                enemy.body.pushable = true;     // Restore your original settings
                enemy.body.setMass(10); // Or your original mass
                enemy.body.setDrag(50); // Your original value, or adjust (e.g., 50-200 is common range)
                enemy.body.setBounce(0);
            }

            // Keep original health calculation (no changes here)
            const minutesElapsed = elapsedTime / 60;
            const healthScalingFactor = Math.pow(1.1, minutesElapsed / 2);
            currentEnemyHealth = baseEnemyHealth * healthScalingFactor;
            enemy.health = Math.ceil(currentEnemyHealth * enemyData.healthMultiplier);

            // Keep original property assignments
            enemy.speed = Phaser.Math.Between(enemyData.speedMin, enemyData.speedMax);
            enemy.damage = enemyData.damage;
            enemy.rank = enemyData.rank;
            enemy.expValue = enemyData.expValue || 1;
            enemy.kana = enemyData.kana;
            enemy.romaji = enemyData.romaji;
            enemy.english = enemyData.english;

            // Add uniqueId for piercing hit tracking (Necessary Change 1/2)
            enemy.uniqueId = Phaser.Utils.String.UUID();
            // Initialize structure for contact damage cooldowns (used by applyContactDamage)
            enemy.lastContactDamage = {};
        }

        // Function to call the rank-specific spawn function
        function spawnEnemyRank1() {
            spawnEnemyOfRank.call(this, 1);
        }

        function spawnEnemyRank2() {
            spawnEnemyOfRank.call(this, 2);
        }

        // Updated function to manage enemy spawners for all ranks
        function updateEnemySpawners() {
            // Skip if game is over or paused
            if (gameOver || gamePaused) return;

            // Calculate minutes elapsed for difficulty scaling
            const minutesElapsed = elapsedTime / 60;

            // Process each rank
            Object.keys(rankEnemyStartTimes).forEach(rank => {
                const rankNum = parseInt(rank);
                const startTime = rankEnemyStartTimes[rank];
                const rankConfig = rankSpawnDelays[rank];

                // Check if this rank's enemies should start spawning yet
                if (elapsedTime >= startTime) {
                    // Create a spawner if it doesn't exist
                    if (!enemySpawners[rank]) {
                        // Create the spawner with initial delay using a single unified spawn function
                        enemySpawners[rank] = registerTimer(this.time.addEvent({
                            delay: rankConfig.base,
                            callback: function () { spawnEnemyOfRank.call(this, rankNum); },
                            callbackScope: this,
                            loop: true
                        }));

                        // If it's not rank 1, show an introduction and update current enemy rank
                        if (rankNum > 1) {
                            showRankIntroduction.call(this, rankNum);
                        }
                    } else {
                        // Update existing spawner's delay based on elapsed time
                        // Calculate time since this rank started
                        const rankMinutesActive = (elapsedTime - startTime) / 60;

                        // Only scale up to 12 minutes of active time for this rank
                        const scalingMinutes = Math.min(12, rankMinutesActive);

                        // Calculate new delay with minimum floor
                        const newSpawnDelay = Math.max(
                            rankConfig.min,
                            rankConfig.base / Math.pow(enemyCountScaleFactor, scalingMinutes)
                        );



                        // Update the timer if needed
                        if (Math.abs(enemySpawners[rank].delay - newSpawnDelay) > (enemySpawners[rank].delay * 0.1)) {
                            enemySpawners[rank].delay = newSpawnDelay;
                            enemySpawners[rank].reset({
                                delay: newSpawnDelay,
                                callback: function () { spawnEnemyOfRank.call(this, rankNum); },
                                callbackScope: this,
                                loop: true
                            });
                        }
                    }
                }
            });
        }
        // Function to show a dramatic kanji-based introduction when a new rank appears
        function showRankIntroduction(rank) {
            // Update the current enemy rank when a new rank is introduced
            currentEnemyRank = rank;

            // Threat kanji: 危 (ki) - meaning danger/threat/peril
            const threatKanji = '危';

            // Create a more atmospheric introduction with multiple kanji
            const kanjiCount = 8; // Number of kanji to show
            const duration = 4000; // Total duration: 4 seconds

            // Scale kanji size based on rank
            const baseSize = 128; // Base font size for kanji
            const sizeFactor = Math.min(1.5, 1 + (rank - 1) * 0.25); // Increase size for higher ranks

            // Create multiple kanji at different positions
            for (let i = 0; i < kanjiCount; i++) {
                // Calculate random position weighted toward the center
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDistance = Math.random() * 300 + 100;

                const x = 600 + Math.cos(randomAngle) * randomDistance;
                const y = 400 + Math.sin(randomAngle) * randomDistance;

                // Randomize appearance time within the duration
                const delay = Math.random() * 3000; // Random delay up to 3 seconds

                // Create the kanji text with varying properties
                const kanji = this.add.text(x, y, threatKanji, {
                    fontFamily: 'Arial',
                    fontSize: `${baseSize * sizeFactor}px`,
                    color: '#ff0000',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);

                // Set initial alpha to 0
                kanji.setAlpha(0);

                // Fast fade in then fast fade out - total 1 second per kanji
                this.tweens.add({
                    targets: kanji,
                    alpha: { from: 0, to: 0.7 }, // Not fully opaque
                    scale: { from: 0.8, to: 1.2 },
                    duration: 500, // 0.5 second fade in
                    delay: delay,
                    ease: 'Sine.easeInOut',
                    onComplete: () => {
                        this.tweens.add({
                            targets: kanji,
                            alpha: { from: 0.7, to: 0 },
                            scale: { from: 1.2, to: 1.5 },
                            duration: 500, // 0.5 second fade out
                            ease: 'Sine.easeInOut',
                            onComplete: () => {
                                kanji.destroy();
                            }
                        });
                    }
                });
            }

            // After all kanji effects, show rank name briefly
            // Get the rank name from bestiary.js
            const rankName = ENEMY_RANK_NAMES[rank] || `${rank}`;

            // Wait for most of the kanji to appear, then show the rank
            this.time.delayedCall(2500, () => {
                const rankText = this.add.text(600, 400, rankName, {
                    fontFamily: 'Arial',
                    fontSize: '200px',
                    color: '#ff0000',
                    stroke: '#000000',
                    strokeThickness: 8
                }).setOrigin(0.5);
                rankText.setAlpha(0);

                // Dramatic appearance of the rank number
                this.tweens.add({
                    targets: rankText,
                    alpha: { from: 0, to: 0.9 },
                    scale: { from: 0.5, to: 1.2 },
                    duration: 800,
                    ease: 'Cubic.easeOut',
                    onComplete: () => {
                        this.tweens.add({
                            targets: rankText,
                            alpha: { from: 0.9, to: 0 },
                            scale: { from: 1.2, to: 1.5 },
                            duration: 700,
                            delay: 300,
                            ease: 'Cubic.easeIn',
                            onComplete: () => {
                                rankText.destroy();
                            }
                        });
                    }
                });
            });
        }

        // Now replace your existing enemySpawner initialization in startGame with:
        function initializeEnemySpawners() {
            // Clean up any existing spawners
            Object.values(enemySpawners).forEach(spawner => {
                if (spawner) {
                    spawner.remove();
                }
            });

            // Reset the spawners object
            enemySpawners = {};

            // Rank 1 spawner will be created in the first update
            // Other ranks will be created when their time comes
        }

        // Enhanced pauseGame function
        function pauseGame(isLevelUpPause = false) {
            // Set the flag
            gamePaused = true;

            // Pause physics
            const activeScene = game.scene.scenes[0];
            if (activeScene && activeScene.physics) {
                activeScene.physics.pause();
            }
            if (activeScene.tweens) {
                activeScene.tweens.pauseAll();
            }

            // Pause all registered timers
            gameTimers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = true;
                }
            });

            // Pause all effect timers
            activeEffects.timers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = true;
                }
            });
        }

        function getEffectiveDamage() {
            return playerDamage * berserkMultiplier;
        }

        // Function to calculate the effective fire rate
        function getEffectiveFireRate() {
            return playerFireRate * archerMultiplier;
        }

        // Resume the game and hide overlay
        function resumeGame() {
            if (gameOver) return;

            // If level up is in progress, don't resume
            if (levelUpCards && levelUpCards.length > 0) {
                console.log("Cannot resume, level up screen is active");
                return;
            }

            // Hide pause screen elements
            if (pauseScreen) pauseScreen.setVisible(false);
            if (pauseMessage) pauseMessage.setVisible(false);
            if (resumeButton) resumeButton.setVisible(false);

            // Hide perks container
            const scene = game.scene.scenes[0];
            if (scene && scene.pausePerksContainer) {
                scene.pausePerksContainer.setVisible(false);
            }

            // Set pause flag
            gamePaused = false;

            // Resume physics
            const activeScene = game.scene.scenes[0];
            if (activeScene && activeScene.physics) {
                activeScene.physics.resume();
            }
            if (activeScene.tweens) {
                activeScene.tweens.resumeAll();
            }

            // Resume all registered timers
            gameTimers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = false;
                }
            });

            // Resume all effect timers
            activeEffects.timers.forEach(timer => {
                if (timer && timer.paused !== undefined) {
                    timer.paused = false;
                }
            });

            console.log("Game resumed");
        }

        // Setup pause system
        function setupPauseSystem() {
            const scene = this;

            // Create pause key (P)
            pauseKeyP = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pauseKeyP.on('down', function () {
                if (!gameOver) {
                    if (gamePaused) {
                        resumeGame();
                    } else {
                        pauseGameWithOverlay();
                    }
                }
            });

            // Setup visibility change detection
            document.addEventListener('visibilitychange', function () {
                if (document.hidden && !gameOver && !gamePaused) {
                    // Tab/window is hidden, pause the game
                    pauseGameWithOverlay();
                }
                // We don't auto-resume when tab becomes visible again
            });

            // Create pause overlay elements (initially hidden)
            createPauseScreen.call(this);

            console.log("Pause system initialized");
        }

        function createPauseScreen() {
            // Create semi-transparent background
            pauseScreen = this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.7);
            pauseScreen.setVisible(false);
            pauseScreen.setDepth(1000); // Make sure it appears on top

            // Create pause message
            pauseMessage = this.add.text(
                600, 100,
                'GAME PAUSED',
                { fontFamily: 'Arial', fontSize: '40px', color: '#ffffff', fontStyle: 'bold' }
            ).setOrigin(0.5);
            pauseMessage.setVisible(false);
            pauseMessage.setDepth(1001);

            // Create resume button
            resumeButton = this.add.text(
                600, 700,
                'RESUME GAME',
                {
                    fontFamily: 'Arial',
                    fontSize: '36px',
                    color: '#ffffff',
                    backgroundColor: '#008800',
                    padding: { left: 15, right: 15, top: 10, bottom: 10 }
                }
            ).setOrigin(0.5);
            resumeButton.setVisible(false);
            resumeButton.setDepth(1001);
            resumeButton.setInteractive();

            // Add resume button functionality
            resumeButton.on('pointerdown', resumeGame);
            resumeButton.on('pointerover', function () {
                this.setStyle({ backgroundColor: '#00aa00' });
            });
            resumeButton.on('pointerout', function () {
                this.setStyle({ backgroundColor: '#008800' });
            });

            // Create container for perks display
            this.pausePerksContainer = this.add.container(0, 0);
            this.pausePerksContainer.setDepth(1001);
            this.pausePerksContainer.setVisible(false);

            // Create perks title
            const perksTitle = this.add.text(
                600, 200,
                'MY PERKS',
                { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff', fontStyle: 'bold' }
            ).setOrigin(0.5);

            // Add to container
            this.pausePerksContainer.add(perksTitle);
        }

        function calculateProcChance(luck, baseChance) {
            return baseChance * Math.sqrt(luck / BASE_STATS.LUK);
        }

        // Pause the game and show overlay
        function pauseGameWithOverlay() {
            if (gameOver) return;

            // Pause game systems
            pauseGame();

            // Show pause screen elements
            pauseScreen.setVisible(true);
            pauseMessage.setVisible(true);
            resumeButton.setVisible(true);

            // Update and show perks
            updatePauseScreenPerks.call(this);

            console.log("Game paused with overlay");
        }

        // Generalized function to create perk card elements with consistent positioning
        function createPerkCardElements(scene, perk, x, y, options = {}) {
            const defaults = {
                container: null,
                showBackground: true,
                showKana: true,
                showRomaji: true,
                showEnglish: true,
                showDescription: true,
                backgroundColor: 0x444444,
                width: 200,
                height: 300,
                strokeWidth: 2,
                strokeColor: 0xeeeeee,
                makeInteractive: false,
                perkCallback: null
            };

            // Merge options with defaults
            const settings = { ...defaults, ...options };

            // Elements array to return
            const elements = [];

            // Create card background if requested
            if (settings.showBackground) {
                const cardBg = scene.add.rectangle(x, y, settings.width, settings.height, settings.backgroundColor, 1)
                    .setStrokeStyle(settings.strokeWidth, settings.strokeColor);

                // Add to container if provided
                if (settings.container) {
                    settings.container.add(cardBg);
                }

                // Make interactive if requested
                if (settings.makeInteractive && perk) {
                    cardBg.setInteractive({ useHandCursor: true });
                    cardBg.perkId = perk.id;

                    // Add hover effects
                    cardBg.on('pointerover', function () {
                        this.fillColor = perk.hoverColor ?? 0x666666;
                        this.setStrokeStyle(4, 0xffffff);
                    });

                    cardBg.on('pointerout', function () {
                        this.fillColor = settings.backgroundColor;
                        this.setStrokeStyle(settings.strokeWidth, settings.strokeColor);
                    });

                    // Add click handler if provided
                    if (settings.perkCallback) {
                        cardBg.on('pointerdown', function () {
                            settings.perkCallback(perk.id);
                        });
                    }
                }

                elements.push(cardBg);
            }

            // Fixed positions relative to card center
            const positions = {
                kanji: y - 60,      // Kanji position
                kana: y - 15,   // Kana position 
                romaji: y + 10,     // Romaji position
                english: y + 40,    // English position
                description: y + 85 // Description position - 145 from kanji
            };

            // Always show kanji
            if (perk) {
                const kanjiText = scene.add.text(
                    x, positions.kanji,
                    perk.kanji,
                    {
                        fontFamily: 'Arial',
                        fontSize: '36px',
                        color: perk.color,
                        fontStyle: 'bold',
                        stroke: '#000000',
                        strokeThickness: 4
                    }
                ).setOrigin(0.5);

                if (settings.container) {
                    settings.container.add(kanjiText);
                }

                elements.push(kanjiText);

                // Show kana if requested
                if (settings.showKana) {
                    const kanaText = scene.add.text(
                        x, positions.kana,
                        perk.kana,
                        { fontFamily: 'Arial', fontSize: '18px', color: '#ffffff' }
                    ).setOrigin(0.5);

                    if (settings.container) {
                        settings.container.add(kanaText);
                    }

                    elements.push(kanaText);
                }

                // Show romaji if requested
                if (settings.showRomaji) {
                    const romajiText = scene.add.text(
                        x, positions.romaji,
                        perk.romaji,
                        { fontFamily: 'Arial', fontSize: '16px', color: '#dddddd', fontStyle: 'italic' }
                    ).setOrigin(0.5);

                    if (settings.container) {
                        settings.container.add(romajiText);
                    }

                    elements.push(romajiText);
                }

                // Show english if requested
                if (settings.showEnglish) {
                    const englishText = scene.add.text(
                        x, positions.english,
                        perk.english,
                        {
                            fontFamily: 'Arial',
                            fontSize: '20px',
                            color: perk.color,
                            fontStyle: 'bold'
                        }
                    ).setOrigin(0.5);

                    if (settings.container) {
                        settings.container.add(englishText);
                    }

                    elements.push(englishText);
                }

                // Show description if requested - always in the same position
                if (settings.showDescription) {
                    const descText = scene.add.text(
                        x, positions.description,
                        perk.description,
                        {
                            fontFamily: 'Arial',
                            fontSize: '16px',
                            color: '#ffffff',
                            align: 'center',
                            wordWrap: { width: settings.width - 20 }
                        }
                    ).setOrigin(0.5);

                    if (settings.container) {
                        settings.container.add(descText);
                    }

                    elements.push(descText);
                }
            }

            return elements;
        }

        // Update the createPerkCard function to use our generalized function
        function createPerkCard(scene, perkId, x, y, options = {}) {
            const perk = PERKS[perkId];
            if (!perk) return [];

            return createPerkCardElements(scene, perk, x, y, {
                ...options,
                showKana: true,
                showRomaji: true,
                showEnglish: true,
                showDescription: true
            });
        }

        // Update the updatePerkCardDisplay function to use our generalized function
        function updatePerkCardDisplay() {
            console.log("Updating perk card display, cards: " + this.perkChallenge.currentCards);

            // First, completely clear the container and element tracking
            this.perkCardContainer.removeAll(true); // true means destroy children
            this.perkChallenge.cardElements = [];

            // Calculate positions for cards
            const cardCount = this.perkChallenge.currentCards;
            const totalWidth = cardCount * 220 + (cardCount - 1) * 20; // Card width + spacing
            const startX = 600 - (totalWidth / 2) + 110; // Center point - half of total width + half card width

            console.log("Creating " + cardCount + " cards");

            // Create each card
            for (let i = 0; i < cardCount; i++) {
                const cardX = startX + i * 240; // 220 + 20 spacing
                const perk = this.perkChallenge.selectedPerks[i];

                if (!perk) {
                    console.log("Warning: No perk found for index " + i);
                    continue;
                }

                console.log("Creating card for perk: " + perk.id + " at position " + i);

                // Determine what to show based on state
                const isCurrentChallenge = (i === this.perkChallenge.currentCards - 1 &&
                    this.perkChallenge.inputActive &&
                    i === this.perkChallenge.currentIndex);

                // Show partial or full details based on attempts
                const showKana = !isCurrentChallenge || this.perkChallenge.attempts >= 1;
                const showRomaji = !isCurrentChallenge || this.perkChallenge.attempts >= 2;
                const showEnglish = !isCurrentChallenge || this.perkChallenge.attempts >= 2;
                const showDescription = !isCurrentChallenge || this.perkChallenge.attempts >= 2;

                // Create card elements with appropriate options
                const cardElements = createPerkCardElements(this, perk, cardX, 330, {
                    container: this.perkCardContainer,
                    showKana: showKana,
                    showRomaji: showRomaji,
                    showEnglish: showEnglish,
                    showDescription: showDescription,
                    makeInteractive: true,
                    perkCallback: function (perkId) {
                        selectCard.call(this, perkId);
                    }.bind(this)
                });

                // Store card elements including background
                this.perkChallenge.cardElements.push({
                    background: cardElements[0], // First element is the background
                    elements: cardElements.slice(1) // Rest are text elements
                });
            }

            // Update input visibility based on challenge state
            updateInputVisibility.call(this);

            console.log("Card display updated, now showing " + this.perkChallenge.cardElements.length + " cards");
        }// Improved pause screen perks display with better visuals
        function updatePauseScreenPerks() {
            const scene = game.scene.scenes[0];

            // Clear existing perk icons first
            if (scene.perkIcons) {
                scene.perkIcons.forEach(icon => {
                    icon.destroy();
                });
            }

            // Clear existing perk card if any
            if (scene.activePerkCard) {
                scene.activePerkCard.forEach(element => {
                    element.destroy();
                });
                scene.activePerkCard = null;
            }

            // Clear pagination controls if they exist
            if (scene.paginationControls) {
                scene.paginationControls.forEach(control => {
                    control.destroy();
                });
            }

            // Initialize arrays
            scene.perkIcons = [];
            scene.paginationControls = [];

            // Set or initialize current page
            if (scene.currentPerkPage === undefined) {
                scene.currentPerkPage = 0;
            }

            // Set container visible
            scene.pausePerksContainer.setVisible(true);

            // If no perks, show a message
            if (acquiredPerks.length === 0) {
                const noPerkText = scene.add.text(
                    600, 350,
                    'No perks acquired yet',
                    { fontFamily: 'Arial', fontSize: '20px', color: '#aaaaaa' }
                ).setOrigin(0.5);
                scene.perkIcons.push(noPerkText);
                scene.pausePerksContainer.add(noPerkText);
                return;
            }

            // Create temporary text objects to measure each kanji's width
            const measurements = [];
            acquiredPerks.forEach(perkId => {
                const perk = PERKS[perkId];
                if (!perk) return;

                // Create temp text for measurement
                const tempText = scene.add.text(0, 0, perk.kanji, {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    fontStyle: 'bold'
                });

                // Store the width and perk info
                measurements.push({
                    perkId: perkId,
                    width: tempText.width
                });

                // Remove the temp text
                tempText.destroy();
            });

            // Configuration for paginated layout
            const spacing = 20; // Pixels between kanji horizontally
            const perksPerRow = 8; // Maximum perks per row
            const rowsPerPage = 4; // Maximum rows per page
            const perksPerPage = perksPerRow * rowsPerPage; // Perks per page (32)
            const rowHeight = 70; // Vertical spacing between rows
            const startY = 280; // Starting Y position for the first row

            // Calculate total number of pages
            const totalPages = Math.ceil(measurements.length / perksPerPage);

            // Ensure current page is valid
            scene.currentPerkPage = Math.min(scene.currentPerkPage, totalPages - 1);
            scene.currentPerkPage = Math.max(0, scene.currentPerkPage);

            // Get perks for the current page
            const startIndex = scene.currentPerkPage * perksPerPage;
            const currentPagePerks = measurements.slice(startIndex, startIndex + perksPerPage);

            // Split current page perks into rows
            const rows = [];
            for (let i = 0; i < currentPagePerks.length; i += perksPerRow) {
                rows.push(currentPagePerks.slice(i, i + perksPerRow));
            }

            // Process each row
            rows.forEach((row, rowIndex) => {
                // Calculate total width of this row with spacing
                const rowWidth = row.reduce((sum, item) => sum + item.width, 0) +
                    (spacing * (row.length - 1));

                // Calculate starting X position to center this row
                let currentX = 600 - (rowWidth / 2);
                const y = startY + (rowIndex * rowHeight);

                // Create perk icons for this row
                row.forEach(item => {
                    const perkId = item.perkId;
                    const perk = PERKS[perkId];

                    // Position this kanji centered on its width
                    const centerX = currentX + (item.width / 2);

                    // Create the perk icon (kanji) with improved visual styling
                    const perkIcon = scene.add.text(
                        centerX, y,
                        perk.kanji,
                        {
                            fontFamily: 'Arial',
                            fontSize: '32px',
                            color: perk.color,
                            fontStyle: 'bold',
                            stroke: '#000000',
                            strokeThickness: 4
                        }
                    ).setOrigin(0.5);

                    // Make interactive
                    perkIcon.setInteractive({ useHandCursor: true });

                    // Add enhanced hover effects
                    perkIcon.on('pointerover', function () {
                        // Scale effect on hover
                        this.setScale(1.2);

                        // Always place card below, regardless of row position
                        const cardY = y + 150;

                        showPerkCard.call(scene, perkId, centerX, cardY);
                    });

                    perkIcon.on('pointerout', function () {
                        // Reset scale
                        this.setScale(1);
                        hidePerkCard.call(scene);
                    });

                    // Store reference
                    scene.perkIcons.push(perkIcon);

                    // Add to container
                    scene.pausePerksContainer.add(perkIcon);

                    // Move currentX position for the next kanji
                    currentX += item.width + spacing;
                });
            });

            // Only show pagination if we have multiple pages
            if (totalPages > 1) {
                // Create left arrow (if not on first page)
                if (scene.currentPerkPage > 0) {
                    const leftArrow = scene.add.text(
                        520, 580,
                        '◀',
                        {
                            fontFamily: 'Arial',
                            fontSize: '48px',
                            color: '#ffffff'
                        }
                    ).setOrigin(0.5);

                    leftArrow.setInteractive({ useHandCursor: true });

                    leftArrow.on('pointerdown', () => {
                        scene.currentPerkPage--;
                        updatePauseScreenPerks.call(scene);
                    });

                    // Enhanced hover effects
                    leftArrow.on('pointerover', function () {
                        this.setColor('#aaffaa');
                        // Scale effect
                        this.setScale(1.2);
                    });

                    leftArrow.on('pointerout', function () {
                        this.setColor('#ffffff');
                        // Reset scale
                        this.setScale(1);
                    });

                    scene.paginationControls.push(leftArrow);
                    scene.pausePerksContainer.add(leftArrow);
                }

                // Create page counter
                const pageCounter = scene.add.text(
                    600, 580,
                    `${scene.currentPerkPage + 1}/${totalPages}`,
                    {
                        fontFamily: 'Arial',
                        fontSize: '40px',
                        color: '#ffffff'
                    }
                ).setOrigin(0.5);

                scene.paginationControls.push(pageCounter);
                scene.pausePerksContainer.add(pageCounter);

                // Create right arrow (if not on last page)
                if (scene.currentPerkPage < totalPages - 1) {
                    const rightArrow = scene.add.text(
                        680, 580,
                        '▶',
                        {
                            fontFamily: 'Arial',
                            fontSize: '48px',
                            color: '#ffffff'
                        }
                    ).setOrigin(0.5);

                    rightArrow.setInteractive({ useHandCursor: true });

                    rightArrow.on('pointerdown', () => {
                        scene.currentPerkPage++;
                        updatePauseScreenPerks.call(scene);
                    });

                    // Enhanced hover effects
                    rightArrow.on('pointerover', function () {
                        this.setColor('#aaffaa');
                        // Scale effect
                        this.setScale(1.2);
                    });

                    rightArrow.on('pointerout', function () {
                        this.setColor('#ffffff');
                        // Reset scale
                        this.setScale(1);
                    });

                    scene.paginationControls.push(rightArrow);
                    scene.pausePerksContainer.add(rightArrow);
                }
            }
        }

        // Function to show detailed perk card with improved visuals
        function showPerkCard(perkId, x, y) {
            const scene = this;

            // Clear any existing perk card
            hidePerkCard.call(scene);

            // Create card elements using the shared function with better styling
            scene.activePerkCard = createPerkCard(scene, perkId, x, y, {
                container: scene.pausePerksContainer,
                backgroundColor: 0x333333,
                strokeWidth: 3,
                strokeColor: 0xeeeeee
            });
        }

        // Function to hide perk card
        function hidePerkCard() {
            const scene = this;

            if (scene.activePerkCard) {
                scene.activePerkCard.forEach(element => {
                    element.destroy();
                });
                scene.activePerkCard = null;
            }
        }

        // Perk system helper functions
        function initializePerks() {
            playerPerks = {};
        }

        // Update the acquirePerk function to register perks
        function acquirePerk(scene, perkId) {
            // Skip if already acquired
            if (acquiredPerks.includes(perkId)) return false;

            // Add to acquired perks list
            acquiredPerks.push(perkId);
            activeEffects.activePerks.push(perkId);

            // Apply the perk
            return PerkSystem.applyPerk(scene, perkId);
        }

        // Add this helper function to register effects
        window.registerEffect = function (type, item) {
            if (type === 'timer' && item) {
                activeEffects.timers.push(item);
                // If game is paused, also pause the new timer
                if (gamePaused && item.paused !== undefined) {
                    item.paused = true;
                }
            } else if (type === 'entity' && item) {
                activeEffects.entities.push(item);
            }
        };

        // Add this cleanup function to your startGame function
        function clearAllPerkEffects() {
            // Clear all timers
            activeEffects.timers.forEach(timer => {
                if (timer) {
                    timer.remove();
                }
            });

            // Clear all entities
            activeEffects.entities.forEach(entity => {
                if (entity && entity.active) {
                    entity.destroy();
                }
            });

            // Reset active effects
            activeEffects.timers = [];
            activeEffects.entities = [];
            activeEffects.activePerks = [];
        }

        function resetAllPerks() {
            // Call onReset for all perks that were acquired
            for (const perkId in playerPerks) {
                if (perkRegistry[perkId] && perkRegistry[perkId].onReset) {
                    perkRegistry[perkId].onReset();
                }
            }
            // Reset the perks object
            playerPerks = {};
        }

        function hasPerk(perkId) {
            return acquiredPerks.includes(perkId);
        }

        // Create the game instance
        const game = new Phaser.Game(config);

        function preload() {
            // No image assets to preload
        }

        // Function to toggle debug mode and stats
        function toggleDebugMode() {
            // Toggle debug mode
            debugModeEnabled = !debugModeEnabled;

            // Toggle stats visibility
            if (statsText) {
                statsText.visible = debugModeEnabled;
                statsVisible = debugModeEnabled;
            }

            // Toggle physics debug rendering
            this.physics.world.drawDebug = debugModeEnabled;

            // When enabling debug mode, we need to create the debug graphics if it doesn't exist
            if (debugModeEnabled && !this.physics.world.debugGraphic) {
                this.physics.world.createDebugGraphic();
            }

            // Toggle the visibility of the debug graphics
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = debugModeEnabled;
            }

            console.log(`Debug mode ${debugModeEnabled ? 'enabled' : 'disabled'}`);
        }

        // Add this to your update function
        function updatePerformanceStats(time, delta) {
            if (statsText && statsVisible) {
                const fps = Math.round(this.game.loop.actualFps);

                // Get physics bodies count
                let bodyCount = 0;
                if (this.physics && this.physics.world) {
                    bodyCount = this.physics.world.bodies.size;
                }

                // Count active game objects by type
                const totalObjects = this.children.list.length;
                let enemyCount = 0;
                let projectileCount = 0;

                if (enemies) {
                    enemyCount = enemies.getChildren().length;
                }
                if (projectiles) {
                    projectileCount = projectiles.getChildren().length;
                }

                // Calculate frame time from delta
                const frameTime = delta.toFixed(2);

                // Get memory usage if available
                let memoryUsage = "N/A";
                if (window.performance && window.performance.memory) {
                    memoryUsage = Math.round(window.performance.memory.usedJSHeapSize / 1048576) + " MB";
                }

                // Update stats text
                statsText.setText(
                    `DEBUG MODE ON\n` +
                    `FPS: ${fps}\n` +
                    `Frame Time: ${frameTime}ms\n` +
                    `Memory: ${memoryUsage}\n` +
                    `Total Objects: ${totalObjects}\n` +
                    `Enemies: ${enemyCount}\n` +
                    `Projectiles: ${projectileCount}\n` +
                    `Physics Bodies: ${bodyCount}`
                );
            }
        }

        // Generic function for handling contact-based damage with cooldown
        function applyContactDamage(source, enemy, damage, cooldownMs = 1000) {
            // Skip if either object is already destroyed
            if (!source.active || !enemy.active) return;

            // Ensure the cooldown tracking property exists on the enemy
            enemy.lastContactDamage = enemy.lastContactDamage ?? {};

            // Create a unique key for this damage source
            const sourceKey = source.damageSourceId ?? (source.damageSourceId = `damage_${Date.now()}_${Math.random()}`);

            // Check if we're still in the cooldown period for this damage source
            const currentTime = this.time.now;
            if (!enemy.lastContactDamage[sourceKey] || (currentTime - enemy.lastContactDamage[sourceKey] > cooldownMs)) {
                // Apply damage to enemy
                enemy.health -= damage;
                enemy.lastContactDamage[sourceKey] = currentTime;

                // Visual effect for damage
                this.tweens.add({
                    targets: enemy,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 1
                });

                // Check if enemy is defeated
                if (enemy.health <= 0) {
                    defeatedEnemy.call(this, enemy);
                }
            }
        }

        function create() {
            // Initialize perk system first
            initializePerks();

            // Record game start time for difficulty scaling
            gameStartTime = this.time.now;

            // Detect keyboard layout
            detectKeyboardLayout.call(this);

            setupPauseSystem.call(this);
            setupPerformanceMonitor.call(this);

            // Create player text - using kanji character
            player = this.add.text(600, 400, HERO_CHARACTER, {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(50);

            // Store all language and educational properties
            player.kana = HERO_KANA;
            player.romaji = HERO_ROMAJI;
            player.english = HERO_ENGLISH;

            // Add physics to player
            this.physics.world.enable(player);
            player.body.setCollideWorldBounds(true);

            GameUI.createUI(this);
            OrbitalSystem.init();

            // Create player stats text
            playerStatsText = this.add.text(
                10, 100,
                `Speed: ${playerSpeed}\nDamage: ${playerDamage}\nLuck: ${playerLuck}`,
                { fontFamily: 'Arial', fontSize: '12px', color: '#ffffff' }
            );

            // Create shield visual (initially invisible)
            shieldVisual = this.add.circle(player.x, player.y, 30, 0x3498db, 0.4);
            shieldVisual.setStrokeStyle(3, 0x0088ff);
            shieldVisual.setVisible(false);

            // Add health regeneration
            setupHealthRegeneration.call(this);

            // Create enemy group
            enemies = this.physics.add.group();

            // Create projectile group
            projectiles = this.physics.add.group();

            // Set up collision between projectiles and enemies
            this.physics.add.collider(
                projectiles,
                enemies,
                handleProjectileEnemyCollision, // Use the NEW collideCallback
                checkProjectilePiercing,      // Use the NEW processCallback
                this                          // Context remains 'this' (the scene)
            );

            // Set up collision between player and enemies
            this.physics.add.overlap(player, enemies, playerHitEnemy, null, this);

            // Set up cursor keys for movement
            cursors = this.input.keyboard.createCursorKeys();

            // Set up WASD keys for movement based on detected layout
            updateWASDKeys.call(this);

            // Set up touch controls
            this.input.on('pointerdown', (pointer) => {
                touchInput.isActive = true;
                touchInput.x = pointer.x;
                touchInput.y = pointer.y;
            });

            this.input.on('pointermove', (pointer) => {
                if (touchInput.isActive) {
                    touchInput.x = pointer.x;
                    touchInput.y = pointer.y;
                }
            });

            this.input.on('pointerup', () => {
                touchInput.isActive = false;
            });

            // Debug function to lvl up
            setupDebugKeys.call(this);

            // Create the game over screen (hidden initially)
            gameOverText = this.add.text(
                600, 400,
                'GAME OVER',
                { fontFamily: 'Arial', fontSize: '40px', color: '#ff0000', fontStyle: 'bold' }
            ).setOrigin(0.5).setVisible(false);

            // Create restart button (hidden initially)
            restartButton = this.add.text(
                600, 600,
                'PLAY AGAIN',
                { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff', backgroundColor: '#880000', padding: { left: 15, right: 15, top: 10, bottom: 10 } }
            ).setOrigin(0.5).setVisible(false).setInteractive();

            // Add restart button functionality
            restartButton.on('pointerdown', startGame, this);

            // Create learning feedback text (initially empty)
            this.learningFeedback = this.add.text(
                600, 770,
                '',
                {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    color: '#ffffff',
                    stroke: '#000000', // Add stroke for better readability with different colors
                    strokeThickness: 2,
                    align: 'center'
                }
            ).setOrigin(0.5).setDepth(100); // Ensure it displays above other elements

            // Start the game by calling startGame (replaces the need for duplicate initialization)
            startGame.call(this);
        }

        // Add this to your update function
        function update(time, delta) {
            if (gameOver) return;
            if (gamePaused) return; // Skip updates when game is paused for level up

            updatePerformanceStats.call(this, time, delta);
            updatePlayerStateEffects();

            // Increment elapsed time
            elapsedTime += delta / 1000; // delta is in milliseconds

            // Check if we should start quest mode
            checkQuestModeStart.call(this);

            // Update the level display to show time survived
            const levelDisplay = document.getElementById('level');
            levelDisplay.innerText = `Time Survived: ${formatTime(elapsedTime)}`;

            // Player movement with keyboard
            player.body.setVelocity(0);

            if (cursors.left.isDown || wasdKeys.left.isDown) {
                player.body.setVelocityX(-playerSpeed * 50);
            } else if (cursors.right.isDown || wasdKeys.right.isDown) {
                player.body.setVelocityX(playerSpeed * 50);
            }

            if (cursors.up.isDown || wasdKeys.up.isDown) {
                player.body.setVelocityY(-playerSpeed * 50);
            } else if (cursors.down.isDown || wasdKeys.down.isDown) {
                player.body.setVelocityY(playerSpeed * 50);
            }

            // Player movement with touch
            if (touchInput.isActive) {
                // Calculate direction vector
                const dx = touchInput.x - player.x;
                const dy = touchInput.y - player.y;

                // Normalize and scale
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) {  // Add a small threshold to prevent jitter
                    player.body.setVelocityX((dx / distance) * playerSpeed * 50);
                    player.body.setVelocityY((dy / distance) * playerSpeed * 50);
                }
            }

            // --- REVISED Enemy Movement Logic using Manual Acceleration Vector ---
            enemies.getChildren().forEach(enemy => {
                // Ensure enemy and its body are valid and active
                if (enemy && enemy.active && enemy.body) {
                    // Target position (player)
                    const targetX = player.x;
                    const targetY = player.y;

                    // Vector from enemy to player
                    const dx = targetX - enemy.x;
                    const dy = targetY - enemy.y;

                    // Distance to player
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Define the maximum speed the enemy should reach.
                    // Use the 'speed' property we assigned during spawn.
                    const maxSpeed = enemy.speed;

                    // Define the acceleration rate (pixels/sec^2). Tune this!
                    // It needs to be strong enough to overcome drag and feel responsive.
                    // Let's start with a multiple of maxSpeed, e.g., 5x to 10x.
                    const accelerationRate = maxSpeed * 8; // Example starting point

                    // Avoid division by zero and applying acceleration if already very close
                    if (distance > 1) { // Small threshold (1 pixel)
                        // Normalize the direction vector (dx/distance, dy/distance)
                        const dirX = dx / distance;
                        const dirY = dy / distance;

                        // Calculate acceleration components based on direction and rate
                        const accelX = dirX * accelerationRate;
                        const accelY = dirY * accelerationRate;

                        // Apply the calculated acceleration
                        enemy.body.setAcceleration(accelX, accelY);

                    } else {
                        // Optional: If very close, stop accelerating. Drag will slow it down.
                        enemy.body.setAcceleration(0, 0);
                        // Optionally, set velocity to 0 too if jittering occurs when very close
                        // enemy.body.setVelocity(0, 0);
                    }

                    // --- Manually Cap Speed ---
                    // We need to prevent acceleration from making the enemy exceed its maxSpeed.
                    const velocity = enemy.body.velocity;
                    const currentSpeedSq = velocity.lengthSq(); // Use squared length for efficiency

                    if (currentSpeedSq > maxSpeed * maxSpeed) {
                        // If current speed squared exceeds max speed squared, scale velocity back.
                        // Calculate the ratio of maxSpeed to currentSpeed
                        const currentSpeed = Math.sqrt(currentSpeedSq);
                        const scale = maxSpeed / currentSpeed;

                        // Apply the scale factor to the velocity components
                        enemy.body.setVelocity(velocity.x * scale, velocity.y * scale);

                        // Alternatively, using normalization (slightly more calculation but conceptually clear):
                        // const normVelX = velocity.x / currentSpeed;
                        // const normVelY = velocity.y / currentSpeed;
                        // enemy.body.setVelocity(normVelX * maxSpeed, normVelY * maxSpeed);
                    }
                    // Drag (set via setDrag()) will naturally oppose the velocity,
                    // helping to stabilize the speed around maxSpeed when accelerating,
                    // and slowing the enemy down after knockback or when acceleration stops.
                }
            });

            // Keep shield visual positioned on player
            if (shieldVisual) {
                shieldVisual.x = player.x;
                shieldVisual.y = player.y;
            }


            // Updated projectile processing
            projectiles.getChildren().forEach(projectile => {
                // Check if out of bounds
                if (projectile.y < -50 || projectile.y > 850 ||
                    projectile.x < -50 || projectile.x > 1250) {
                    projectile.destroy();
                    return;
                }

                // Process component updates
                if (projectile.components && Object.keys(projectile.components).length > 0) {
                    ProjectileComponentSystem.processEvent(projectile, 'update');
                }
            });

            // Update health bar
            GameUI.updateHealthBar(this);
            GameUI.updateExpBar(this);

            // Update UI
            document.getElementById('kills').textContent = `Enemies killed: ${score}`;

            // Update orbitals
            OrbitalSystem.update(this, time);

            // Calculate difficulty scaling based on elapsed time instead of raw time
            const minutesElapsed = elapsedTime / 60;

            // Call our new enemy spawner manager
            updateEnemySpawners.call(this);

            // Update player stats text
            updatePlayerStatsText();

            // Update player level
            if (heroExp >= heroExpToLevel) {
                levelUp.call(this);
            }
        }

        // Setup health regeneration
        function setupHealthRegeneration() {
            // Calculate delay based on max health (100s / maxHealth)
            const regenDelay = Math.ceil(100000 / maxPlayerHealth); // In milliseconds

            // Remove any existing regen timer
            if (healthRegenTimer) {
                healthRegenTimer.remove();
            }

            // Create and register health regeneration timer
            healthRegenTimer = registerTimer(this.time.addEvent({
                delay: regenDelay,
                callback: regenerateHealth,
                callbackScope: this,
                loop: true
            }));

            GameUI.updateHealthBar(this);

            console.log(`Health regeneration timer set: +1 HP every ${regenDelay / 1000} seconds`);
        }

        function regenerateHealth() {
            if (gameOver || gamePaused) return;

            // Only regenerate if health is below max
            if (playerHealth < maxPlayerHealth) {
                // Add 1 HP
                playerHealth = Math.min(playerHealth + 1, maxPlayerHealth);

                // Update health bar and text
                GameUI.updateHealthBar(this);

                // Show visual effect
                showRegenEffect(this);
            }
        }

        function showRegenEffect(scene) {
            // Create a healing indicator
            const healEffect = scene.add.text(player.x, player.y - 20, '+1', {
                fontFamily: 'Arial',
                fontSize: '16px',
                color: '#00ff00'
            }).setOrigin(0.5);

            // Animate the healing indicator
            scene.tweens.add({
                targets: healEffect,
                y: healEffect.y - 15,
                alpha: 0,
                duration: 800,
                onComplete: function () {
                    healEffect.destroy();
                }
            });
        }

        function levelUp() {
            // Calculate excess XP
            const excessXP = heroExp - heroExpToLevel;

            // Increase player level
            playerLevel++;

            // Set new XP threshold
            heroExpToLevel = xpForNextLevel(playerLevel);

            // Set XP to excess amount (instead of resetting to 0)
            heroExp = Math.max(0, excessXP);

            // Update the XP bar with new values
            GameUI.updateExpBar(this);

            // Show level up cards
            showLevelUpCards.call(this);
        }

        function updatePlayerStatsText() {
            const effectiveDamage = getEffectiveDamage();

            let statsText = `POW: ${effectiveDamage}\nAGI: ${playerFireRate}\nLUK: ${playerLuck}\nEND: ${maxPlayerHealth}`;

            // Update the text
            playerStatsText.setText(statsText);
        }

        function fireProjectile() {
            if (gameOver) return;

            // Find the closest enemy within 400px
            let closestEnemy = null;
            let closestDistance = 400;

            enemies.getChildren().forEach(enemy => {
                if (!enemy) return; // Skip if enemy is null or undefined

                const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEnemy = enemy;
                }
            });

            if (closestEnemy) {
                // Calculate direction to the enemy
                const angle = Phaser.Math.Angle.Between(player.x, player.y, closestEnemy.x, closestEnemy.y);

                // Create the main projectile
                createSingleProjectile.call(this, angle);

                // Check for double shot if we have that perk
                if (hasPerk('PURPLE_OWL')) {
                    // Base chance: 20% at Luck 4
                    const doubleChance = calculateProcChance(playerLuck, baseProcChance);

                    if (Math.random() < doubleChance) {
                        // Fire a second projectile with slight angle variation
                        const angleVariation = (Math.random() - 0.5) * 0.2; // Small random angle variation
                        createSingleProjectile.call(this, angle + angleVariation);
                    }
                }
            }
        }

        function createProjectileBase(scene, x, y, color = '#ffff00', symbol = '★') {
            // Get the effective damage including all multipliers
            const effectiveDamage = getEffectiveDamage();

            // Create the projectile
            const projectile = scene.add.text(x, y, symbol, {
                fontFamily: 'Arial',
                fontSize: `${projectileSizeFactor * effectiveDamage}px`,
                color: color,
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Add to physics group
            projectiles.add(projectile);

            // Set projectile properties (smaller hitbox for better visual feel)
            projectile.body.setSize(projectile.width / 2, projectile.height / 2);

            // Set damage value using the effective damage
            projectile.damage = effectiveDamage;

            // Initialize empty components object
            projectile.components = {};

            // Return the created projectile
            return projectile;
        }

        function createSingleProjectile(angle) {
            // --- Keep original base creation ---
            const projectile = createProjectileBase(this, player.x, player.y);

            // *** Set defaults for piercing flags ***
            projectile.isPiercing = false;
            projectile.canHitMultiple = false;
            // No need to initialize 'enemiesHit' data here, piercing components will do it

            if (projectile.body) { // Check if the physics body exists
                // Calculate mass based on playerFireRate (AGI) relative to base AGI
                // Ensures mass scales linearly from the base mass at base AGI
                const calculatedMass = baseProjectileMass * playerFireRate;
                projectile.body.setMass(calculatedMass);
                // console.log(`Projectile mass set to: ${calculatedMass.toFixed(2)} (AGI: ${playerFireRate})`); // Optional: for debugging
            }

            const speed = 400;
            if (projectile.body) { // Safety check
                projectile.body.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );
            }

            // --- Keep applying perk effects ---
            // This is where a component like boomerang will set isPiercing = true etc.
            ProjectilePerkRegistry.applyPerkEffects(projectile, this);

            // --- NEW: Safety check AFTER applying perks ---
            // If a component made it piercing, ensure hit tracking data is initialized
            // This is a fallback in case the component's initialize missed it.
            if (projectile.isPiercing === true && !projectile.getData('enemiesHit')) {
                console.warn("Piercing projectile missing 'enemiesHit' data after perk application. Initializing.");
                projectile.setData('enemiesHit', []);
            }

            return projectile;
        }
        // Quest data structure (used when active)
        function createQuest(enemyType) {
            const enemyData = getEnemyData(enemyType);

            // Calculate required kills based on quest count
            // First quest: 4, Second quest: 8, Third quest: 12, etc.
            const required = BASE_QUEST_DIFFICULTY * (questCount + 1);

            return {
                enemyType: enemyType,
                kanji: enemyType,
                kana: enemyData.kana,
                romaji: enemyData.romaji,
                english: enemyData.english,
                killed: 0,
                required: required,
                completed: false
            };
        }

        // Check if we should start quest mode (call this in update)
        function checkQuestModeStart() {
            // If we've reached the quest start time and haven't shown transition yet
            if (!questMode && elapsedTime >= questStartTime && !questTransitionShown) {
                startQuestMode.call(this);;
            }
        }

        // Start quest mode with dramatic effect
        function startQuestMode() {
            questMode = true;
            questTransitionShown = true;

            // Create dramatic kanji transition effect
            const questKanji = this.add.text(600, 400, '任務', {
                fontFamily: 'Arial',
                fontSize: '250px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 8
            }).setOrigin(0.5);
            questKanji.setAlpha(0);

            // Subtitle
            const questSubtitle = this.add.text(600, 550, 'QUESTS BEGIN', {
                fontFamily: 'Arial',
                fontSize: '40px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);
            questSubtitle.setAlpha(0);

            // Dramatic animation sequence
            this.tweens.add({
                targets: questKanji,
                scale: { from: 0.2, to: 1 },
                alpha: { from: 0, to: 0.7 },
                duration: 1000,
                ease: 'Power2',
                onComplete: () => {
                    this.tweens.add({
                        targets: questKanji,
                        scale: { from: 1, to: 1.5 },
                        alpha: { from: 0.7, to: 0 },
                        duration: 1500,
                        ease: 'Power2',
                        onComplete: () => {
                            questKanji.destroy();
                        }
                    });
                }
            });

            this.tweens.add({
                targets: questSubtitle,
                alpha: { from: 0, to: 1 },
                duration: 1000,
                delay: 500,
                ease: 'Power2',
                onComplete: () => {
                    this.tweens.add({
                        targets: questSubtitle,
                        alpha: { from: 1, to: 0 },
                        duration: 1000,
                        delay: 1000,
                        ease: 'Power2',
                        onComplete: () => {
                            questSubtitle.destroy();
                            // Start the first quest
                            startNewQuest.call(this);
                        }
                    });
                }
            });
        }



        // Start a new quest
        function startNewQuest() {
            // Get all available enemy types
            const enemyTypes = getAllEnemyTypes();

            // Remove previous quest type from options to avoid repeats
            let availableTypes = enemyTypes;
            if (previousQuestType) {
                availableTypes = enemyTypes.filter(type => type !== previousQuestType);
            }

            // Select a random enemy type
            const randomIndex = Math.floor(Math.random() * availableTypes.length);
            const selectedType = availableTypes[randomIndex];

            // Create the new quest
            currentQuest = createQuest(selectedType);
            previousQuestType = selectedType;

            // Update the learning text to show quest
            updateQuestDisplay.call(this);

            // Create a brief highlight effect
            const questNotification = this.add.text(600, 400, 'NEW QUEST', {
                fontFamily: 'Arial',
                fontSize: '60px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);

            // Animate the notification
            this.tweens.add({
                targets: questNotification,
                y: questNotification.y - 100,
                alpha: { from: 1, to: 0 },
                duration: 1500,
                ease: 'Power2',
                onComplete: () => {
                    questNotification.destroy();
                }
            });
        }

        // Update quest display in learning feedback area
        function updateQuestDisplay() {
            if (!currentQuest || !this.learningFeedback) return;

            const questText = `Hunt: ${currentQuest.kanji} (${currentQuest.kana}) [${currentQuest.romaji}] - ${currentQuest.english} (${currentQuest.killed}/${currentQuest.required})`;
            this.learningFeedback.setText(questText);

            // Set alpha to full to ensure visibility
            this.learningFeedback.setAlpha(1);
        }

        // Call this when an enemy is defeated to check quest progress
        function checkQuestProgress(enemy) {
            if (!questMode || !currentQuest) return;

            // Check if the defeated enemy matches the quest target
            if (enemy.text === currentQuest.enemyType) {
                // Increment kill counter
                currentQuest.killed++;

                // Update the display
                updateQuestDisplay.call(this);

                // Create a popup effect to indicate progress
                const progressText = this.add.text(
                    enemy.x, enemy.y - 30,
                    `QUEST`,
                    { fontFamily: 'Arial', fontSize: '16px', color: '#ffff00', stroke: '#000000', strokeThickness: 3 }
                ).setOrigin(0.5);

                this.tweens.add({
                    targets: progressText,
                    y: progressText.y - 30,
                    alpha: { from: 1, to: 0 },
                    duration: 1000,
                    ease: 'Power2',
                    onComplete: () => {
                        progressText.destroy();
                    }
                });

                // Check if quest is completed
                if (currentQuest.killed >= currentQuest.required) {
                    completeQuest.call(this);
                }
            }
        }

        // Handle quest completion
        function completeQuest() {
            // Mark as completed
            currentQuest.completed = true;

            // Calculate reward (half of XP needed for next level)
            const rewardXP = Math.floor(heroExpToLevel / 2);

            // Add XP
            heroExp += rewardXP;

            // Update the XP bar
            GameUI.updateExpBar(this);

            // Increment quest counter for next quest
            questCount++;

            // Show completion effect
            const completionText = this.add.text(600, 400, 'QUEST COMPLETE', {
                fontFamily: 'Arial',
                fontSize: '60px',
                color: '#00ff00',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);

            // Show reward
            const rewardText = this.add.text(600, 470, `+${rewardXP} XP`, {
                fontFamily: 'Arial',
                fontSize: '36px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);

            // Animate completion notification
            this.tweens.add({
                targets: [completionText, rewardText],
                alpha: { from: 1, to: 0 },
                y: '-=50',
                duration: 2000,
                ease: 'Power2',
                onComplete: () => {
                    completionText.destroy();
                    rewardText.destroy();

                    // Start a new quest after a short delay
                    this.time.delayedCall(1000, () => {
                        startNewQuest.call(this);
                    });
                }
            });
        }


        // Modify the defeatedEnemy function to handle quests
        // Helper function to get a legible random color
        function getRandomLegibleColor() {
            const legibleColors = [
                '#ffffff', // white
                '#ffff00', // yellow
                '#00ffff', // cyan
                '#ff00ff', // magenta
                '#00ff88', // mint green
                '#ff8800', // orange
                '#88ff00', // lime
                '#00bbff', // sky blue
                '#ff88ff', // pink
                '#ffbb00', // gold
                '#00ffbb', // turquoise
                '#bbff00'  // chartreuse
            ];

            return legibleColors[Math.floor(Math.random() * legibleColors.length)];
        }

        // Helper function to get a random defeat synonym
        function getRandomDefeatSynonym() {
            return DEFEAT_SYNONYMS[Math.floor(Math.random() * DEFEAT_SYNONYMS.length)];
        }

        function defeatedEnemy(enemy) {
            // Only show learning feedback for enemies of the current (highest) rank
            if (this.learningFeedback && enemy.rank === currentEnemyRank) {
                // Set white color for this text
                const textColor = '#ffffff';

                // Update the text
                this.learningFeedback.setText(
                    `${enemy.text} (${enemy.kana}) [${enemy.romaji}] - ${enemy.english}`
                );

                // Reset scale for animation
                this.learningFeedback.setScale(1);

                // Create subtle scale animation (grow, then back to normal)
                this.tweens.add({
                    targets: this.learningFeedback,
                    scale: { from: 0.95, to: 1 }, // Grow slightly
                    duration: 80, // Fast animation (half the time of perk hover)
                    ease: 'Sine.easeOut'
                });
            }

            // Destroy the enemy entity
            enemy.destroy();

            // Increment score
            score++;

            // Add experience
            heroExp += enemy.expValue;

            // Update exp bar
            GameUI.updateExpBar(this);

            // Check quest progress (this needs to work for all enemy ranks)
            if (questMode && currentQuest) {
                checkQuestProgress.call(this, enemy);
            }
        }


        function getRandomLegibleColor() {
            return LEGIBLE_COLORS[Math.floor(Math.random() * LEGIBLE_COLORS.length)];
        }

        // Helper function to get a random defeat synonym
        function getRandomDefeatSynonym() {
            return DEFEAT_SYNONYMS[Math.floor(Math.random() * DEFEAT_SYNONYMS.length)];
        }


        function updatePlayerStateEffects() {
            // This now just calls the centralized player status system
            updatePlayerStatus();
        }

        function playerHitEnemy(player, enemy) {
            // Check if player was already hit
            if (playerInvincible) return;

            // Make the player invincible to damage while flashing
            playerInvincible = true;

            // Flash the player when hit
            this.tweens.add({
                targets: player,
                alpha: 0.5,
                scale: 1.2,
                duration: 250,
                yoyo: true,
                repeat: 1,
                onComplete: function () {
                    // Ensure alpha is reset properly
                    player.alpha = 1;
                    player.scale = 1;
                }
            });

            // Remove invincibility after 500ms
            this.time.delayedCall(500, function () {
                playerInvincible = false;

                // Double-check alpha is reset even if tween was interrupted
                if (player.active) {
                    player.alpha = 1;
                    player.scale = 1;
                }
            });

            // Check for Purple Hedgehog perk and trigger defensive burst
            if (hasPerk('PURPLE_HEDGEHOG')) {
                triggerDefensiveBurst.call(this);
            }

            // Check if shield is active
            if (window.isShieldActive()) {
                // Shield absorbs the hit - this will handle cooldown for permanent shields
                window.triggerShieldHit();

                // Flash the shield effect
                this.tweens.add({
                    targets: player,
                    alpha: 0.5,
                    scale: 1.2,
                    duration: 100,
                    yoyo: true,
                    repeat: 1
                });

                return;
            }

            // Apply damage to player
            const damageAmount = enemy.damage ?? 1;
            playerHealth -= damageAmount;

            // Update health text and bar
            GameUI.updateHealthBar(this);

            // Check if player is dead
            if (playerHealth < 1) {
                playerDeath.call(this);
            }
        }

        // Function to create the defensive burst effect (simplified)
        function triggerDefensiveBurst() {
            // Calculate number of projectiles based on luck (2 * LUCK)
            const projectileCount = playerLuck * 2;

            // Visual effect at player position
            const burstEffect = this.add.circle(player.x, player.y, 40, 0x9370db, 0.5);
            this.tweens.add({
                targets: burstEffect,
                alpha: 0,
                scale: 2,
                duration: 300,
                onComplete: function () {
                    burstEffect.destroy();
                }
            });

            // Create each projectile in the burst
            for (let i = 0; i < projectileCount; i++) {
                // Calculate angle for even distribution (in radians)
                const angle = (i / projectileCount) * Math.PI * 2;

                // Create projectile using shared base
                const projectile = createProjectileBase(this, player.x, player.y, '#9370db');

                // Set velocity based on angle
                const speed = 400;
                projectile.body.setVelocity(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                );

                // Add special property
                projectile.isDefensiveBurst = true;
            }
        }

        function playerDeath() {
            // Set game over state
            gameOver = true;

            // Pause the game physics to stop all movement
            pauseGame();

            // Show game over text and restart button
            gameOverText.setText(`GAME OVER\nTime Survived: ${formatTime(elapsedTime)}\nEnemies killed: ${score}`);
            gameOverText.setVisible(true);
            restartButton.setVisible(true);
        }

        // Enhanced level up cards with romaji typing challenge
        function showLevelUpCards() {
            // Pause the game
            pauseGame();

            // Create semi-transparent background
            const levelUpBackground = this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.7);

            // Create level up title with improved styling
            const levelUpTitle = this.add.text(
                600, 150,
                'LEVEL UP!',
                {
                    fontFamily: 'Arial',
                    fontSize: '32px',
                    color: '#ffffff',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 4
                }
            ).setOrigin(0.5);

            // Removed the subtitle text that was getting covered by cards

            // Get random perks (excluding already acquired ones)
            const selectedPerks = PerkSystem.getRandomPerks(4, acquiredPerks);

            // Store all level up UI elements
            const cardElements = [];

            // Create tracking variables for the challenge
            this.perkChallenge = {
                currentCards: 1,        // Start with 1 card
                maxCards: 4,            // Maximum of 4 cards
                selectedPerks: selectedPerks,
                inputActive: true,      // Whether input is active
                attempts: 0,            // Number of failed attempts on current card
                currentIndex: 0,        // Current perk being challenged
                cardElements: []        // Store card elements for updating
            };

            // Create a container for cards
            this.perkCardContainer = this.add.container(0, 0);

            // Create input field for romaji typing
            createRomajiInput.call(this, 600, 580); // Moved lower vertically

            // Create initial card(s)
            updatePerkCardDisplay.call(this);

            // Store all level up UI elements in the global array
            levelUpCards = [
                levelUpBackground,
                levelUpTitle,
                this.perkCardContainer,
                this.inputBox,
                this.inputText,
                this.submitButton,
                this.inputPrompt
            ];
        }

        // --- FINAL VERSION of checkProjectilePiercing ---
        function checkProjectilePiercing(projectile, enemy) {
            if (!projectile || !projectile.active || !projectile.body || !enemy || !enemy.active || !enemy.body) { return false; }
            if (projectile.isPiercing === true) { return false; }
            else { return true; }
        }

        // --- FINAL VERSION of handleProjectileEnemyCollision ---
        function handleProjectileEnemyCollision(projectile, enemy) {
            if (!projectile || !projectile.active || !projectile.body || !enemy || !enemy.active || !enemy.body) { return; }
            const isPiercing = projectile.isPiercing === true;
            if (!projectile.damageSourceId) { projectile.damageSourceId = `proj_${Date.now()}_${Math.random()}`; }

            if (isPiercing) {
                if (projectile.canHitMultiple === true) {
                    let enemiesHit = projectile.getData('enemiesHit');
                    if (!enemiesHit) { enemiesHit = []; projectile.setData('enemiesHit', enemiesHit); }
                    if (enemy.uniqueId && !enemiesHit.includes(enemy.uniqueId)) {
                        enemiesHit.push(enemy.uniqueId);
                        applyContactDamage.call(this, projectile, enemy, projectile.damage, 0);
                        ProjectileComponentSystem.processEvent(projectile, 'onHit', enemy, this);
                    } else if (!enemy.uniqueId) {
                        console.warn("Enemy missing uniqueId for piercing hit tracking.");
                        applyContactDamage.call(this, projectile, enemy, projectile.damage, projectile.hitCooldown || 500);
                        ProjectileComponentSystem.processEvent(projectile, 'onHit', enemy, this);
                    }
                } else {
                    console.warn("Piercing projectile without canHitMultiple flag.");
                    applyContactDamage.call(this, projectile, enemy, projectile.damage, 0);
                    ProjectileComponentSystem.processEvent(projectile, 'onHit', enemy, this);
                }
            } else {
                applyContactDamage.call(this, projectile, enemy, projectile.damage, 0);
                ProjectileComponentSystem.processEvent(projectile, 'onHit', enemy, this);
                // --- DELAYED DESTRUCTION ---
                projectile.setActive(false);
                projectile.setVisible(false);
                if (projectile.body) { projectile.body.enable = false; }
                this.time.delayedCall(1, () => {
                    if (projectile) { // Basic check if it still exists
                        // Check active state as set before delay
                        if (projectile.active === false) {
                            if (typeof projectile.killAndHide === 'function') {
                                // projectile.killAndHide(); // Pooling logic if you implement it
                            } else if (projectile.destroy) { // Check destroy exists
                                // Check if scene still exists before destroying
                                if (projectile.scene) {
                                    projectile.destroy();
                                } else {
                                    // console.warn("Projectile scene missing before destroy"); // Optional warning
                                }
                            }
                        }
                    }
                });
            }
        }
        // Helper function to disable debug keys
        function disableDebugKeys() {
            // We'll use a simple approach: add a flag that the debug key handlers can check
            this.debugKeysDisabled = true;
        }

        // Helper function to restore debug keys
        function restoreDebugKeys() {
            // Clear the flag to allow debug keys to work again
            this.debugKeysDisabled = false;
        }

        // Enhanced cleanup function
        function closeLevelUpCards() {
            console.log("Closing level up cards and cleaning up UI elements");

            // Clean up the window key handler
            if (this.romajiKeyHandler) {
                window.removeEventListener('keydown', this.romajiKeyHandler);
                this.romajiKeyHandler = null;
            }

            // Disable our custom handler
            this.isRomajiInputActive = false;

            // Re-enable debug keys
            restoreDebugKeys.call(this);

            // Extra safety: check if we're in a valid scene
            if (!this.add) {
                console.log("Not in a valid scene, forcing cleanup");
                levelUpCards = [];
                return;
            }

            // First, make all elements invisible for cleaner transition
            if (Array.isArray(levelUpCards)) {
                levelUpCards.forEach(element => {
                    if (element && element.setVisible) {
                        element.setVisible(false);
                    }
                });
            }

            // Then destroy all tracked UI elements
            if (Array.isArray(levelUpCards)) {
                levelUpCards.forEach(element => {
                    if (element && typeof element !== 'undefined') {
                        if (element.destroy) {
                            element.destroy();
                        } else if (element.removeAll) {
                            element.removeAll(true);
                            element.destroy();
                        }
                    }
                });
            }

            // Extra safety to clean up specific elements that might be missed
            if (this.perkCardContainer) {
                this.perkCardContainer.removeAll(true);
                this.perkCardContainer.destroy();
                this.perkCardContainer = null;
            }

            if (this.inputBox) {
                this.inputBox.destroy();
                this.inputBox = null;
            }

            if (this.inputText) {
                this.inputText.destroy();
                this.inputText = null;
            }

            if (this.submitButton) {
                this.submitButton.destroy();
                this.submitButton = null;
            }

            if (this.inputPrompt) {
                this.inputPrompt.destroy();
                this.inputPrompt = null;
            }

            // Reset challenge state
            this.perkChallenge = null;

            // Reset global array
            levelUpCards = [];

            // Resume game
            resumeGame();

            console.log("Level up cards cleanup complete");
        }

        // Function to create the input field for romaji typing
        function createRomajiInput(x, y) {
            // Create input prompt
            this.inputPrompt = this.add.text(
                x, y - 50,
                'TYPE ROMAJI TO UNLOCK MORE',
                {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#ffffff'
                }
            ).setOrigin(0.5);

            // Create input box background
            this.inputBox = this.add.rectangle(x, y, 300, 40, 0x333333, 1)
                .setStrokeStyle(2, 0xaaaaaa);

            // Create input text
            this.inputText = this.add.text(
                x - 140, y - 15,
                '',
                {
                    fontFamily: 'Arial',
                    fontSize: '20px',
                    color: '#ffffff'
                }
            );

            // Create submit button - below the input box
            this.submitButton = this.add.text(
                x, y + 50,
                'Submit',
                {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#ffffff',
                    backgroundColor: '#008800',
                    padding: { left: 15, right: 15, top: 8, bottom: 8 }
                }
            ).setOrigin(0.5);

            this.submitButton.setInteractive({ useHandCursor: true });

            // Add button hover effects
            this.submitButton.on('pointerover', function () {
                this.setStyle({ backgroundColor: '#00aa00' });
            });

            this.submitButton.on('pointerout', function () {
                this.setStyle({ backgroundColor: '#008800' });
            });

            // Add click event
            this.submitButton.on('pointerdown', function () {
                validateRomajiInput.call(this.scene);
            });

            // Set a flag to track our custom keyboard handler
            this.isRomajiInputActive = true;

            // Create a one-time-use generic keyboard event handler
            this.romajiKeyHandler = function (event) {
                // Only process if the challenge is active
                if (!this.isRomajiInputActive || !this.perkChallenge || !this.perkChallenge.inputActive) return;

                // Handle different key types
                if (event.key === 'Backspace') {
                    // Backspace - remove last character
                    if (this.inputText.text.length > 0) {
                        this.inputText.setText(this.inputText.text.slice(0, -1));
                    }
                }
                else if (event.key === 'Enter') {
                    // Enter - submit answer
                    validateRomajiInput.call(this);
                }
                else if (/^[a-zA-Z\-]$/.test(event.key)) {
                    // Letters and dash - add to input
                    this.inputText.setText(this.inputText.text + event.key.toLowerCase());
                }
            };

            // Bind the handler to the scene
            this.romajiKeyHandler = this.romajiKeyHandler.bind(this);

            // Add the handler to the window keydown event
            window.addEventListener('keydown', this.romajiKeyHandler);

            // Disable debug keys during the challenge
            disableDebugKeys.call(this);
        }

        // Helper function to disable debug keys
        function disableDebugKeys() {
            // We'll use a simple approach: add a flag that the debug key handlers can check
            this.debugKeysDisabled = true;
        }

        // Helper function to restore debug keys
        function restoreDebugKeys() {
            // Clear the flag to allow debug keys to work again
            this.debugKeysDisabled = false;
        }

        // Enhanced cleanup function
        function closeLevelUpCards() {
            console.log("Closing level up cards and cleaning up UI elements");

            // Clean up the window key handler
            if (this.romajiKeyHandler) {
                window.removeEventListener('keydown', this.romajiKeyHandler);
                this.romajiKeyHandler = null;
            }

            // Disable our custom handler
            this.isRomajiInputActive = false;

            // Re-enable debug keys
            restoreDebugKeys.call(this);

            // Extra safety: check if we're in a valid scene
            if (!this.add) {
                console.log("Not in a valid scene, forcing cleanup");
                levelUpCards = [];
                return;
            }

            // First, make all elements invisible for cleaner transition
            if (Array.isArray(levelUpCards)) {
                levelUpCards.forEach(element => {
                    if (element && element.setVisible) {
                        element.setVisible(false);
                    }
                });
            }

            // Then destroy all tracked UI elements
            if (Array.isArray(levelUpCards)) {
                levelUpCards.forEach(element => {
                    if (element && typeof element !== 'undefined') {
                        if (element.destroy) {
                            element.destroy();
                        } else if (element.removeAll) {
                            element.removeAll(true);
                            element.destroy();
                        }
                    }
                });
            }

            // Extra safety to clean up specific elements that might be missed
            if (this.perkCardContainer) {
                this.perkCardContainer.removeAll(true);
                this.perkCardContainer.destroy();
                this.perkCardContainer = null;
            }

            if (this.inputBox) {
                this.inputBox.destroy();
                this.inputBox = null;
            }

            if (this.inputText) {
                this.inputText.destroy();
                this.inputText = null;
            }

            if (this.submitButton) {
                this.submitButton.destroy();
                this.submitButton = null;
            }

            if (this.inputPrompt) {
                this.inputPrompt.destroy();
                this.inputPrompt = null;
            }

            // Reset challenge state
            this.perkChallenge = null;

            // Reset global array
            levelUpCards = [];

            // Resume game
            resumeGame();

            console.log("Level up cards cleanup complete");
        }

        // Updated setupDebugKeys function that handles all debug keys including performance monitor (O key)
        function setupDebugKeys() {
            // Add debug key (R key for instant level up)
            this.input.keyboard.on('keydown-R', function (event) {
                // Skip if debug keys are disabled
                if (this.debugKeysDisabled) return;

                if (!gamePaused && !gameOver) {
                    // Add enough XP to level up
                    const xpNeeded = heroExpToLevel - heroExp;
                    heroExp += xpNeeded;
                    GameUI.updateExpBar(this);
                    console.log("Debug: Instant level up triggered");
                }
            }, this);

            // Add debug key (T key for instant enemy spawn)
            this.input.keyboard.on('keydown-T', function (event) {
                // Skip if debug keys are disabled
                if (this.debugKeysDisabled) return;

                if (!gamePaused && !gameOver) {
                    // Access the main game scene and call spawnEnemyOfRank on it with rank 1
                    const activeScene = game.scene.scenes[0];
                    if (activeScene) {
                        spawnEnemyOfRank.call(activeScene, 1);
                        console.log("Debug: Rank 1 enemy spawned");
                    }
                }
            }, this);

            // Add debug key (K key for skipping to next enemy phase)
            this.input.keyboard.on('keydown-K', function (event) {
                // Skip if debug keys are disabled
                if (this.debugKeysDisabled) return;

                if (!gamePaused && !gameOver) {
                    // Skip to next phase based on current elapsed time
                    skipToNextPhase.call(this);
                }
            }, this);

            // Add debug key (O key for performance monitor toggle)
            this.input.keyboard.on('keydown-O', function (event) {
                // Skip if debug keys are disabled
                if (this.debugKeysDisabled) return;

                // Toggle debug mode and stats visibility
                toggleDebugMode.call(this);
            }, this);
        }

        function skipToNextPhase() {
            // Based on your code, enemy phases are determined by rankEnemyStartTimes
            // which indicates rank 2 enemies start at 12 minutes (720 seconds)

            // Get the current minutes elapsed
            const currentMinutes = elapsedTime / 60;

            // Find the next phase timing based on rankEnemyStartTimes
            // Convert the start times from seconds to minutes
            const phaseTimings = Object.values(rankEnemyStartTimes).map(time => time / 60);

            // Sort the phase timings to ensure they're in ascending order
            phaseTimings.sort((a, b) => a - b);

            // Find the next phase timing
            let nextPhaseMinutes = null;
            for (const phaseTime of phaseTimings) {
                if (phaseTime > currentMinutes) {
                    nextPhaseMinutes = phaseTime;
                    break;
                }
            }

            // If no next phase was found, add 12 minutes (common phase interval)
            if (nextPhaseMinutes === null) {
                // Find the highest phase timing and add 12 minutes
                const highestPhase = Math.max(...phaseTimings);
                nextPhaseMinutes = Math.floor(currentMinutes / 12) * 12 + 12;

                // Ensure we're actually advancing time
                if (nextPhaseMinutes <= currentMinutes) {
                    nextPhaseMinutes = currentMinutes + 12;
                }
            }

            // Update elapsedTime to the new phase time (in seconds)
            const oldElapsedTime = elapsedTime;
            elapsedTime = nextPhaseMinutes * 60;

            // Log the action
            console.log(`Debug: Time skipped from ${Math.floor(oldElapsedTime / 60)} minutes to ${nextPhaseMinutes} minutes`);

            // Update the level display
            const levelDisplay = document.getElementById('level');
            if (levelDisplay) {
                levelDisplay.innerText = `Time Survived: ${formatTime(elapsedTime)}`;
            }

            // Potentially trigger any time-based events that should happen
            // This will depend on how your game handles time-based events

            // Update enemy spawners to reflect the new time
            const activeScene = game.scene.scenes[0];
            if (activeScene) {
                updateEnemySpawners.call(activeScene);
            }
        }

        // Update setupPerformanceMonitor to not add its own key listener
        function setupPerformanceMonitor() {
            // Create stats text display (initially hidden)
            statsText = this.add.text(1000, 10, 'FPS: 0', {
                fontFamily: 'Arial',
                fontSize: '14px',
                color: '#00ff00',
                backgroundColor: '#000000',
                padding: { x: 5, y: 5 }
            });
            statsText.setDepth(1000);
            statsText.visible = false;
            statsVisible = false;

            // O key listener is now handled in setupDebugKeys

            console.log("Performance monitor initialized (press O to toggle)");
        }

        // Helper function to handle debug keys state
        function setupDebugKeysState(enabled) {
            // Safely handle debug key state without accessing internal Phaser structures
            try {
                // Store the current state if we're disabling
                if (!enabled) {
                    this.debugKeysEnabled = false;

                    // Disable the debug keys by removing their event handlers
                    const debugKeys = ['R', 'T', 'O'];
                    debugKeys.forEach(key => {
                        const keyObj = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[key]);
                        if (keyObj) {
                            keyObj.enabled = false;
                        }
                    });
                } else {
                    this.debugKeysEnabled = true;

                    // Re-enable the debug keys
                    const debugKeys = ['R', 'T', 'O'];
                    debugKeys.forEach(key => {
                        const keyObj = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[key]);
                        if (keyObj) {
                            keyObj.enabled = true;
                        }
                    });
                }
            } catch (error) {
                console.log("Error managing debug keys:", error);
            }
        }

        // Helper function to generate random ID for keyboard event namespace
        function randomKeyboardId() {
            return 'romaji-input-' + Math.floor(Math.random() * 1000000);
        }


        // Function to validate romaji input
        function validateRomajiInput() {
            if (!this.perkChallenge || !this.perkChallenge.inputActive) return;

            const userInput = this.inputText.text.trim().toLowerCase();
            const currentPerk = this.perkChallenge.selectedPerks[this.perkChallenge.currentIndex];

            if (!currentPerk) return;

            const correctRomaji = currentPerk.romaji.toLowerCase();

            if (userInput === correctRomaji) {
                // Correct answer
                handleCorrectRomaji.call(this);
            } else {
                // Wrong answer
                handleWrongRomaji.call(this);
            }

            // Clear input field
            this.inputText.setText('');
        }

        // Function to handle correct romaji input
        function handleCorrectRomaji() {
            // Play success sound/effect
            this.tweens.add({
                targets: this.inputBox,
                strokeStyle: { value: 0x00ff00 },
                alpha: { value: 0.8 },
                yoyo: true,
                duration: 200,
                repeat: 1,
                onComplete: () => {
                    this.inputBox.setStrokeStyle(2, 0xaaaaaa);
                    this.inputBox.alpha = 1;
                }
            });

            // Show success message
            const successText = this.add.text(
                600, 650,
                'Correct!',
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: '#00ff00',
                    fontStyle: 'bold'
                }
            ).setOrigin(0.5);

            this.tweens.add({
                targets: successText,
                y: successText.y - 30,
                alpha: 0,
                duration: 1000,
                onComplete: function () {
                    successText.destroy();
                }
            });

            // Unlock the current card (show full details)
            this.perkChallenge.attempts = 2; // Force full details

            // If this is the final card (4th), give XP reward
            if (this.perkChallenge.currentCards >= this.perkChallenge.maxCards) {
                // Award 25% of XP needed for next level
                const currentLevel = playerLevel;
                const currentExpToLevel = heroExpToLevel;
                const currentExp = heroExp;

                const xpReward = Math.ceil(heroExpToLevel * 0.25);
                console.log(`Level ${currentLevel}: Calculating reward as 25% of ${currentExpToLevel} = ${xpReward}`);

                heroExp += xpReward;
                console.log(`XP before: ${currentExp}, after: ${heroExp}, needed: ${heroExpToLevel}`);

                // After updating the XP bar, check if something unexpected happened
                setTimeout(() => {
                    console.log(`Post-update check: Level ${playerLevel}, XP ${heroExp}/${heroExpToLevel}`);
                    if (playerLevel > currentLevel) {
                        console.log(`WARNING: Level changed from ${currentLevel} to ${playerLevel} after challenge reward!`);
                    }
                }, 100);
                GameUI.updateExpBar(this);

                // Show XP reward
                const rewardText = this.add.text(
                    600, 680,
                    `+${xpReward} XP Bonus!`,
                    {
                        fontFamily: 'Arial',
                        fontSize: '20px',
                        color: '#00ffff',
                        fontStyle: 'bold'
                    }
                ).setOrigin(0.5);

                this.tweens.add({
                    targets: rewardText,
                    y: rewardText.y - 30,
                    alpha: 0,
                    duration: 1500,
                    onComplete: function () {
                        rewardText.destroy();
                    }
                });

                // End the input challenge
                this.perkChallenge.inputActive = false;
            } else {
                // Increment current card count
                this.perkChallenge.currentCards = Math.min(
                    this.perkChallenge.currentCards + 1,
                    this.perkChallenge.maxCards
                );

                // Update current challenge index
                this.perkChallenge.currentIndex = this.perkChallenge.currentCards - 1;
                this.perkChallenge.attempts = 0;
            }

            // Update card display
            updatePerkCardDisplay.call(this);
        }

        // Function to handle incorrect romaji input
        function handleWrongRomaji() {
            console.log("Wrong romaji input, attempts: " + this.perkChallenge.attempts);

            // Play failure sound/effect
            this.tweens.add({
                targets: this.inputBox,
                strokeStyle: { value: 0xff0000 },
                alpha: { value: 0.8 },
                yoyo: true,
                duration: 200,
                repeat: 1,
                onComplete: () => {
                    this.inputBox.setStrokeStyle(2, 0xaaaaaa);
                    this.inputBox.alpha = 1;
                }
            });

            // Increment attempts
            this.perkChallenge.attempts++;
            console.log("Attempts increased to: " + this.perkChallenge.attempts);

            if (this.perkChallenge.attempts === 1) {
                // First wrong attempt - show kana hint
                const hintText = this.add.text(
                    600, 650,
                    'Hint: Check the kana!',
                    {
                        fontFamily: 'Arial',
                        fontSize: '18px',
                        color: '#ffff00'
                    }
                ).setOrigin(0.5);

                this.tweens.add({
                    targets: hintText,
                    y: hintText.y - 20,
                    alpha: 0,
                    duration: 1500,
                    onComplete: function () {
                        hintText.destroy();
                    }
                });

                // Force show kana for the current card
                const currentPerk = this.perkChallenge.selectedPerks[this.perkChallenge.currentIndex];
                const cardX = this.perkChallenge.cardElements[this.perkChallenge.currentIndex].background.x;

                // Add kana text directly
                const kanaText = this.add.text(
                    cardX, 315,
                    currentPerk.kana,
                    { fontFamily: 'Arial', fontSize: '20px', color: '#ffffff' }
                ).setOrigin(0.5);

                this.perkCardContainer.add(kanaText);
                this.perkChallenge.cardElements[this.perkChallenge.currentIndex].elements.push(kanaText);

                console.log("Added kana hint:", currentPerk.kana);
            } else {
                // Second wrong attempt - end input challenge
                const failText = this.add.text(
                    600, 650,
                    'Challenge ended - pick a perk',
                    {
                        fontFamily: 'Arial',
                        fontSize: '18px',
                        color: '#ff6666'
                    }
                ).setOrigin(0.5);

                this.tweens.add({
                    targets: failText,
                    y: failText.y - 20,
                    alpha: 0,
                    duration: 1500,
                    onComplete: function () {
                        failText.destroy();
                    }
                });

                // End input challenge and rebuild all cards with full details
                this.perkChallenge.inputActive = false;

                // Clear and rebuild all cards
                this.perkCardContainer.removeAll(true);
                updatePerkCardDisplay.call(this);

                console.log("Challenge ended after second failure");
            }
        }
        // Function to update input visibility
        function updateInputVisibility() {
            const isInputVisible = this.perkChallenge.inputActive;

            // Show/hide input elements
            this.inputBox.setVisible(isInputVisible);
            this.inputText.setVisible(isInputVisible);
            this.submitButton.setVisible(isInputVisible);
            this.inputPrompt.setVisible(isInputVisible);

            // If no longer active, show encouraging message
            if (!isInputVisible) {
                // Change subtitle text
                levelUpCards.forEach(element => {
                    if (element.text === 'Type romaji to unlock more choices') {
                        element.setText('Choose a perk to continue');
                    }
                });
            }
        }

        // Modified select card function
        function selectCard(perkType) {
            console.log("Card selected with perk: " + perkType);

            // Acquire the selected perk
            acquirePerk(this, perkType);

            // Update player stats text
            updatePlayerStatsText();

            // Update health bar
            GameUI.updateHealthBar(this);

            // First make all the elements invisible for cleaner transition
            levelUpCards.forEach(element => {
                if (element && element.setVisible) {
                    element.setVisible(false);
                }
            });

            if (this.perkCardContainer) {
                this.perkCardContainer.setVisible(false);
            }

            // Close the cards and resume the game
            closeLevelUpCards.call(this);

            // Flash the hero when completing level up
            this.tweens.add({
                targets: player,
                alpha: 0.2,
                scale: 1.5,
                duration: 200,
                yoyo: true,
                repeat: 1,
                onComplete: function () {
                    player.setScale(1);
                    player.alpha = 1;
                }
            });

            console.log("Level up complete, game resumed");
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function detectKeyboardLayout() {
            // Detect keyboard layout
            try {
                // Check for navigator.keyboard API support (modern browsers)
                if (navigator.keyboard && navigator.keyboard.getLayoutMap) {
                    navigator.keyboard.getLayoutMap()
                        .then(keyboardLayoutMap => {
                            // Check for AZERTY layout by looking at the key for 'KeyQ'
                            const qKey = keyboardLayoutMap.get('KeyQ');
                            if (qKey === 'a' || qKey === 'A') {
                                // AZERTY detected
                                keyboardLayout = 'azerty';
                                updateWASDKeys.call(this);
                            }
                        })
                        .catch(error => {
                            console.log('Error detecting keyboard layout:', error);
                        });
                } else {
                    // Fallback method: check browser language
                    const language = navigator.language || navigator.userLanguage;
                    if (language && (language.startsWith('fr') || language.startsWith('be'))) {
                        // French or Belgian language often uses AZERTY
                        keyboardLayout = 'azerty';
                        updateWASDKeys.call(this);
                    }
                }
            } catch (error) {
                console.log('Error in keyboard layout detection:', error);
            }

            // Update the controls text
            updateControlsText.call(this);
        }

        function updateWASDKeys() {
            // Update keys based on detected layout
            if (keyboardLayout === 'azerty') {
                // AZERTY layout uses ZQSD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.Z,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.Q,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            } else {
                // QWERTY layout uses WASD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.W,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.A,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            }
        }

        function updateControlsText() {
            // Update the controls text based on the detected keyboard layout
            let controlsInfo = 'Controls: Arrow Keys';

            if (keyboardLayout === 'azerty') {
                controlsInfo += ' or ZQSD';
            } else {
                controlsInfo += ' or WASD';
            }

            controlsInfo += ' or Touch/Click to move';

            if (this.controlsText) {
                this.controlsText.setText(controlsInfo);
            }
        }

        // Updated modifyStat function that handles negative values
        window.modifyStat = function (statName, amount) {
            const scene = game.scene.scenes[0];
            if (!scene) return;

            switch (statName) {
                case 'damage':
                    playerDamage += amount;
                    // Ensure damage doesn't go below 1
                    playerDamage = Math.max(1, playerDamage);
                    break;
                case 'speed':
                    playerSpeed += amount;
                    // Ensure speed doesn't go below 1
                    playerSpeed = Math.max(1, playerSpeed);
                    break;
                case 'health':
                    maxPlayerHealth += amount;
                    // Ensure maxHealth doesn't go below 1
                    maxPlayerHealth = Math.max(1, maxPlayerHealth);
                    // If reducing max health, also cap current health
                    if (amount < 0 && playerHealth > maxPlayerHealth) {
                        playerHealth = maxPlayerHealth;
                    } else if (amount > 0) {
                        // If increasing max health, also increase current health
                        playerHealth += amount;
                    }
                    setupHealthRegeneration.call(scene);
                    break;
                case 'luck':
                    playerLuck += amount;
                    // Ensure luck doesn't go below 1
                    playerLuck = Math.max(1, playerLuck);
                    break;
                case 'fireRate':
                    playerFireRate += amount;

                    // Ensure fire rate doesn't go below 1
                    playerFireRate = Math.max(1, playerFireRate);

                    // Update the projectile timer if it exists
                    if (projectileFirer) {
                        const newDelay = shootingDelay / getEffectiveFireRate();
                        projectileFirer.delay = newDelay;

                        // Reset with proper callback scope
                        projectileFirer.reset({
                            delay: newDelay,
                            callback: fireProjectile,
                            callbackScope: game.scene.scenes[0],
                            loop: true
                        });
                    }
                    break;
            }
            // Update UI
            updatePlayerStatsText();
        };

        // Function to fully heal the player
        window.fullHeal = function () {
            playerHealth = maxPlayerHealth;

            // Update the health bar
            GameUI.updateHealthBar(this);

            // Visual effect to show healing
            const scene = game.scene.scenes[0];
            if (scene) {
                // Show healing particles or effect
                const healEffect = scene.add.text(player.x, player.y - 40, '+HEAL', {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#00ff00'
                }).setOrigin(0.5);

                // Animate the effect
                scene.tweens.add({
                    targets: healEffect,
                    y: healEffect.y - 30,
                    alpha: 0,
                    duration: 1000,
                    onComplete: function () {
                        healEffect.destroy();
                    }
                });
            }
        };

        function applyPoisonEffect(enemy, baseDamage) {
            // Store original color to reset after poison
            enemy.originalColor = enemy.style.color || '#ff5555';
            // Set enemy color to indicate poison
            enemy.setColor('#2aad27');
            // Calculate poison tick damage
            const tickDamage = playerDamage * 0.5;

            // Track completed ticks (for timer completion detection)
            let completedTicks = 0;
            const totalTicks = 4;

            // Create and register the poison timer
            const poisonTimer = registerTimer(this.time.addEvent({
                delay: 1000, // 1 second between ticks
                callback: function () {
                    // Skip if enemy is destroyed
                    if (!enemy || !enemy.active) {
                        return;
                    }

                    // Apply poison damage
                    enemy.health -= tickDamage;

                    // Flash enemy to show damage
                    this.tweens.add({
                        targets: enemy,
                        alpha: 0.6,
                        duration: 100,
                        yoyo: true
                    });

                    // Count this tick
                    completedTicks++;

                    // Check if enemy is defeated by poison
                    if (enemy.health <= 0) {
                        defeatedEnemy.call(this, enemy);
                    }
                    // Reset color if this is the last tick and enemy still alive
                    else if (completedTicks === totalTicks && enemy.active) {
                        enemy.setColor(enemy.originalColor);
                    }
                },
                callbackScope: this,
                repeat: totalTicks - 1 // 4 ticks total (first run + 3 repeats)
            }));

            // Register the timer for proper cleanup
            window.registerEffect('timer', poisonTimer);
        }


        function startGame() {
            // Reset game state variables
            gameOver = false;
            gamePaused = false;
            elapsedTime = 0;
            score = 0;
            level = 1;
            // Reset player status components
            resetPlayerStatus();
            CooldownManager.initialize();

            // Reset the current enemy rank
            currentEnemyRank = 1;

            // Initialize enemy tiers with dynamic assignments
            initializeEnemyTiers();

            // Reset quest system variables
            questMode = false;
            questTransitionShown = false;
            questCount = 0;
            currentQuest = null;
            previousQuestType = null;

            // Clean up old timers
            cleanupTimers();

            // Hide pause screen if it was visible
            if (pauseScreen) pauseScreen.setVisible(false);
            if (pauseMessage) pauseMessage.setVisible(false);
            if (resumeButton) resumeButton.setVisible(false);

            // Reset player stats to base values
            playerHealth = basePlayerHealth;
            maxPlayerHealth = baseMaxHealth;
            playerSpeed = basePlayerSpeed;
            playerDamage = basePlayerDamage;
            playerLuck = basePlayerLuck;
            playerFireRate = basePlayerFireRate;

            // Reset XP and level
            heroExp = 0;
            playerLevel = 1;
            heroExpToLevel = xpForNextLevel(playerLevel);

            // Reset player position
            player.x = 600;
            player.y = 400;

            // Reset UI
            player.setFontSize(32);
            GameUI.updateHealthBar(this);
            GameUI.updateExpBar(this);

            // Reset all perk effects
            clearAllPerkEffects();
            acquiredPerks = [];

            // Clear learning feedback
            if (this.learningFeedback) {
                this.learningFeedback.setText('');
            }

            // Restart health regeneration
            setupHealthRegeneration.call(this);

            // Reset difficulty scaling
            gameStartTime = this.time.now;
            currentEnemyHealth = baseEnemyHealth;

            // Clear enemies and projectiles
            enemies.clear(true, true);
            projectiles.clear(true, true);

            // Hide game over elements
            gameOverText.setVisible(false);
            restartButton.setVisible(false);

            // Resume physics
            this.physics.resume();

            // Remove existing timers
            if (enemySpawner) {
                enemySpawner.remove();
                enemySpawner = null;
            }

            if (projectileFirer) {
                projectileFirer.remove();
                projectileFirer = null;
            }

            // Initialize the enemy spawning system
            initializeEnemySpawners();

            // Update projectile firer creation with timer registration
            projectileFirer = registerTimer(this.time.addEvent({
                delay: shootingDelay / getEffectiveFireRate(),
                callback: fireProjectile,
                callbackScope: this,
                loop: true
            }));

            // Reset perks system
            resetAllPerks();
            // If using the new perks system
            if (typeof acquiredPerks !== 'undefined') {
                acquiredPerks = [];
            }

            // Update player stats text
            updatePlayerStatsText();
        }
    </script>
</body>

</html>