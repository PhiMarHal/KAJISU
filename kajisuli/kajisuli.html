<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KAJISU</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>

    <script>
// ======= artillery.js =======
// Projectile Component System for Word Survivors
// This system manages special behaviors for projectiles through a component architecture

// Component system for projectiles
const ProjectileComponentSystem = {
    // Component definitions
    componentTypes: {},

    // Register a new component type
    registerComponent: function (name, componentDef) {
        this.componentTypes[name] = componentDef;
    },

    // Add a component to a projectile
    addComponent: function (projectile, componentName, config = {}) {
        // Initialize components object if it doesn't exist
        projectile.components = projectile.components || {};

        // Skip if component already exists or type not registered
        if (projectile.components[componentName] || !this.componentTypes[componentName]) {
            return projectile;
        }

        // Create component from registered type
        const componentDef = this.componentTypes[componentName];
        const component = { ...componentDef };

        // Apply configuration
        Object.assign(component, config);

        // Store component reference
        projectile.components[componentName] = component;

        // Call initialize function if it exists
        if (component.initialize) {
            component.initialize(projectile);
        }

        return projectile;
    },

    // Process a specific event for all components on a projectile
    processEvent: function (projectile, eventName, ...args) {
        if (!projectile || !projectile.components) return;

        // Call the event handler on each component that has it
        Object.values(projectile.components).forEach(component => {
            if (component[eventName]) {
                // Pass the scene as a context if needed
                component[eventName](projectile, ...[...args, projectile.scene]);
            }
        });
    }
};

// Configuration variables for Crimson Scatter (distance-based damage)
const CRIMSON_SCATTER_CONFIG = {
    maxDamageMultiplier: 1.6,  // Maximum multiplier at close range
    minDamageMultiplier: 0.4,  // Minimum multiplier at maximum distance
    distanceMultiplier: 400
};

// Register component for distance-based damage (Crimson Scatter)
ProjectileComponentSystem.registerComponent('distanceDamage', {
    initialize: function (projectile) {
        // Store our start position and base damage in the component
        this.startX = projectile.x;
        this.startY = projectile.y;
        this.baseDamage = playerDamage;

        // Calculate maxDistance dynamically based on current playerFireRate
        this.maxDistance = (Math.sqrt(playerFireRate / BASE_STATS.AGI)) * CRIMSON_SCATTER_CONFIG.distanceMultiplier;

        // Set initial scale and damage for max effect at close range
        projectile.setScale(CRIMSON_SCATTER_CONFIG.maxDamageMultiplier);
        projectile.damage = this.baseDamage * CRIMSON_SCATTER_CONFIG.maxDamageMultiplier;
    },

    update: function (projectile) {
        // Calculate distance from starting position
        const dx = projectile.x - this.startX;
        const dy = projectile.y - this.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate the damage range (difference between max and min multipliers)
        const damageRange = CRIMSON_SCATTER_CONFIG.maxDamageMultiplier - CRIMSON_SCATTER_CONFIG.minDamageMultiplier;

        // Calculate damage multiplier based on distance
        let damageMultiplier = CRIMSON_SCATTER_CONFIG.maxDamageMultiplier -
            (damageRange * Math.min(distance, this.maxDistance) / this.maxDistance);

        // Update projectile damage
        projectile.damage = this.baseDamage * damageMultiplier;

        // Update projectile scale to reflect damage (visual feedback)
        projectile.setScale(damageMultiplier);
    }
});

// Register component for slow effect
ProjectileComponentSystem.registerComponent('slowEffect', {
    initialize: function (projectile) {
        // Safety check for projectile
        if (!projectile || !projectile.active) return;

        // Visual indicator
        try {
            projectile.setColor('#00ffff');
        } catch (e) {
            console.log("Error setting projectile color in slowEffect:", e);
        }
    },

    onHit: function (projectile, enemy, scene) {
        // Safety check for enemy
        if (!enemy || !enemy.active || enemy.health <= 0) return;

        // Check if enemy is already slowed (to avoid redundant processing)
        if (enemy.isSlowed) return;

        // Mark enemy as slowed
        enemy.isSlowed = true;

        // Store original speed for recovery later
        enemy.originalSpeed = enemy.speed || 50; // Default value if speed is undefined

        // Slow the enemy by half with safety check
        try {
            enemy.speed = Math.max(10, enemy.speed * 0.5);

            // Store original color
            enemy.originalColor = enemy.style && enemy.style.color ? enemy.style.color : '#ff5555';

            // Visual indication of slowed enemy
            if (typeof enemy.setColor === 'function') {
                enemy.setColor('#00ffff');
            }
        } catch (e) {
            console.log("Error in slowEffect onHit:", e);
        }
    }
});

// Register component for explosion area damage effect
ProjectileComponentSystem.registerComponent('explosionEffect', {
    initialize: function (projectile) {
        // Visual indicator for the projectile
        projectile.setColor('#FF9500'); // Orange color for explosive feel

        // Set default properties
        this.damageMultiplier = 1; // 100% of player damage in AOE
        this.radiusMultiplier = 80; // 80 * sqrt luck
        this.falloffMultiplier = 0; // No falloff by default

        // Calculate radius based on player luck at creation time
        this.radius = this.radiusMultiplier * (Math.sqrt(playerLuck / BASE_STATS.LUK));

        // Create unique damage source ID for this explosion
        projectile.explosionSourceId = `explosion_${Date.now()}_${Math.random()}`;
    },

    onHit: function (projectile, enemy, scene) {
        // Prevent multiple triggers for piercing projectiles
        if (projectile.effectTriggered) return;
        projectile.effectTriggered = true;

        // Store the hit position (enemy's location)
        const hitX = enemy.x;
        const hitY = enemy.y;

        // Create explosion visual effect
        this.createExplosionEffect(hitX, hitY, scene);

        // Calculate damage amount
        const explosionDamage = playerDamage * this.damageMultiplier;

        // Get all active enemies
        const allEnemies = EnemySystem.enemiesGroup.getChildren();

        // Track primary target to avoid double-counting
        const primaryTarget = enemy;

        // Apply damage to all enemies in explosion radius
        allEnemies.forEach(targetEnemy => {
            // Skip the primary target as it already received damage from the projectile
            if (targetEnemy === primaryTarget || !targetEnemy.active) return;

            // Calculate distance from explosion center to enemy
            const dx = targetEnemy.x - hitX;
            const dy = targetEnemy.y - hitY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If enemy is within radius, apply damage
            if (distance <= this.radius) {
                // Calculate damage with optional falloff
                let damageAmount = explosionDamage;

                // Apply falloff if enabled
                if (this.falloffMultiplier > 0) {
                    const falloff = 1 - (distance / this.radius) * this.falloffMultiplier;
                    damageAmount = explosionDamage * falloff;
                }

                // Use the existing contact damage system
                applyContactDamage.call(
                    scene,
                    {
                        damageSourceId: projectile.explosionSourceId,
                        damage: damageAmount,
                        active: true
                    },
                    targetEnemy,
                    damageAmount,
                    0 // No cooldown needed for one-time explosion
                );
            }
        });
    },

    createExplosionEffect: function (x, y, scene) {
        return VisualEffects.createExplosion(scene, x, y, this.radius, 0xFF9500, {
            startScale: 0.2
        });
    }

});

function applyPoisonEffect(scene, enemy, baseDamage) {
    if (enemy.health <= 0) return;

    // Store original color to reset after poison
    enemy.originalColor = enemy.style.color || '#ff5555';

    // Set enemy color to indicate poison
    enemy.setColor('#2aad27');

    // Calculate poison tick damage
    const tickDamage = baseDamage * 0.5;

    // Track completed ticks (for timer completion detection)
    let completedTicks = 0;
    const totalTicks = 4;

    // Create unique damage source ID for this poison instance
    const poisonSourceId = `poison_${Date.now()}_${Math.random()}`;

    // Create and register the poison timer
    const poisonTimer = registerTimer(scene.time.addEvent({
        delay: 1000, // 1 second between ticks
        callback: function () {
            // Skip if enemy is destroyed
            if (!enemy || !enemy.active) {
                return;
            }

            // Apply poison damage using the contact damage system
            applyContactDamage.call(scene,
                {
                    damageSourceId: poisonSourceId,
                    damage: tickDamage,
                    active: true
                },
                enemy,
                tickDamage,
                0 // No cooldown needed as timer already provides spacing
            );

            // Count this tick
            completedTicks++;

            // Reset color if this is the last tick and enemy still alive
            if (completedTicks === totalTicks && enemy.active) {
                enemy.setColor(enemy.originalColor);
            }
        },
        callbackScope: scene,
        repeat: totalTicks - 1 // 4 ticks total (first run + 3 repeats)
    }));

    // Register the timer for proper cleanup
    window.registerEffect('timer', poisonTimer);
}

// Make the function globally accessible
window.applyPoisonEffect = applyPoisonEffect;

// Now modify the poisonEffect component to use this function
ProjectileComponentSystem.registerComponent('poisonEffect', {
    initialize: function (projectile) {
        // Visual indicator
        projectile.setColor('#2aad27');
    },

    onHit: function (projectile, enemy, scene) {
        if (enemy.health > 0) {
            // Use the extracted function
            applyPoisonEffect(scene, enemy, projectile.damage);
        }
    }
});

// Register component for split effect
ProjectileComponentSystem.registerComponent('splitEffect', {
    initialize: function (projectile) {
        // Visual indicator
        projectile.setColor('#1E90FF');
    },

    onHit: function (projectile, enemy, scene) {
        if (enemy.health > 0 && !projectile.hasSplit) {

            // Set projectile to split, avoids multiple trigger if projectile is piercing
            projectile.hasSplit = true;

            // Calculate the original trajectory angle
            let angle = 0;

            // If projectile has velocity, calculate angle from it
            if (projectile.body.velocity.x !== 0 || projectile.body.velocity.y !== 0) {
                angle = Math.atan2(projectile.body.velocity.y, projectile.body.velocity.x);
            }

            // Calculate perpendicular angles (90 degrees to each side)
            const angle1 = angle + Math.PI / 2;
            const angle2 = angle - Math.PI / 2;

            // Create the two split projectiles
            for (const splitAngle of [angle1, angle2]) {
                // Create a new projectile at the enemy's position using WeaponSystem
                const splitProjectile = WeaponSystem.createProjectile(scene, {
                    x: enemy.x,
                    y: enemy.y,
                    angle: splitAngle,
                    color: '#1E90FF',
                    symbol: '✧',
                    damage: projectile.damage / 2,
                    speed: 300, // Slightly slower than regular projectiles
                    skipComponents: true // Skip components to prevent infinite splitting
                });

                // Mark that this is a split projectile to prevent infinite splitting
                splitProjectile.hasSplit = true;

                // Add visual effect
                scene.tweens.add({
                    targets: splitProjectile,
                    alpha: { from: 0.7, to: 1 },
                    scale: { from: 0.7, to: 1 },
                    duration: 200
                });
            }
        }
    }
});

// Register component for Titan Stomp effect
ProjectileComponentSystem.registerComponent('stompEffect', {
    initialize: function (projectile) {
        // Create immediate explosion at player position
        this.createStompEffect(projectile, projectile.scene);

        // Mark this projectile as having triggered its effect
        projectile.stompTriggered = true;
    },

    createStompEffect: function (projectile, scene) {
        // Calculate radius based on player luck
        const radius = 96 * Math.sqrt(playerLuck / BASE_STATS.LUK);

        // Get player position
        const x = player.x;
        const y = player.y;

        // Create a unique damage source ID that's available in this scope
        const damageId = `stomp_${Date.now()}_${Math.random()}`;

        // Use our generic explosion effect with brown color (0x8B4513) for stomp
        VisualEffects.createExplosion(scene, x, y, radius, 0x8B4513, {
            startScale: 0.2
        });

        // The rest of the damage logic remains unchanged
        // Get all active enemies
        const allEnemies = EnemySystem.enemiesGroup.getChildren();

        // Apply damage to enemies in range
        allEnemies.forEach(enemy => {
            if (!enemy.active) return;

            // Calculate distance from stomp to enemy
            const dx = enemy.x - x;
            const dy = enemy.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If enemy is within radius, apply damage
            if (distance <= radius) {
                applyContactDamage.call(
                    scene,
                    {
                        damageSourceId: damageId, // Using local variable
                        damage: playerDamage,
                        active: true // Adding active: true property
                    },
                    enemy,
                    playerDamage,
                    0 // No cooldown needed
                );
            }
        });
    }
});

// Create a persistent damage-over-time effect at a specific position
function createPersistentEffect(scene, x, y, config = {}) {
    // Default configuration
    const defaults = {
        symbol: '火', // Default is fire kanji
        color: '#FF4500', // Default is orange-red
        fontSize: '24px', // Default size
        damage: playerDamage / 10, // Default damage
        tickInterval: 200, // Default interval between damage ticks (ms)
        duration: 4000, // Default duration (ms)
        pulsing: true, // Whether to add pulsing animation
        bodyScale: 0.8, // Scale factor for physics body
        startScale: 0.5, // Initial scale for spawn animation
        alpha: 1.0, // Opacity
        sourceEffect: null // For tracking which effect created this
    };

    // Merge with provided config
    const effectConfig = { ...defaults, ...config };

    // Create the effect object
    const effect = scene.add.text(x, y, effectConfig.symbol, {
        fontFamily: 'Arial',
        fontSize: effectConfig.fontSize,
        color: effectConfig.color,
        fontStyle: 'bold'
    }).setOrigin(0.5);

    // Set initial alpha
    effect.setAlpha(effectConfig.alpha);

    // Add physics body
    scene.physics.world.enable(effect);
    effect.body.setSize(effect.width * effectConfig.bodyScale, effect.height * effectConfig.bodyScale);
    effect.body.setAllowGravity(false);
    effect.body.setImmovable(true);

    // Custom properties
    effect.damagePerTick = effectConfig.damage;
    effect.tickInterval = effectConfig.tickInterval;
    effect.damageSourceId = `effect_${Date.now()}_${Math.random()}`;
    effect.sourceEffect = effectConfig.sourceEffect;

    // Register for cleanup
    window.registerEffect('entity', effect);

    // Damage tick timer
    const damageTimer = registerTimer(scene.time.addEvent({
        delay: effectConfig.tickInterval,
        callback: function () {
            if (!effect.active) return;

            // Apply damage to overlapping enemies
            scene.physics.overlap(effect, EnemySystem.enemiesGroup, (effectObj, enemy) => {
                applyContactDamage.call(
                    scene,
                    effectObj,
                    enemy,
                    effectObj.damagePerTick,
                    effectObj.tickInterval - 100
                );
            });
        },
        callbackScope: scene,
        loop: true
    }));

    // Add visual effects
    let pulseTween = null;
    if (effectConfig.pulsing) {
        pulseTween = scene.tweens.add({
            targets: effect,
            scale: { from: 0.9, to: 1.1 },
            duration: 500,
            yoyo: true,
            repeat: -1
        });
    }

    // Fade out over duration
    const fadeTween = scene.tweens.add({
        targets: effect,
        alpha: { from: effectConfig.alpha, to: 0 },
        duration: effectConfig.duration,
        delay: 100,
        onComplete: function () {
            // Cleanup when fade completes
            damageTimer.remove();
            if (pulseTween) pulseTween.stop();
            effect.destroy();
        }
    });

    // Initial spawn animation
    effect.setScale(effectConfig.startScale);
    scene.tweens.add({
        targets: effect,
        scale: 1,
        duration: 200,
        ease: 'Back.out'
    });

    return effect;
}

// Make the function globally accessible
window.createPersistentEffect = createPersistentEffect;

// Update the fireEffect component in artillery.js to use the generalized function
ProjectileComponentSystem.registerComponent('fireEffect', {
    initialize: function (projectile) {
        // Visual indicator for the projectile itself
        projectile.setColor('#FF4500');
        this.fireDamage = playerDamage / 10; // Default fire damage
        this.fireDuration = 4000; // 4s default duration
        this.fireTickInterval = 200; // 0.2 seconds default tick interval
    },

    onHit: function (projectile, enemy, scene) {
        // Don't create fire if enemy is already dead
        if (!enemy || !enemy.active || enemy.health <= 0) return;

        // Prevent multiple triggers for piercing projectiles
        if (projectile.effectTriggered) return;
        projectile.effectTriggered = true;

        // Use the generalized function to create fire
        createPersistentEffect(scene, projectile.x, projectile.y, {
            symbol: '火', // Fire kanji
            color: '#FF4500', // Orange-red color
            fontSize: '24px',
            damage: this.fireDamage,
            tickInterval: this.fireTickInterval,
            duration: this.fireDuration,
            sourceEffect: 'fire'
        });
    }
});

// Create magmaDropEffect component using the generalized function
ProjectileComponentSystem.registerComponent('magmaDropEffect', {
    initialize: function (projectile) {
        // Visual indicator for the projectile itself
        projectile.setColor('#FF6600');
        this.magmaDamage = playerDamage; // Full damage for magma
        this.magmaDuration = playerLuck * 1000; // Duration scales with luck
        this.magmaTickInterval = 1000; // 1 second between ticks
    },

    onHit: function (projectile, enemy, scene) {
        // Don't create magma if enemy is already dead
        if (!enemy || !enemy.active || enemy.health <= 0) return;

        // Prevent multiple triggers for piercing projectiles
        if (projectile.effectTriggered) return;
        projectile.effectTriggered = true;

        // Use the generalized function to create magma
        createPersistentEffect(scene, projectile.x, projectile.y, {
            symbol: '熔', // Magma kanji
            color: '#FF4400', // Orange-red color
            fontSize: '32px', // Larger size
            damage: this.magmaDamage,
            tickInterval: this.magmaTickInterval,
            duration: this.magmaDuration,
            sourceEffect: 'magma'
        });
    }
});

ProjectileComponentSystem.registerComponent('piercingEffect', {
    initialize: function (projectile) {
        // Mark the projectile as piercing
        projectile.piercing = true;
    }
});

ProjectileComponentSystem.registerComponent('healingAuraEffect', {
    initialize: function (projectile) {
        // Visual indicator for healing projectile
        projectile.setColor('#00ff00'); // Light green color

        // Set default properties
        this.healRadius = 128; // 128px healing radius
    },

    onHit: function (projectile, enemy, scene) {
        // Get hit position (enemy's location)
        const hitX = enemy.x;
        const hitY = enemy.y;

        // Create healing aura visual
        const healColor = VisualEffects.convertToColorValue('#00ff00');
        VisualEffects.createExplosion(scene, hitX, hitY, this.healRadius, healColor, {
            startScale: 0.2,
            duration: 1000
        });

        // Check if player is within healing radius
        const dx = player.x - hitX;
        const dy = player.y - hitY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= this.healRadius) {
            // Use LifeSystem's regenerateHealth
            LifeSystem.regenerateHealth.call(scene);
        }
    }
});

// Register component for boomerang effect
ProjectileComponentSystem.registerComponent('boomerangEffect', {
    initialize: function (projectile) {
        // Mark as piercing
        projectile.piercing = true;

        // Store initial position and set up state
        this.startX = projectile.x;
        this.startY = projectile.y;
        this.maxDistance = 400; // Maximum distance before turning back
        this.returning = false; // Track if the boomerang is returning
        this.initialized = false; // Flag to track full initialization

        // Add rotation animation
        projectile.scene.tweens.add({
            targets: projectile,
            angle: 360,
            duration: 1000,
            repeat: -1,
            ease: 'Linear'
        });

        // Set flag for a deferred velocity capture
        projectile.needsOnFireEvent = true;
    },

    // Capture velocity when the projectile is fully created
    onFire: function (projectile, scene, angle) {
        // Now we can safely access the velocity
        if (projectile.body && projectile.body.velocity) {
            const velocity = projectile.body.velocity;

            // Store original velocity for direction
            this.originalVelocity = {
                x: velocity.x,
                y: velocity.y
            };

            // Store original speed
            this.originalSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);

            // Calculate original direction (normalized)
            this.direction = {
                x: velocity.x / this.originalSpeed,
                y: velocity.y / this.originalSpeed
            };

            this.initialized = true;
        }
    },

    update: function (projectile) {
        if (!projectile.active || !projectile.body) return;

        // Skip until fully initialized
        if (!this.initialized) {
            // Try to initialize if possible
            if (projectile.body && projectile.body.velocity) {
                const velocity = projectile.body.velocity;

                this.originalVelocity = {
                    x: velocity.x,
                    y: velocity.y
                };

                // Store original speed
                this.originalSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);

                // Calculate original direction (normalized)
                this.direction = {
                    x: velocity.x / this.originalSpeed,
                    y: velocity.y / this.originalSpeed
                };

                this.initialized = true;
            } else {
                return; // Skip until initialized
            }
        }

        // Check if player is destroyed (game over)
        if (!player || !player.active) {
            projectile.destroy();
            return;
        }

        if (!this.returning) {
            // Calculate distance from starting position
            const dx = projectile.x - this.startX;
            const dy = projectile.y - this.startY;
            const distanceTraveled = Math.sqrt(dx * dx + dy * dy);

            // If we've reached the maximum distance, start returning
            if (distanceTraveled >= this.maxDistance) {
                this.returning = true;

                // Flash effect when turning
                projectile.scene.tweens.add({
                    targets: projectile,
                    alpha: 0.3,
                    scale: 1.5,
                    duration: 100,
                    yoyo: true,
                    repeat: 1
                });
            }
        }

        if (this.returning) {
            // Calculate direction to player
            const dx = player.x - projectile.x;
            const dy = player.y - projectile.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If we're close enough to the player, destroy the projectile
            if (distance < 30) {
                projectile.destroy();
                return;
            }

            // Calculate new velocity toward player
            const returnSpeed = this.originalSpeed * 1.2; // faster, else we can outrun forever and get infinite shots!!
            const newVelocityX = (dx / distance) * returnSpeed;
            const newVelocityY = (dy / distance) * returnSpeed;

            // Update velocity
            projectile.body.setVelocity(newVelocityX, newVelocityY);
        }
    }
});

// ======= backgrounds.js =======
// backgrounds.js - Background visual effects for Word Survivors
// Uses Phaser's built-in graphics and game objects for backgrounds

// Background Animation System using Phaser primitives
const BackgroundAnimationSystem = {
    // Configuration
    config: {
        particleCount: 200,  // Default count, will be adjusted based on screen size
        particleSize: { min: 1, max: 3 },
        particleSpeed: { min: 5, max: 50 },
        baseColor: 0xdddddd, // Light gray for normal mode (hex format for Phaser)
        bossColor: 0xff3838, // Brighter red for boss mode (increased red component)
        normalOpacity: 0.2,  // Opacity for normal mode
        bossOpacity: 0.3,    // Increased opacity for boss mode for better visibility
        bossModeActive: false, // Tracks if boss mode is active
        debugMode: false     // Disable debug for production
    },

    // State references
    scene: null,
    particles: [],
    particleContainer: null,
    testParticle: null,
    isInitialized: false,

    // Initialize the background animation system
    init: function (scene) {
        // Skip if already initialized
        if (this.isInitialized) return;

        console.log("Initializing background system...");

        // Store scene reference
        this.scene = scene;

        // Calculate appropriate particle count based on screen size
        this.calculateParticleCount();

        // Create a container for all particles
        this.createParticleContainer();

        // Generate all particles
        this.createParticles();

        // Create test particle in debug mode only
        if (this.config.debugMode) {
            this.createTestParticle();
        }

        // Mark as initialized
        this.isInitialized = true;

        console.log("Background system initialized with", this.particles.length, "particles");

        return this;
    },

    // Calculate appropriate particle count
    calculateParticleCount: function () {
        if (!this.scene) return;

        // Scale particle count based on screen area (1 particle per 4000 pixels as you set)
        const width = this.scene.sys.game.config.width;
        const height = this.scene.sys.game.config.height;
        const area = width * height;

        this.config.particleCount = Math.floor(area / 4000);

        // Cap the particle count to avoid performance issues
        this.config.particleCount = Math.min(Math.max(this.config.particleCount, 100), 1000);
    },

    // Create a container for all particles
    createParticleContainer: function () {
        // Create a container at a very deep depth to ensure it's behind everything
        this.particleContainer = this.scene.add.container(0, 0);
        this.particleContainer.setDepth(-1000);
    },

    // Create individual particles
    createParticles: function () {
        // Clear existing particles
        this.particles.forEach(p => p.destroy());
        this.particles = [];

        // Create particles
        for (let i = 0; i < this.config.particleCount; i++) {
            this.createOneParticle();
        }
    },

    // Create a single particle
    createOneParticle: function () {
        // Random position
        const x = Math.random() * this.scene.sys.game.config.width;
        const y = Math.random() * this.scene.sys.game.config.height;

        // Random size
        const size = Phaser.Math.Between(
            this.config.particleSize.min,
            this.config.particleSize.max
        );

        // Random speed
        const speed = Phaser.Math.FloatBetween(
            this.config.particleSpeed.min,
            this.config.particleSpeed.max
        );

        // Random direction
        const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const velocityX = Math.cos(angle) * speed;
        const velocityY = Math.sin(angle) * speed;

        // Create particle using a Circle graphics object
        // Use the current appropriate opacity based on boss mode
        const opacity = this.config.bossModeActive ?
            this.config.bossOpacity : this.config.normalOpacity;

        // Use the current appropriate color based on boss mode
        const color = this.config.bossModeActive ?
            this.config.bossColor : this.config.baseColor;

        const particle = this.scene.add.circle(x, y, size, color, opacity);

        // Store velocity
        particle.velocityX = velocityX;
        particle.velocityY = velocityY;

        // Add to container
        this.particleContainer.add(particle);

        // Store in our array
        this.particles.push(particle);

        return particle;
    },

    // Create a visible test particle (debug only)
    createTestParticle: function () {
        // Create a large, obvious test particle in the center of the screen
        this.testParticle = this.scene.add.circle(
            this.scene.sys.game.config.width / 2,
            this.scene.sys.game.config.height / 2,
            20, // Large radius
            0xff0000, // Red color
            1 // Full opacity
        );

        // Add it to our container
        this.particleContainer.add(this.testParticle);

        console.log("Created test particle at center of screen");
    },

    // Update particles - to be called in the scene's update method
    update: function (time, delta) {
        if (!this.isInitialized || !this.particleContainer) return;

        // Convert delta to seconds for smoother movement
        const dt = delta / 1000;

        // Update each particle
        this.particles.forEach(particle => {
            // Move particle
            particle.x += particle.velocityX * dt;
            particle.y += particle.velocityY * dt;

            // Wrap around screen
            if (particle.x < -particle.radius) {
                particle.x = this.scene.sys.game.config.width + particle.radius;
            } else if (particle.x > this.scene.sys.game.config.width + particle.radius) {
                particle.x = -particle.radius;
            }

            if (particle.y < -particle.radius) {
                particle.y = this.scene.sys.game.config.height + particle.radius;
            } else if (particle.y > this.scene.sys.game.config.height + particle.radius) {
                particle.y = -particle.radius;
            }
        });

        // Animate test particle if in debug mode
        if (this.config.debugMode && this.testParticle) {
            this.testParticle.fillColor = (time % 2000 < 1000) ? 0xff0000 : 0x00ff00;
        }
    },

    // Set boss mode (changing the color and opacity)
    setBossMode: function (active) {
        // Don't do anything if already in the correct mode
        if (this.config.bossModeActive === active) return;

        this.config.bossModeActive = active;

        // Update all particles with new color and opacity
        const color = active ? this.config.bossColor : this.config.baseColor;
        const opacity = active ? this.config.bossOpacity : this.config.normalOpacity;

        this.particles.forEach(particle => {
            particle.fillColor = color;
            particle.fillAlpha = opacity;
        });

        console.log("Background animation boss mode:", active ? "ACTIVE" : "INACTIVE");
    },

    // Set overall opacity of the effect
    setOpacity: function (opacity, isBossMode = false) {
        // Store the new opacity in the appropriate config property
        if (isBossMode) {
            this.config.bossOpacity = Math.max(0, Math.min(1, opacity));
        } else {
            this.config.normalOpacity = Math.max(0, Math.min(1, opacity));
        }

        // Only update particles if we're in the corresponding mode
        if (this.config.bossModeActive === isBossMode) {
            // Update all particles with new opacity
            this.particles.forEach(particle => {
                particle.fillAlpha = opacity;
            });
        }

        console.log(`Background ${isBossMode ? 'boss' : 'normal'} opacity set to:`, opacity);
    },

    // Clean up resources
    cleanup: function () {
        console.log("Cleaning up background system");

        // Destroy all particles
        this.particles.forEach(particle => particle.destroy());
        this.particles = [];

        // Destroy test particle
        if (this.testParticle) {
            this.testParticle.destroy();
            this.testParticle = null;
        }

        // Destroy container
        if (this.particleContainer) {
            this.particleContainer.destroy();
            this.particleContainer = null;
        }

        // Clear references
        this.scene = null;
        this.isInitialized = false;
    }
};

// Export the background animation system
window.BackgroundAnimationSystem = BackgroundAnimationSystem;

// ======= ballistics.js =======
// Projectile Perk Registry System for Word Survivors
// This system maps perks to projectile components and handles their automatic application

// Projectile perk registry - maps perks to their projectile effects
const ProjectilePerkRegistry = {
    // Store perk-to-component mappings
    perkEffects: {},

    // Register a perk effect that can apply components to projectiles
    registerPerkEffect: function (perkId, options) {
        this.perkEffects[perkId] = {
            componentName: options.componentName ?? null,
            chanceMultiplier: options.chanceMultiplier ?? 1.0,
            applyChance: options.applyChance ?? true,
            configGenerator: options.configGenerator ?? null
        };
    },

    // Apply all registered perk effects to a new projectile
    applyPerkEffects: function (projectile, scene) {
        // Go through all registered perk effects
        Object.entries(this.perkEffects).forEach(([perkId, effectInfo]) => {
            // Check if player has this perk
            if (hasPerk(perkId)) {
                let shouldApply = true;

                // Check if we should apply a chance calculation
                if (effectInfo.applyChance) {
                    // Calculate chance based on luck and any multiplier
                    const chance = calculateProcChance(playerLuck, baseProcChance) * effectInfo.chanceMultiplier;
                    shouldApply = Math.random() < chance;
                }

                // Apply the component if conditions are met
                if (shouldApply && effectInfo.componentName) {
                    // Generate config if needed
                    let config = {};
                    if (effectInfo.configGenerator) {
                        config = effectInfo.configGenerator(scene);
                    }

                    // Add the component to the projectile
                    ProjectileComponentSystem.addComponent(projectile, effectInfo.componentName, config);
                }
            }
        });

        return projectile;
    }
};

// Register built-in perk effects
ProjectilePerkRegistry.registerPerkEffect('CRIMSON_SCATTER', {
    componentName: 'distanceDamage',
    applyChance: false, // Always apply, not chance-based
    configGenerator: (scene) => ({
        startX: player.x, // Use the global player variable
        startY: player.y, // Use the global player variable
        baseDamage: playerDamage
    })
});

ProjectilePerkRegistry.registerPerkEffect('AZURE_FROST', {
    componentName: 'slowEffect',
    applyChance: true // Apply based on chance
});

ProjectilePerkRegistry.registerPerkEffect('GREEN_VENOM', {
    componentName: 'poisonEffect',
    applyChance: true
});

ProjectilePerkRegistry.registerPerkEffect('AZURE_FORK', {
    componentName: 'splitEffect',
    applyChance: true
});

ProjectilePerkRegistry.registerPerkEffect('SCARLET_EMBER', {
    componentName: 'fireEffect',
    applyChance: true
});

ProjectilePerkRegistry.registerPerkEffect('PURPLE_OWL', {
    componentName: 'multiShot',
    applyChance: true, // Use standard chance calculation
    configGenerator: function (scene) {
        return {
            maxExtraShots: 1 // Just one extra shot
        };
    }
});

// Register the Titan Stomp perk effect
ProjectilePerkRegistry.registerPerkEffect('TITAN_STOMP', {
    componentName: 'stompEffect',
    applyChance: true, // Apply based on chance calculation
    configGenerator: function (scene) {
        return {
            // We could add custom config here if needed
        };
    }
});

// Register the explosion area effect perk
ProjectilePerkRegistry.registerPerkEffect('AMBER_NOVA', {
    componentName: 'explosionEffect',
    applyChance: true, // Apply based on chance
    configGenerator: function (scene) {
        return {
            // We could add custom config here if needed
        };
    }
});

ProjectilePerkRegistry.registerPerkEffect('PIERCING_SHOTS', {
    componentName: 'piercingEffect',
    applyChance: true,  // Use standard chance calculation based on luck
});


// Register the Yellow Boomerang perk effect
ProjectilePerkRegistry.registerPerkEffect('YELLOW_BOOMERANG', {
    componentName: 'boomerangEffect',
    chanceMultiplier: 0.5,
    applyChance: true, // Apply based on chance
});

// ======= bestiary.js =======
// Default values for different ranks of enemies
const ENEMY_RANK_DEFAULTS = {
    // Rank 1 (basic enemies)
    1: {
        healthMultiplier: 1.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 32,
        expValue: 1
    },
    // Rank 2 (stronger enemies)
    2: {
        healthMultiplier: 4.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 48,
        expValue: 4
    },
    // Rank 3 (even stronger enemies)
    3: {
        healthMultiplier: 16.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 64,
        expValue: 16
    },
    // Rank 4 (powerful enemies)
    4: {
        healthMultiplier: 64.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 80,
        expValue: 64
    },
    // Rank 5 (very powerful enemies)
    5: {
        healthMultiplier: 256.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 96,
        expValue: 256
    },
    // Rank 6 (elite enemies)
    6: {
        healthMultiplier: 1024.0,
        speedMin: 25,
        speedMax: 100,
        damage: 1,
        color: '#ff5555',
        size: 128,
        expValue: 1024
    }
    // Future ranks can be added here following the pattern
};

// Rank names using kanji characters
const ENEMY_RANK_NAMES = {
    1: "壱", // Formal number 1 (ichi)
    2: "弐", // Formal number 2 (ni)
    3: "参", // Formal number 3 (san)
    4: "肆", // Formal number 4 (shi)
    5: "伍", // Formal number 5 (go)
    6: "陸"  // Formal number 6 (roku)
};

// Boss configuration
const BOSS_CONFIG = {
    max_rank: 4,                // Maximum rank at which the boss appears
    health_multiplier: 10.0,    // Boss health multiplier compared to normal enemies
    speed: 100                  // Fixed boss speed
};

// The enemy definitions - using kanji characters with readings and translations
// Note: Removed rank field as it will be assigned dynamically
const ENEMY_TYPES = {
    '鬼': {
        kana: 'おに',
        romaji: 'oni',
        english: 'Demon'
    },
    '幽': {
        kana: 'ゆう',
        romaji: 'yuu',
        english: 'Ghost'
    },
    '龍': {
        kana: 'りゅう',
        romaji: 'ryuu',
        english: 'Dragon'
    },
    '蛇': {
        kana: 'へび',
        romaji: 'hebi',
        english: 'Snake'
    },
    '魔': {
        kana: 'ま',
        romaji: 'ma',
        english: 'Devil'
    },
    '死': {
        kana: 'し',
        romaji: 'shi',
        english: 'Death'
    },
    '獣': {
        kana: 'けもの',
        romaji: 'kemono',
        english: 'Beast'
    },
    '骨': {
        kana: 'ほね',
        romaji: 'hone',
        english: 'Bone'
    },
    '影': {
        kana: 'かげ',
        romaji: 'kage',
        english: 'Shadow'
    },
    '鮫': {
        kana: 'さめ',
        romaji: 'same',
        english: 'Shark'
    },
    '妖': {
        kana: 'あやかし',
        romaji: 'ayakashi',
        english: 'Phantom'
    },
    '冥': {
        kana: 'めい',
        romaji: 'mei',
        english: 'Specter'
    },
    '霊': {
        kana: 'れい',
        romaji: 'rei',
        english: 'Spirit'
    },
    '怨': {
        kana: 'おん',
        romaji: 'on',
        english: 'Grudge'
    },
    '邪': {
        kana: 'じゃ',
        romaji: 'ja',
        english: 'Evil'
    },
    '呪': {
        kana: 'のろい',
        romaji: 'noroi',
        english: 'Curse'
    },
    '魂': {
        kana: 'たましい',
        romaji: 'tamashii',
        english: 'Soul'
    },
    '闇': {
        kana: 'やみ',
        romaji: 'yami',
        english: 'Darkness'
    },
    '妄': {
        kana: 'もう',
        romaji: 'mou',
        english: 'Delusion'
    },
    '憑': {
        kana: 'つき',
        romaji: 'tsuki',
        english: 'Possession'
    },
    '煉': {
        kana: 'れん',
        romaji: 'ren',
        english: 'Purgatory'
    },
    '殺': {
        kana: 'さつ',
        romaji: 'satsu',
        english: 'Slayer'
    },
    '魘': {
        kana: 'えん',
        romaji: 'en',
        english: 'Nightmare'
    },
    '禍': {
        kana: 'わざわい',
        romaji: 'wazawai',
        english: 'Calamity'
    },
    '鬣': {
        kana: 'たてがみ',
        romaji: 'tategami',
        english: 'Mane'
    },
    '悪': {
        kana: 'あく',
        romaji: 'aku',
        english: 'Malice'
    },
    '屍': {
        kana: 'しかばね',
        romaji: 'shikabane',
        english: 'Corpse'
    },
    '凶': {
        kana: 'きょう',
        romaji: 'kyou',
        english: 'Doom'
    },
    '鵺': {
        kana: 'ぬえ',
        romaji: 'nue',
        english: 'Chimera'
    },
    '餓': {
        kana: 'うえ',
        romaji: 'ue',
        english: 'Hunger'
    },
    '狂': {
        kana: 'きょう',
        romaji: 'kyou',
        english: 'Madness'
    },
    '兇': {
        kana: 'きょう',
        romaji: 'kyou',
        english: 'Savage'
    },
    '鬧': {
        kana: 'かまびすし',
        romaji: 'kamabisushi',
        english: 'Uproar'
    },
    // Additional enemies
    '災': {
        kana: 'わざわい',
        romaji: 'wazawai',
        english: 'Disaster'
    },
    '亡': {
        kana: 'ほろ',
        romaji: 'horo',
        english: 'Perish'
    },
    '滅': {
        kana: 'めつ',
        romaji: 'metsu',
        english: 'Destroy'
    },
    '崩': {
        kana: 'くず',
        romaji: 'kuzu',
        english: 'Collapse'
    },
    '破': {
        kana: 'やぶ',
        romaji: 'yabu',
        english: 'Break'
    },
    '裂': {
        kana: 'さ',
        romaji: 'sa',
        english: 'Tear'
    },
    '灰': {
        kana: 'はい',
        romaji: 'hai',
        english: 'Ash'
    },
    '焦': {
        kana: 'こ',
        romaji: 'ko',
        english: 'Scorch'
    },
    '血': {
        kana: 'ち',
        romaji: 'chi',
        english: 'Blood'
    },
    '斬': {
        kana: 'き',
        romaji: 'ki',
        english: 'Slash'
    },
    '穿': {
        kana: 'うが',
        romaji: 'uga',
        english: 'Pierce'
    },
    '刺': {
        kana: 'さ',
        romaji: 'sa',
        english: 'Stab'
    },
    '砕': {
        kana: 'くだ',
        romaji: 'kuda',
        english: 'Crush'
    },
    '毒': {
        kana: 'どく',
        romaji: 'doku',
        english: 'Poison'
    },
    '疫': {
        kana: 'えき',
        romaji: 'eki',
        english: 'Plague'
    },
    '病': {
        kana: 'やまい',
        romaji: 'yamai',
        english: 'Disease'
    },
    '腐': {
        kana: 'くさ',
        romaji: 'kusa',
        english: 'Rot'
    },
    '蝕': {
        kana: 'しょく',
        romaji: 'shoku',
        english: 'Erode'
    },
    '墓': {
        kana: 'はか',
        romaji: 'haka',
        english: 'Tomb'
    },
    '棺': {
        kana: 'かん',
        romaji: 'kan',
        english: 'Coffin'
    },
    '葬': {
        kana: 'ほうむ',
        romaji: 'houmu',
        english: 'Bury'
    },
    '鎖': {
        kana: 'くさり',
        romaji: 'kusari',
        english: 'Chain'
    },
    '縛': {
        kana: 'しば',
        romaji: 'shiba',
        english: 'Bind'
    },
    '罠': {
        kana: 'わな',
        romaji: 'wana',
        english: 'Trap'
    },
    '恐': {
        kana: 'おそ',
        romaji: 'oso',
        english: 'Fear'
    },
    '驚': {
        kana: 'おどろ',
        romaji: 'odoro',
        english: 'Surprise'
    },
    '脅': {
        kana: 'おど',
        romaji: 'odo',
        english: 'Threaten'
    },
    '絶': {
        kana: 'た',
        romaji: 'ta',
        english: 'Sever'
    },
    '終': {
        kana: 'お',
        romaji: 'o',
        english: 'End'
    },
    '喪': {
        kana: 'も',
        romaji: 'mo',
        english: 'Mourn'
    },
    '虚': {
        kana: 'きょ',
        romaji: 'kyo',
        english: 'Void'
    },
    '空': {
        kana: 'から',
        romaji: 'kara',
        english: 'Empty'
    },
    '虫': {
        kana: 'むし',
        romaji: 'mushi',
        english: 'Insect'
    },
    '蜘': {
        kana: 'くも',
        romaji: 'kumo',
        english: 'Spider'
    },
    '蛛': {
        kana: 'くも',
        romaji: 'kumo',
        english: 'Spider'
    },
    '蟲': {
        kana: 'むし',
        romaji: 'mushi',
        english: 'Bug'
    },
    '蠍': {
        kana: 'さそり',
        romaji: 'sasori',
        english: 'Scorpion'
    },
    '蜈': {
        kana: 'むかで',
        romaji: 'mukade',
        english: 'Centipede'
    },
    '蚣': {
        kana: 'むかで',
        romaji: 'mukade',
        english: 'Centipede'
    },
    '蝎': {
        kana: 'さそり',
        romaji: 'sasori',
        english: 'Scorpion'
    }
};


// Dynamic tier assignments - will store enemy types for each rank
let ENEMY_TIER_ASSIGNMENTS = {
    1: [], // Will hold enemy types assigned to rank 1
    2: [], // Will hold enemy types assigned to rank 2
    3: [], // Will hold enemy types assigned to rank 3
    4: [], // Will hold enemy types assigned to rank 4
    5: [], // Will hold enemy types assigned to rank 5
    6: []  // Will hold enemy types assigned to rank 6
};

// Initialize enemy tier assignments
function initializeEnemyTiers(tierCounts = { 1: 8, 2: 4, 3: 2, 4: 2, 5: 2, 6: 2 }) {
    // Reset assignments
    ENEMY_TIER_ASSIGNMENTS = {
        1: [], 2: [], 3: [], 4: [], 5: [], 6: []
    };

    // Get all enemy types
    const allEnemyTypes = Object.keys(ENEMY_TYPES);

    // Shuffle array to randomize assignments
    const shuffledEnemies = [...allEnemyTypes];
    for (let i = shuffledEnemies.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledEnemies[i], shuffledEnemies[j]] = [shuffledEnemies[j], shuffledEnemies[i]];
    }

    // Assign enemies to tiers based on specified counts
    let usedCount = 0;

    // Start assigning from tier 1 to 6
    for (let tier = 1; tier <= 6; tier++) {
        // Get the count for this tier (or default to 0)
        const tierCount = tierCounts[tier] ?? 0;

        // Check if we have enough enemies left
        if (usedCount + tierCount <= shuffledEnemies.length) {
            // Assign enemies to this tier
            ENEMY_TIER_ASSIGNMENTS[tier] = shuffledEnemies.slice(usedCount, usedCount + tierCount);
            usedCount += tierCount;
        } else {
            // Not enough enemies left, assign remaining ones
            ENEMY_TIER_ASSIGNMENTS[tier] = shuffledEnemies.slice(usedCount);
            console.log(`Warning: Not enough enemy types for tier ${tier}. Requested ${tierCount}, assigned ${shuffledEnemies.length - usedCount}`);
            break;
        }
    }

    // Log the assignments for debugging
    console.log("Enemy tier assignments initialized:",
        Object.entries(ENEMY_TIER_ASSIGNMENTS).map(([tier, enemies]) =>
            `Tier ${tier}: ${enemies.length} enemies`).join(', '));

    return ENEMY_TIER_ASSIGNMENTS;
}

// Helper function to get complete enemy data with defaults applied
function getEnemyData(enemyType) {
    // If enemy type doesn't exist, use a random one
    if (!ENEMY_TYPES[enemyType]) {
        const availableTypes = Object.keys(ENEMY_TYPES);
        enemyType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
    }

    // Find which rank this enemy is assigned to
    let enemyRank = 1; // Default to rank 1 if not found
    for (let rank = 1; rank <= 6; rank++) {
        if (ENEMY_TIER_ASSIGNMENTS[rank].includes(enemyType)) {
            enemyRank = rank;
            break;
        }
    }

    // Get the defaults for this rank
    const rankDefaults = ENEMY_RANK_DEFAULTS[enemyRank] || ENEMY_RANK_DEFAULTS[1];

    // Merge rank defaults with specific enemy data
    return {
        ...rankDefaults,
        ...ENEMY_TYPES[enemyType],
        type: enemyType,
        rank: enemyRank // Include the assigned rank
    };
}

// Get all enemy types as an array
function getAllEnemyTypes() {
    return Object.keys(ENEMY_TYPES);
}

// Get enemy types by rank (from dynamic assignments)
function getEnemyTypesByRank(rank) {
    return ENEMY_TIER_ASSIGNMENTS[rank] || [];
}

// Choose a random enemy type
function getRandomEnemyType() {
    const types = getAllEnemyTypes();
    return types[Math.floor(Math.random() * types.length)];
}

// Choose a random enemy type of a specific rank
function getRandomEnemyTypeByRank(rank) {
    const types = getEnemyTypesByRank(rank);
    if (types.length === 0) return getRandomEnemyType(); // Fallback if no enemies of this rank
    return types[Math.floor(Math.random() * types.length)];
}

// ======= cards.js =======
// cards.js - Enhanced Card Management System for Word Survivors

// Colors for various UI elements
const CARD_COLORS = {
    DEFAULT_BG: 0x444444,
    HOVER_BG: 0x666666,
    STROKE: 0xeeeeee,
    STROKE_HOVER: 0xffffff
};

/**
 * Helper function to get the active scene
 * @returns {Phaser.Scene} The active Phaser scene
 */
function getActiveScene() {
    // Access the first active scene from the global game object
    if (window.game && window.game.scene && window.game.scene.scenes && window.game.scene.scenes.length > 0) {
        return window.game.scene.scenes[0];
    }

    // If that fails, try without window prefix
    if (typeof game !== 'undefined' && game && game.scene && game.scene.scenes && game.scene.scenes.length > 0) {
        return game.scene.scenes[0];
    }

    console.error("Unable to access active game scene");
    return null;
}

/**
 * Helper function to safely access PERKS
 * @returns {Object} The PERKS object
 */
function getPerks() {
    // Try accessing PERKS from window
    if (window.PERKS) {
        return window.PERKS;
    }

    // Try accessing without window prefix
    if (typeof PERKS !== 'undefined') {
        return PERKS;
    }

    console.error("PERKS object not found in global scope");
    return {};
}

/**
 * Creates a perk card with consistent styling and positioning
 * 
 * @param {Object} perk - Perk data object containing kanji, kana, romaji, etc.
 * @param {number} x - X position for card center
 * @param {number} y - Y position for card center
 * @param {Object} options - Configuration options for card appearance and behavior
 * @returns {Array} - Array of created elements, with first element being the background
 */
function createPerkCardElements(perk, x, y, options = {}) {
    // Get the active scene directly
    const scene = getActiveScene();

    // Safety check for scene
    if (!scene || !scene.add) {
        console.error("Cannot access active scene in createPerkCardElements");
        return [];
    }

    // Safety check for perk
    if (!perk) {
        console.error("Invalid perk provided to createPerkCardElements");
        return [];
    }

    const defaults = {
        container: null,
        showBackground: true,
        showKana: true,
        showRomaji: true,
        showEnglish: true,
        showDescription: true,
        backgroundColor: CARD_COLORS.DEFAULT_BG,
        width: 200,
        height: 300,
        strokeWidth: 2,
        strokeColor: CARD_COLORS.STROKE,
        makeInteractive: false,
        perkCallback: null
    };

    // Merge options with defaults
    const settings = { ...defaults, ...options };

    // Elements array to return
    const elements = [];

    // Create card background if requested
    if (settings.showBackground) {
        const cardBg = scene.add.rectangle(x, y, settings.width, settings.height, settings.backgroundColor, 1)
            .setStrokeStyle(settings.strokeWidth, settings.strokeColor);

        // Add to container if provided
        if (settings.container && settings.container.add) {
            settings.container.add(cardBg);
        }

        // Make interactive if requested
        if (settings.makeInteractive && perk) {
            cardBg.setInteractive({ useHandCursor: true });
            cardBg.perkId = perk.id;

            // Add hover effects
            cardBg.on('pointerover', function () {
                this.fillColor = perk.hoverColor ?? CARD_COLORS.HOVER_BG;
                this.setStrokeStyle(4, CARD_COLORS.STROKE_HOVER);
            });

            cardBg.on('pointerout', function () {
                this.fillColor = settings.backgroundColor;
                this.setStrokeStyle(settings.strokeWidth, settings.strokeColor);
            });

            // Add click handler if provided
            if (settings.perkCallback && typeof settings.perkCallback === 'function') {
                cardBg.on('pointerdown', function () {
                    settings.perkCallback(perk.id);
                });
            }
        }

        elements.push(cardBg);
    }

    // Fixed positions relative to card center
    const positions = {
        kanji: y - 60,      // Kanji position
        kana: y - 15,       // Kana position 
        romaji: y + 10,     // Romaji position
        english: y + 40,    // English position
        description: y + 85 // Description position - 145 from kanji
    };

    // Always show kanji
    if (perk) {
        const kanjiText = scene.add.text(
            x, positions.kanji,
            perk.kanji,
            {
                fontFamily: 'Arial',
                fontSize: '36px',
                color: perk.color || '#ffffff',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }
        ).setOrigin(0.5);

        if (settings.container && settings.container.add) {
            settings.container.add(kanjiText);
        }

        elements.push(kanjiText);

        // Show kana if requested
        if (settings.showKana) {
            const kanaText = scene.add.text(
                x, positions.kana,
                perk.kana || '',
                { fontFamily: 'Arial', fontSize: '18px', color: '#ffffff' }
            ).setOrigin(0.5);

            if (settings.container && settings.container.add) {
                settings.container.add(kanaText);
            }

            elements.push(kanaText);
        }

        // Show romaji if requested
        if (settings.showRomaji) {
            const romajiText = scene.add.text(
                x, positions.romaji,
                perk.romaji || '',
                { fontFamily: 'Arial', fontSize: '16px', color: '#dddddd', fontStyle: 'italic' }
            ).setOrigin(0.5);

            if (settings.container && settings.container.add) {
                settings.container.add(romajiText);
            }

            elements.push(romajiText);
        }

        // Show english if requested
        if (settings.showEnglish) {
            const englishText = scene.add.text(
                x, positions.english,
                perk.english || '',
                {
                    fontFamily: 'Arial',
                    fontSize: '20px',
                    color: perk.color || '#ffffff',
                    fontStyle: 'bold'
                }
            ).setOrigin(0.5);

            if (settings.container && settings.container.add) {
                settings.container.add(englishText);
            }

            elements.push(englishText);
        }

        // Show description if requested - always in the same position
        if (settings.showDescription) {
            const descText = scene.add.text(
                x, positions.description,
                perk.description || '',
                {
                    fontFamily: 'Arial',
                    fontSize: '16px',
                    color: '#ffffff',
                    align: 'center',
                    wordWrap: { width: settings.width - 20 }
                }
            ).setOrigin(0.5);

            if (settings.container && settings.container.add) {
                settings.container.add(descText);
            }

            elements.push(descText);
        }
    }

    return elements;
}

/**
 * Helper function to create a perk card using the generic card element creator
 * 
 * @param {string} perkId - ID of the perk to create a card for
 * @param {number} x - X position of the card center
 * @param {number} y - Y position of the card center
 * @param {Object} options - Additional configuration options
 * @returns {Array} Array of card elements
 */
function createPerkCard(perkId, x, y, options = {}) {
    const PERKS = getPerks();

    if (Object.keys(PERKS).length === 0) {
        console.error("PERKS not defined when calling createPerkCard");

        // Create a fallback dummy perk to avoid breaking UI
        const dummyPerk = {
            id: perkId || "undefined",
            kanji: "?",
            kana: "unknown",
            romaji: "unknown",
            english: "Unknown Perk",
            description: "Perk data could not be loaded",
            color: "#ff0000"
        };

        return createPerkCardElements(dummyPerk, x, y, options);
    }

    const perk = PERKS[perkId];
    if (!perk) {
        console.error("Invalid perk ID provided to createPerkCard:", perkId);

        // Create a fallback dummy perk specific to the ID
        const dummyPerk = {
            id: perkId,
            kanji: perkId.substring(0, 1),
            kana: perkId,
            romaji: perkId,
            english: `Unknown: ${perkId}`,
            description: "This perk data could not be found",
            color: "#ff0000"
        };

        return createPerkCardElements(dummyPerk, x, y, options);
    }

    return createPerkCardElements(perk, x, y, {
        ...options,
        showKana: true,
        showRomaji: true,
        showEnglish: true,
        showDescription: true
    });
}

/**
 * Creates and shuffles an array of perk cards for level up
 * @param {number} count - Number of cards to generate
 * @param {Array} excludeIds - Array of perk IDs to exclude
 * @returns {Array} Array of shuffled perk objects
 */
function generateRandomPerkCards(count, excludeIds = []) {
    // Use the existing PerkSystem if available
    if (window.PerkSystem && window.PerkSystem.getRandomPerks) {
        return window.PerkSystem.getRandomPerks(count, excludeIds);
    }

    // Fallback method if PerkSystem is not available
    const PERKS = getPerks();
    const availablePerks = Object.keys(PERKS)
        .filter(key => !excludeIds.includes(key))
        .map(key => ({
            id: key,
            ...PERKS[key]
        }));

    // Shuffle the array
    for (let i = availablePerks.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availablePerks[i], availablePerks[j]] = [availablePerks[j], availablePerks[i]];
    }

    return availablePerks.slice(0, count);
}

// Add this to cards.js

/**
 * Shows a mobile-friendly level up screen with card navigation
 * @param {Phaser.Scene} scene - The active game scene
 */
function showMobileLevelUpScreen(scene) {
    // Pause the game
    PauseSystem.pauseGame();

    // Number of perk options to offer
    const numPerkOptions = 4;

    // Get random perks (excluding already acquired ones)
    const availablePerks = PerkSystem.getRandomPerks(numPerkOptions, acquiredPerks);

    // Create a container with high depth for all level-up elements
    const levelUpContainer = scene.add.container(0, 0);
    levelUpContainer.setDepth(1000);

    // Create semi-transparent background
    const centerX = game.config.width / 2;
    const centerY = game.config.height / 2;
    const levelUpBackground = scene.add.rectangle(
        centerX,
        centerY,
        game.config.width,
        game.config.height,
        0x000000,
        0.7
    );

    // Create level up title with improved styling
    const levelUpTitle = scene.add.text(
        centerX,
        game.config.height * 0.15,
        'LEVEL UP!',
        {
            fontFamily: 'Arial',
            fontSize: '32px',
            color: '#ffffff',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 4
        }
    ).setOrigin(0.5);

    // Create subtitle text
    const subtitle = scene.add.text(
        centerX,
        game.config.height * 0.22,
        'Choose a perk to continue',
        {
            fontFamily: 'Arial',
            fontSize: '18px',
            color: '#ffffff'
        }
    ).setOrigin(0.5);

    // Add background and text to container
    levelUpContainer.add(levelUpBackground);
    levelUpContainer.add(levelUpTitle);
    levelUpContainer.add(subtitle);

    // Show KAJISULI stats if in KAJISULI mode
    if (KAJISULI_MODE) {
        // Use the enhanced showStatsDisplay from pause.js with custom options
        PauseSystem.showStatsDisplay(scene, {
            container: levelUpContainer,           // Add to our level up container instead
            positionY: game.config.height * 0.28, // Position below subtitle
            storeInElements: false,                // Don't store in pause system's elements
            clearContainer: false,                 // Don't clear our level up container
            setVisible: false                      // We'll handle visibility via the container
        });
    }

    // Current perk index being displayed
    let currentPerkIndex = 0;

    // Create perk card at the center
    let currentCardElements = [];

    // Function to create or update the displayed card
    function updateDisplayedCard() {
        // Remove previous card elements if they exist
        currentCardElements.forEach(element => {
            if (element && element.destroy) {
                element.destroy();
            }
        });
        currentCardElements = [];

        // Create new card with the current perk
        const currentPerk = availablePerks[currentPerkIndex];
        if (currentPerk) {
            currentCardElements = CardSystem.createPerkCardElements(
                currentPerk,
                centerX,
                centerY,
                {
                    showKana: true,
                    showRomaji: true,
                    showEnglish: true,
                    showDescription: true,
                    width: Math.min(200, game.config.width * 0.6),
                    height: 300
                }
            );

            // Add all card elements to the container
            currentCardElements.forEach(element => {
                levelUpContainer.add(element);
            });

            // Make the background clickable to select this perk
            const cardBackground = currentCardElements[0];
            cardBackground.setInteractive({ useHandCursor: true });
            cardBackground.on('pointerdown', () => {
                selectPerk(currentPerk.id);
            });

            // Add a highlight effect to emphasize it's selectable
            scene.tweens.add({
                targets: cardBackground,
                strokeStyle: { value: 0xffff00 },
                easeParams: [1, 0.5],
                yoyo: true,
                duration: 700,
                repeat: -1
            });
        }
    }

    // Create navigation arrows
    const arrowConfig = {
        fontSize: '40px',
        color: '#ffffff',
        stroke: '#000000',
        strokeThickness: 4
    };

    // Left arrow - only shown if not on first card
    const leftArrow = scene.add.text(
        centerX - (game.config.width * 0.25),
        centerY,
        '◀',
        arrowConfig
    ).setOrigin(0.5);
    leftArrow.setInteractive({ useHandCursor: true });
    leftArrow.on('pointerdown', () => {
        currentPerkIndex = (currentPerkIndex - 1 + numPerkOptions) % numPerkOptions;
        updateDisplayedCard();
        updateArrowVisibility();
    });

    // Right arrow - only shown if not on last card
    const rightArrow = scene.add.text(
        centerX + (game.config.width * 0.25),
        centerY,
        '▶',
        arrowConfig
    ).setOrigin(0.5);
    rightArrow.setInteractive({ useHandCursor: true });
    rightArrow.on('pointerdown', () => {
        currentPerkIndex = (currentPerkIndex + 1) % numPerkOptions;
        updateDisplayedCard();
        updateArrowVisibility();
    });

    // Add arrows to container
    levelUpContainer.add(leftArrow);
    levelUpContainer.add(rightArrow);

    // Add card counter text (e.g., "1/3")
    const counterText = scene.add.text(
        centerX,
        centerY + 180, // Below the card
        `${currentPerkIndex + 1}/${numPerkOptions}`,
        {
            fontFamily: 'Arial',
            fontSize: '18px',
            color: '#ffffff'
        }
    ).setOrigin(0.5);
    levelUpContainer.add(counterText);

    // Function to update arrow visibility and counter text
    function updateArrowVisibility() {
        // Update counter text
        counterText.setText(`${currentPerkIndex + 1}/${numPerkOptions}`);

        // Make both arrows visible but with different alpha based on position
        leftArrow.setVisible(true);
        rightArrow.setVisible(true);

        if (numPerkOptions <= 1) {
            // Hide both if only one card
            leftArrow.setVisible(false);
            rightArrow.setVisible(false);
        } else {
            // Set alpha based on position
            leftArrow.setAlpha(currentPerkIndex === 0 ? 0.5 : 1);
            rightArrow.setAlpha(currentPerkIndex === numPerkOptions - 1 ? 0.5 : 1);
        }
    }

    // Create a select button at the bottom
    const selectButton = scene.add.text(
        centerX,
        game.config.height * 0.8,
        'Select This Perk',
        {
            fontFamily: 'Arial',
            fontSize: '20px',
            color: '#ffffff',
            backgroundColor: '#008800',
            padding: { left: 15, right: 15, top: 10, bottom: 10 }
        }
    ).setOrigin(0.5);
    selectButton.setInteractive({ useHandCursor: true });

    // Add hover effects
    selectButton.on('pointerover', function () {
        this.setStyle({ backgroundColor: '#00aa00' });
    });
    selectButton.on('pointerout', function () {
        this.setStyle({ backgroundColor: '#008800' });
    });

    // Add click event
    selectButton.on('pointerdown', () => {
        const currentPerk = availablePerks[currentPerkIndex];
        if (currentPerk) {
            selectPerk(currentPerk.id);
        }
    });

    levelUpContainer.add(selectButton);

    // Function to handle perk selection
    function selectPerk(perkId) {
        // Acquire the selected perk
        acquirePerk(scene, perkId);

        // Update UI elements
        GameUI.updateStatCircles(scene);
        GameUI.updateHealthBar(scene);

        // Flash the hero when completing level up
        scene.tweens.add({
            targets: player,
            alpha: 0.2,
            scale: 1.5,
            duration: 200,
            yoyo: true,
            repeat: 1,
            onComplete: function () {
                player.setScale(1);
                player.alpha = 1;

                // Reset the level up lock
                window.levelUpInProgress = false;

                // Check if we have enough XP for another level up
                if (heroExp >= xpForNextLevel(playerLevel)) {
                    // Process next level up after a short delay
                    setTimeout(() => {
                        if (heroExp >= xpForNextLevel(playerLevel) && !window.levelUpInProgress) {
                            window.levelUpInProgress = true;
                            levelUp.call(scene);
                        }
                    }, 100);
                }
            }
        });

        // Clean up and close the level up screen
        levelUpContainer.destroy();
        levelUpCards = []; // Clear global array

        // Resume the game
        PauseSystem.resumeGame();
    }

    // Initial display setup
    updateDisplayedCard();
    updateArrowVisibility();

    // Add container to global level up cards for potential cleanup
    levelUpCards = [levelUpContainer];
}

/**
 * Modified showLevelUpScreen function with screen size detection
 * @param {Phaser.Scene} scene - The active game scene
 */
function showLevelUpScreen(scene) {
    // Check if we're in kajisuli mode (mobile)
    const isMobileMode = typeof KAJISULI_MODE !== 'undefined' ? KAJISULI_MODE : false;

    if (isMobileMode) {
        // Call the mobile-optimized version for kajisuli mode
        showMobileLevelUpScreen(scene);
    } else {
        // Use the existing romaji challenge for desktop mode
        if (window.RomajiChallengeSystem) {
            window.RomajiChallengeSystem.showLevelUpChallenge(scene);
        } else {
            console.error("RomajiChallengeSystem not found, falling back to mobile implementation");
            // Fallback to mobile version if romaji system is missing
            showMobileLevelUpScreen(scene);
        }
    }
}

// Update CardSystem exports to include new function
const CardSystem = {
    createPerkCardElements,
    createPerkCard,
    getActiveScene,
    showLevelUpScreen,
    showMobileLevelUpScreen, // Add the new function to the exported object
    generateRandomPerkCards,
    CARD_COLORS
};

// Export CardSystem for use in other files
window.CardSystem = CardSystem;

// ======= challenge.js =======
// challenge.js - Romaji Challenge System for Word Survivors
// Manages the romaji typing challenge during level-up

// Romaji Challenge System namespace
const RomajiChallengeSystem = {
    // Challenge state tracking
    state: {
        currentCards: 1,        // Start with 1 card
        maxCards: 4,            // Maximum of 4 cards
        selectedPerks: [],      // Perks selected for this challenge
        inputActive: true,      // Whether input is active
        attempts: 0,            // Number of failed attempts on current card
        currentIndex: 0,        // Current perk being challenged
        cardElements: []        // Store card elements for updating
    },

    // UI elements
    elements: {
        inputBox: null,
        inputText: null,
        submitButton: null,
        inputPrompt: null,
        levelUpContainer: null, // Main container for level up UI
        perkCardContainer: null // Container for perk cards
    },

    // Event handlers
    handlers: {
        keydownHandler: null,   // Keyboard event handler
    },

    // Debug keys state
    originalDebugKeysState: null,

    // Initialize the challenge system with a scene
    init: function (scene) {
        // Reset state
        this.resetState();

        console.log("Romaji Challenge System initialized");
    },

    // Reset challenge state
    resetState: function () {
        this.state = {
            currentCards: 1,
            maxCards: 4,
            selectedPerks: [],
            inputActive: true,
            attempts: 0,
            currentIndex: 0,
            cardElements: []
        };

        // Clean up UI elements references
        this.elements = {
            inputBox: null,
            inputText: null,
            submitButton: null,
            inputPrompt: null,
            levelUpContainer: null,
            perkCardContainer: null
        };

        // Clean up event handlers
        if (this.handlers.keydownHandler) {
            window.removeEventListener('keydown', this.handlers.keydownHandler);
            this.handlers.keydownHandler = null;
        }

        // Restore debug keys if they were disabled
        this.restoreDebugKeys();
    },

    // Show the level up challenge
    showLevelUpChallenge: function (scene) {
        // Pause the game
        PauseSystem.pauseGame();

        // Create a container with high depth for all level-up elements
        this.elements.levelUpContainer = scene.add.container(0, 0);
        this.elements.levelUpContainer.setDepth(1000); // Same depth as pause screen for consistency

        // Create semi-transparent background
        const centerX = game.config.width / 2;
        const centerY = game.config.height / 2;
        const levelUpBackground = scene.add.rectangle(centerX, centerY, game.config.width, game.config.height, 0x000000, 0.7);

        // Create level up title with improved styling
        const levelUpTitle = scene.add.text(
            centerX, game.config.height * 0.1875, // 150/800 = 0.1875
            'LEVEL UP!',
            {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }
        ).setOrigin(0.5);

        // Add background and title to container
        this.elements.levelUpContainer.add(levelUpBackground);
        this.elements.levelUpContainer.add(levelUpTitle);

        // Get random perks (excluding already acquired ones)
        this.state.selectedPerks = PerkSystem.getRandomPerks(4, acquiredPerks);

        // Create a container for cards (nested inside the main container)
        this.elements.perkCardContainer = scene.add.container(0, 0);
        this.elements.levelUpContainer.add(this.elements.perkCardContainer);

        // Create input field for romaji typing
        this.createRomajiInput(scene, centerX, game.config.height * 0.725); // 580/800 = 0.725

        // Create initial card(s)
        this.updatePerkCardDisplay(scene);

        // Store all level up UI elements in the global array for cleanup
        levelUpCards = [
            this.elements.levelUpContainer,
            // No need to add individual elements as they'll be destroyed with the container
        ];

        // Disable debug keys during the challenge
        this.disableDebugKeys(scene);
    },

    // Disable debug keys - improved without hardcoding specific keys
    disableDebugKeys: function (scene) {
        // Store the original debug keys state
        this.originalDebugKeysState = scene.debugKeysDisabled;

        // Disable debug keys flag
        scene.debugKeysDisabled = true;

        // No hardcoded key handling - just use the scene flag
        console.log("Debug keys disabled for romaji challenge");
    },

    // Restore debug keys to their original state
    restoreDebugKeys: function () {
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // If we have a saved state, restore it
        if (this.originalDebugKeysState !== null) {
            scene.debugKeysDisabled = this.originalDebugKeysState;
            this.originalDebugKeysState = null;
        } else {
            // Otherwise, default to enabling them
            scene.debugKeysDisabled = false;
        }

        console.log("Debug keys restored after romaji challenge");
    },

    // Create romaji input field
    createRomajiInput: function (scene, x, y) {
        // Create input prompt
        this.elements.inputPrompt = scene.add.text(
            x, y - game.config.height * 0.0625, // 50/800 = 0.0625
            'TYPE ROMAJI TO UNLOCK MORE',
            {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff'
            }
        ).setOrigin(0.5);

        // Create input box background
        const inputBoxWidth = game.config.width * 0.25; // 300/1200 = 0.25
        this.elements.inputBox = scene.add.rectangle(x, y, inputBoxWidth, 40, 0x333333, 1)
            .setStrokeStyle(2, 0xaaaaaa);

        // Create input text (positioned relative to the left of the input box)
        this.elements.inputText = scene.add.text(
            x - (inputBoxWidth / 2) + 10, y - 15,
            '',
            {
                fontFamily: 'Arial',
                fontSize: '20px',
                color: '#ffffff'
            }
        );

        // Create submit button - below the input box
        this.elements.submitButton = scene.add.text(
            x, y + game.config.height * 0.0625, // 50/800 = 0.0625
            'Submit',
            {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff',
                backgroundColor: '#008800',
                padding: { left: 15, right: 15, top: 8, bottom: 8 }
            }
        ).setOrigin(0.5);

        // Add all elements to the level-up container
        this.elements.levelUpContainer.add(this.elements.inputPrompt);
        this.elements.levelUpContainer.add(this.elements.inputBox);
        this.elements.levelUpContainer.add(this.elements.inputText);
        this.elements.levelUpContainer.add(this.elements.submitButton);

        this.elements.submitButton.setInteractive({ useHandCursor: true });

        // Add button hover effects
        this.elements.submitButton.on('pointerover', function () {
            this.setStyle({ backgroundColor: '#00aa00' });
        });

        this.elements.submitButton.on('pointerout', function () {
            this.setStyle({ backgroundColor: '#008800' });
        });

        // Add click event
        this.elements.submitButton.on('pointerdown', () => {
            this.validateRomajiInput(scene);
        });

        // Create a one-time-use generic keyboard event handler
        this.handlers.keydownHandler = (event) => {
            // Only process if the challenge is active
            if (!this.state.inputActive) return;

            // Handle different key types
            if (event.key === 'Backspace') {
                // Backspace - remove last character
                if (this.elements.inputText.text.length > 0) {
                    this.elements.inputText.setText(this.elements.inputText.text.slice(0, -1));
                }
            }
            else if (event.key === 'Enter') {
                // Enter - submit answer
                this.validateRomajiInput(scene);
            }
            else if (/^[a-zA-Z\-]$/.test(event.key)) {
                // Letters and dash - add to input
                this.elements.inputText.setText(this.elements.inputText.text + event.key.toLowerCase());
            }
        };

        // Add the handler to the window keydown event
        window.addEventListener('keydown', this.handlers.keydownHandler);
    },

    // Update the perk card display
    updatePerkCardDisplay: function (scene) {
        console.log("Updating perk card display, cards: " + this.state.currentCards);

        // First, completely clear the container
        this.elements.perkCardContainer.removeAll(true); // true means destroy children
        this.state.cardElements = [];

        // Calculate positions for cards
        const cardCount = this.state.currentCards;
        const cardWidth = 220; // Fixed card width
        const cardSpacing = game.config.width * 0.0167; // 20/1200 = 0.0167
        const totalWidth = cardCount * cardWidth + (cardCount - 1) * cardSpacing;
        const centerX = game.config.width / 2;
        const startX = centerX - (totalWidth / 2) + (cardWidth / 2);

        console.log("Creating " + cardCount + " cards");

        // Create each card
        for (let i = 0; i < cardCount; i++) {
            const cardX = startX + i * (cardWidth + cardSpacing);
            const perk = this.state.selectedPerks[i];

            if (!perk) {
                console.log("Warning: No perk found for index " + i);
                continue;
            }

            console.log("Creating card for perk: " + perk.id + " at position " + i);

            // Determine what to show based on state
            const isCurrentChallenge = (i === this.state.currentCards - 1 &&
                this.state.inputActive &&
                i === this.state.currentIndex);

            // Show partial or full details based on attempts
            const showKana = !isCurrentChallenge || this.state.attempts >= 1;
            const showRomaji = !isCurrentChallenge || this.state.attempts >= 2;
            const showEnglish = !isCurrentChallenge || this.state.attempts >= 2;
            const showDescription = !isCurrentChallenge || this.state.attempts >= 2;

            // Create card elements with appropriate options
            const cardElements = window.CardSystem.createPerkCardElements(perk, cardX, game.config.height * 0.4125, { // 330/800 = 0.4125
                container: this.elements.perkCardContainer,
                showKana: showKana,
                showRomaji: showRomaji,
                showEnglish: showEnglish,
                showDescription: showDescription,
                makeInteractive: true,
                perkCallback: (perkId) => {
                    this.selectCard(scene, perkId);
                }
            });

            // Store card elements including background
            this.state.cardElements.push({
                background: cardElements[0], // First element is the background
                elements: cardElements.slice(1) // Rest are text elements
            });
        }

        // Update input visibility based on challenge state
        this.updateInputVisibility();

        console.log("Card display updated, now showing " + this.state.cardElements.length + " cards");
    },

    // Function to validate romaji input
    validateRomajiInput: function (scene) {
        if (!this.state.inputActive) return;

        const userInput = this.elements.inputText.text.trim().toLowerCase();
        const currentPerk = this.state.selectedPerks[this.state.currentIndex];

        if (!currentPerk) return;

        const correctRomaji = currentPerk.romaji.toLowerCase();

        if (userInput === correctRomaji) {
            // Correct answer
            this.handleCorrectRomaji(scene);
        } else {
            // Wrong answer
            this.handleWrongRomaji(scene);
        }

        // Clear input field
        this.elements.inputText.setText('');
    },

    // Function to handle correct romaji input
    handleCorrectRomaji: function (scene) {
        // Store a local reference to the input box to use in the tween callback
        // This prevents errors if elements are cleared before the tween completes
        const inputBox = this.elements.inputBox;

        if (!inputBox) return; // Safety check

        // Play success sound/effect with improved callback safety
        scene.tweens.add({
            targets: inputBox,
            strokeStyle: { value: 0x00ff00 },
            alpha: { value: 0.8 },
            yoyo: true,
            duration: 200,
            repeat: 1,
            onComplete: function () {
                // Check if the input box still exists before manipulating it
                if (inputBox && inputBox.active) {
                    inputBox.setStrokeStyle(2, 0xaaaaaa);
                    inputBox.alpha = 1;
                }
            }
        });

        // Show success message
        const centerX = game.config.width / 2;
        const successY = game.config.height * 0.8125; // 650/800 = 0.8125
        const successText = scene.add.text(
            centerX, successY,
            'Correct!',
            {
                fontFamily: 'Arial',
                fontSize: '24px',
                color: '#00ff00',
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);

        // Add success text to container
        this.elements.levelUpContainer.add(successText);

        scene.tweens.add({
            targets: successText,
            y: successText.y - 30,
            alpha: 0,
            duration: 1000,
            onComplete: function () {
                successText.destroy();
            }
        });

        // Unlock the current card (show full details)
        this.state.attempts = 2; // Force full details

        // If this is the final card (4th), give XP reward
        if (this.state.currentCards >= this.state.maxCards) {
            // Award 25% of XP needed for next level
            const currentLevel = playerLevel;
            const currentExpToLevel = xpForNextLevel(playerLevel);
            const currentExp = heroExp;

            const xpReward = Math.ceil(xpForNextLevel(playerLevel) * 0.25);
            console.log(`Level ${currentLevel}: Calculating reward as 25% of ${currentExpToLevel} = ${xpReward}`);

            heroExp += xpReward;
            console.log(`XP before: ${currentExp}, after: ${heroExp}, needed: ${xpForNextLevel(playerLevel)}`);

            // After updating the XP bar, check if something unexpected happened
            setTimeout(() => {
                console.log(`Post-update check: Level ${playerLevel}, XP ${heroExp}/${xpForNextLevel(playerLevel)}`);
                if (playerLevel > currentLevel) {
                    console.log(`WARNING: Level changed from ${currentLevel} to ${playerLevel} after challenge reward!`);
                }
            }, 100);
            GameUI.updateExpBar(scene);

            // Show XP reward
            const rewardY = game.config.height * 0.85; // 680/800 = 0.85
            const rewardText = scene.add.text(
                centerX, rewardY,
                `+${xpReward} XP Bonus!`,
                {
                    fontFamily: 'Arial',
                    fontSize: '20px',
                    color: '#00ffff',
                    fontStyle: 'bold'
                }
            ).setOrigin(0.5);

            scene.tweens.add({
                targets: rewardText,
                y: rewardText.y - 30,
                alpha: 0,
                duration: 1500,
                onComplete: function () {
                    rewardText.destroy();
                }
            });

            // End the input challenge
            this.state.inputActive = false;
        } else {
            // Increment current card count
            this.state.currentCards = Math.min(
                this.state.currentCards + 1,
                this.state.maxCards
            );

            // Update current challenge index
            this.state.currentIndex = this.state.currentCards - 1;
            this.state.attempts = 0;
        }

        // Update card display
        this.updatePerkCardDisplay(scene);
    },

    // Function to handle incorrect romaji input
    handleWrongRomaji: function (scene) {
        console.log("Wrong romaji input, attempts: " + this.state.attempts);

        // Store a local reference to the input box to use in the tween callback
        const inputBox = this.elements.inputBox;

        if (!inputBox) return; // Safety check

        // Play failure sound/effect with improved callback safety
        scene.tweens.add({
            targets: inputBox,
            strokeStyle: { value: 0xff0000 },
            alpha: { value: 0.8 },
            yoyo: true,
            duration: 200,
            repeat: 1,
            onComplete: function () {
                // Check if the input box still exists before manipulating it
                if (inputBox && inputBox.active) {
                    inputBox.setStrokeStyle(2, 0xaaaaaa);
                    inputBox.alpha = 1;
                }
            }
        });

        // Increment attempts
        this.state.attempts++;
        console.log("Attempts increased to: " + this.state.attempts);

        const centerX = game.config.width / 2;
        const messageY = game.config.height * 0.8125; // 650/800 = 0.8125

        if (this.state.attempts === 1) {
            // First wrong attempt - show kana hint
            const hintText = scene.add.text(
                centerX, messageY,
                'Hint: Check the kana!',
                {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#ffff00'
                }
            ).setOrigin(0.5);

            // Add to container
            this.elements.levelUpContainer.add(hintText);

            scene.tweens.add({
                targets: hintText,
                y: hintText.y - 20,
                alpha: 0,
                duration: 1500,
                onComplete: function () {
                    hintText.destroy();
                }
            });

            // Force show kana for the current card
            const currentPerk = this.state.selectedPerks[this.state.currentIndex];
            const cardX = this.state.cardElements[this.state.currentIndex].background.x;

            // Add kana text directly
            const kanaY = game.config.height * 0.39375; // 315/800 = 0.39375
            const kanaText = scene.add.text(
                cardX, kanaY,
                currentPerk.kana,
                { fontFamily: 'Arial', fontSize: '20px', color: '#ffffff' }
            ).setOrigin(0.5);

            this.elements.perkCardContainer.add(kanaText);
            this.state.cardElements[this.state.currentIndex].elements.push(kanaText);

            console.log("Added kana hint:", currentPerk.kana);
        } else {
            // Second wrong attempt - end input challenge
            const failText = scene.add.text(
                centerX, messageY,
                'Challenge ended - pick a perk',
                {
                    fontFamily: 'Arial',
                    fontSize: '18px',
                    color: '#ff6666'
                }
            ).setOrigin(0.5);

            // Add to container
            this.elements.levelUpContainer.add(failText);

            scene.tweens.add({
                targets: failText,
                y: failText.y - 20,
                alpha: 0,
                duration: 1500,
                onComplete: function () {
                    failText.destroy();
                }
            });

            // End input challenge and rebuild all cards with full details
            this.state.inputActive = false;

            // Clear and rebuild all cards
            this.elements.perkCardContainer.removeAll(true);
            this.updatePerkCardDisplay(scene);

            console.log("Challenge ended after second failure");
        }
    },

    // Function to update input visibility
    updateInputVisibility: function () {
        const isInputVisible = this.state.inputActive;

        // Safety check - make sure elements exist before trying to set visibility
        if (this.elements.inputBox) {
            this.elements.inputBox.setVisible(isInputVisible);
        }
        if (this.elements.inputText) {
            this.elements.inputText.setVisible(isInputVisible);
        }
        if (this.elements.submitButton) {
            this.elements.submitButton.setVisible(isInputVisible);
        }
        if (this.elements.inputPrompt) {
            this.elements.inputPrompt.setVisible(isInputVisible);
        }

        // If no longer active, show encouraging message
        if (!isInputVisible) {
            // Change subtitle text
            levelUpCards.forEach(element => {
                if (element && element.text === 'Type romaji to unlock more choices') {
                    element.setText('Choose a perk to continue');
                }
            });
        }
    },

    // Function to select a card and acquire the perk
    selectCard: function (scene, perkType) {
        console.log("Card selected with perk: " + perkType);

        // Acquire the selected perk
        acquirePerk(scene, perkType);

        // Update player stats text
        GameUI.updateStatCircles(scene);

        // Update health bar
        GameUI.updateHealthBar(scene);

        // First make all the elements invisible for cleaner transition
        levelUpCards.forEach(element => {
            if (element && element.setVisible) {
                element.setVisible(false);
            }
        });

        if (this.elements.perkCardContainer) {
            this.elements.perkCardContainer.setVisible(false);
        }

        // Close the cards and resume the game
        this.closeLevelUpCards(scene);

        // Flash the hero when completing level up
        scene.tweens.add({
            targets: player,
            alpha: 0.2,
            scale: 1.5,
            duration: 200,
            yoyo: true,
            repeat: 1,
            onComplete: function () {
                player.setScale(1);
                player.alpha = 1;

                // Reset the level up lock
                window.levelUpInProgress = false;

                // Check if we have enough XP for another level up
                if (heroExp >= xpForNextLevel(playerLevel)) {
                    // Use the scene parameter passed to selectCard instead of looking up game.scene
                    setTimeout(() => {
                        if (heroExp >= xpForNextLevel(playerLevel) && !window.levelUpInProgress) {
                            window.levelUpInProgress = true;
                            levelUp.call(scene);
                        }
                    }, 100);
                }
            }
        });

        console.log("Level up complete, game resumed");
    },

    // Function to close level up cards and clean up resources
    closeLevelUpCards: function (scene) {
        console.log("Closing level up cards and cleaning up UI elements");

        // Clean up the window key handler
        if (this.handlers.keydownHandler) {
            window.removeEventListener('keydown', this.handlers.keydownHandler);
            this.handlers.keydownHandler = null;
        }

        // Restore debug keys
        this.restoreDebugKeys();

        // Extra safety: check if we're in a valid scene
        if (!scene.add) {
            console.log("Not in a valid scene, forcing cleanup");
            levelUpCards = [];
            this.resetState();
            return;
        }

        // Destroy the main container which will destroy all child elements
        if (this.elements.levelUpContainer) {
            this.elements.levelUpContainer.destroy();
            this.elements.levelUpContainer = null;
        }

        // Reset references
        this.resetState();

        // Reset global array
        levelUpCards = [];

        // Resume game
        PauseSystem.resumeGame();
    }
};

// Export the system for use in other files
window.RomajiChallengeSystem = RomajiChallengeSystem;

// ======= cooldown.js =======
// CooldownManager - a system to track and update timers based on stat changes
const CooldownManager = {
    // Store registered timers with their configuration
    registeredTimers: [],

    // Last known player stats
    lastStats: {
        luck: null,
        fireRate: null,
        damage: null,
        health: null
    },

    // Initialize the system
    initialize: function () {
        // Reset registered timers array
        this.registeredTimers = [];

        // Store initial stats
        this.lastStats.luck = playerLuck;
        this.lastStats.fireRate = playerFireRate;
        this.lastStats.damage = playerDamage;
        this.lastStats.health = maxPlayerHealth;

        console.log("CooldownManager initialized with stats:", this.lastStats);
    },

    // Create and register a timer
    createTimer: function (options) {
        const scene = game.scene.scenes[0];
        if (!scene) return null;

        // Get current stat value
        const currentStatValue = options.statName === 'luck' ? playerLuck :
            options.statName === 'fireRate' ? playerFireRate :
                options.statName === 'damage' ? playerDamage :
                    options.statName === 'health' ? maxPlayerHealth : 1;

        // Calculate initial cooldown
        let initialCooldown;
        if (options.formula === 'multiply') {
            initialCooldown = options.baseCooldown * currentStatValue;
        } else if (options.formula === 'sqrt') {
            // Use BASE_STATS reference for better code maintenance
            const baseStatValue = options.statName === 'luck' ? BASE_STATS.LUK :
                options.statName === 'fireRate' ? BASE_STATS.AGI :
                    options.statName === 'damage' ? BASE_STATS.POW :
                        options.statName === 'health' ? BASE_STATS.END : 4;
            initialCooldown = options.baseCooldown / (Math.sqrt(currentStatValue / baseStatValue));
        } else {
            // Default to divide
            initialCooldown = options.baseCooldown / currentStatValue;
        }

        // Create the timer
        const timer = scene.time.addEvent({
            delay: initialCooldown,
            callback: options.callback,
            callbackScope: options.callbackScope,
            loop: options.loop ?? true
        });

        // Register with effect system
        window.registerEffect('timer', timer);

        // Store configuration
        const config = {
            timer: timer,
            statName: options.statName ?? 'luck',
            baseCooldown: options.baseCooldown ?? 30000,
            formula: options.formula ?? 'divide',
            component: options.component ?? null,
            callback: options.callback,
            callbackScope: options.callbackScope,
            loop: options.loop ?? true
        };

        // Add to registered timers
        this.registeredTimers.push(config);

        return timer;
    },

    // Remove a timer
    removeTimer: function (timer) {
        if (!timer) return;

        // Find and remove the timer from registry
        this.registeredTimers = this.registeredTimers.filter(config => config.timer !== timer);

        // Stop the timer
        if (timer && !timer.hasOwnProperty('removed')) {
            timer.remove();
        }
    },

    // Check for stat changes and update timers accordingly
    update: function () {
        let statsChanged = false;
        const changedStats = {};

        // Check each stat for significant changes (10% or more)
        if (Math.abs(this.lastStats.luck - playerLuck) >= this.lastStats.luck * 0.1) {
            changedStats.luck = playerLuck;
            statsChanged = true;
        }

        if (Math.abs(this.lastStats.fireRate - playerFireRate) >= this.lastStats.fireRate * 0.1) {
            changedStats.fireRate = playerFireRate;
            statsChanged = true;
        }

        if (Math.abs(this.lastStats.damage - playerDamage) >= this.lastStats.damage * 0.1) {
            changedStats.damage = playerDamage;
            statsChanged = true;
        }

        if (Math.abs(this.lastStats.health - maxPlayerHealth) >= this.lastStats.health * 0.1) {
            changedStats.health = maxPlayerHealth;
            statsChanged = true;
        }

        // If no significant changes, exit early
        if (!statsChanged) return;

        console.log("Significant stat changes detected:", changedStats);

        // Update each affected timer
        this.registeredTimers.forEach(config => {
            // Check if this timer depends on a changed stat
            if (changedStats.hasOwnProperty(config.statName)) {
                this.updateTimer(config, changedStats[config.statName]);
            }
        });

        // Update stored stats
        Object.assign(this.lastStats, changedStats);
    },

    // Update a specific timer with new stat value
    updateTimer: function (config, newStatValue) {
        // Skip if timer was removed
        if (!config.timer || config.timer.hasOwnProperty('removed')) return;

        // Calculate new cooldown based on formula
        let newCooldown;
        if (config.formula === 'multiply') {
            newCooldown = config.baseCooldown * newStatValue;
        } else if (config.formula === 'sqrt') {
            // Use BASE_STATS reference for better code maintenance
            const baseStatValue = config.statName === 'luck' ? BASE_STATS.LUK :
                config.statName === 'fireRate' ? BASE_STATS.AGI :
                    config.statName === 'damage' ? BASE_STATS.POW :
                        config.statName === 'health' ? BASE_STATS.END : 4;
            newCooldown = config.baseCooldown / (Math.sqrt(newStatValue / baseStatValue));
        } else {
            // Default to divide
            newCooldown = config.baseCooldown / newStatValue;
        }

        // Store elapsed time and progress
        const elapsed = config.timer.elapsed;
        const progress = elapsed / config.timer.delay;

        console.log(`Updating timer: old delay=${config.timer.delay}ms, new delay=${newCooldown}ms, progress=${progress.toFixed(2)}`);

        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Remove old timer
        config.timer.remove();

        // Create new timer with updated cooldown
        const newTimer = scene.time.addEvent({
            delay: newCooldown,
            callback: config.callback,
            callbackScope: config.callbackScope,
            loop: config.loop
        });

        // Preserve progress in the cooldown cycle
        newTimer.elapsed = progress * newCooldown;

        // Register with effect system
        window.registerEffect('timer', newTimer);

        // Update reference in config
        config.timer = newTimer;

        // If component exists, update its reference too
        if (config.component && typeof config.component === 'object') {
            // For familiar timers, store reference directly
            if (config.component.firingTimer === config.timer) {
                config.component.firingTimer = newTimer;
            }
            // Find timer property in component for other types
            else {
                for (const key in config.component) {
                    if (config.component[key] === config.timer) {
                        config.component[key] = newTimer;
                        break;
                    }
                }
            }
        }
    }
};

// Export the manager for use in other files
window.CooldownManager = CooldownManager;

// ======= debug.js =======
// debug.js - Debug utilities and performance monitoring for Word Survivors
// Manages debug mode, performance stats, and debug keyboard shortcuts

// Debug System namespace
const DebugSystem = {
    // State tracking
    debugModeEnabled: false,
    statsVisible: false,
    statsText: null,

    // Initialize the debug system
    init: function (scene) {
        // Create stats text display (initially hidden)
        this.setupPerformanceMonitor(scene);

        // Setup debug keyboard shortcuts
        this.setupDebugKeys(scene);

        console.log("Debug system initialized (press O to toggle)");
    },

    // Toggle debug mode and stats visibility
    toggleDebugMode: function (scene) {
        // Toggle debug mode
        this.debugModeEnabled = !this.debugModeEnabled;

        // Toggle stats visibility
        if (this.statsText) {
            this.statsText.visible = this.debugModeEnabled;
            this.statsVisible = this.debugModeEnabled;
        }

        // Toggle physics debug rendering
        scene.physics.world.drawDebug = this.debugModeEnabled;

        // When enabling debug mode, we need to create the debug graphics if it doesn't exist
        if (this.debugModeEnabled && !scene.physics.world.debugGraphic) {
            scene.physics.world.createDebugGraphic();
        }

        // Toggle the visibility of the debug graphics
        if (scene.physics.world.debugGraphic) {
            scene.physics.world.debugGraphic.visible = this.debugModeEnabled;
        }

        console.log(`Debug mode ${this.debugModeEnabled ? 'enabled' : 'disabled'}`);
    },

    // Setup performance monitoring display
    setupPerformanceMonitor: function (scene) {
        // Create stats text display (initially hidden)
        // Position in top-right corner with padding
        const rightPadding = 20;
        const topPadding = 10;
        const statsX = game.config.width - rightPadding;
        const statsY = topPadding;

        this.statsText = scene.add.text(statsX, statsY, 'FPS: 0', {
            fontFamily: 'Arial',
            fontSize: '14px',
            color: '#00ff00',
            backgroundColor: '#000000',
            padding: { x: 5, y: 5 }
        });
        // Set origin to right-align text against the right edge
        this.statsText.setOrigin(1, 0);
        this.statsText.setDepth(1000);
        this.statsText.visible = false;
        this.statsVisible = false;
    },

    // Update performance statistics display
    updatePerformanceStats: function (scene, time, delta) {
        if (this.statsText && this.statsVisible) {
            const fps = Math.round(scene.game.loop.actualFps);

            // Get physics bodies count
            let bodyCount = 0;
            if (scene.physics && scene.physics.world) {
                bodyCount = scene.physics.world.bodies.size;
            }

            // Count active game objects by type
            const totalObjects = scene.children.list.length;
            let enemyCount = 0;
            let projectileCount = 0;

            if (window.EnemySystem && window.EnemySystem.enemiesGroup) {
                enemyCount = window.EnemySystem.enemiesGroup.getChildren().length;
            }
            if (window.projectiles) {
                projectileCount = window.projectiles.getChildren().length;
            }

            // Calculate frame time from delta
            const frameTime = delta.toFixed(2);

            // Get memory usage if available
            let memoryUsage = "N/A";
            if (window.performance && window.performance.memory) {
                memoryUsage = Math.round(window.performance.memory.usedJSHeapSize / 1048576) + " MB";
            }

            // Update stats text
            this.statsText.setText(
                `DEBUG MODE ON\n` +
                `FPS: ${fps}\n` +
                `Frame Time: ${frameTime}ms\n` +
                `Memory: ${memoryUsage}\n` +
                `Total Objects: ${totalObjects}\n` +
                `Enemies: ${enemyCount}\n` +
                `Projectiles: ${projectileCount}\n` +
                `Physics Bodies: ${bodyCount}`
            );
        }
    },

    // Setup debug keyboard shortcuts
    setupDebugKeys: function (scene) {
        // Add debug key (R key for instant level up)
        scene.input.keyboard.on('keydown-R', function () {
            // Skip if debug keys are disabled
            if (this.debugKeysDisabled) return;

            if (!gamePaused && !gameOver) {
                // Add enough XP to level up
                const xpNeeded = xpForNextLevel(playerLevel) - heroExp;
                heroExp += xpNeeded;
                GameUI.updateExpBar(this);
                console.log("Debug: Instant level up triggered");
            }
        }, scene);

        // Add debug key (T key for instant enemy spawn)
        scene.input.keyboard.on('keydown-T', function () {
            // Skip if debug keys are disabled
            if (this.debugKeysDisabled) return;

            if (!gamePaused && !gameOver) {
                // Access the main game scene and call spawnEnemyOfRank on it with rank 1
                const activeScene = this;
                if (activeScene) {
                    window.spawnEnemyOfRank.call(activeScene, 1);
                    console.log("Debug: Rank 1 enemy spawned");
                }
            }
        }, scene);

        // Add debug key (K key for skipping to next enemy phase)
        scene.input.keyboard.on('keydown-K', function () {
            // Skip if debug keys are disabled
            if (this.debugKeysDisabled) return;

            if (!gamePaused && !gameOver) {
                // Skip to next phase based on current elapsed time
                DebugSystem.skipToNextPhase.call(this);
            }
        }, scene);

        // Add debug key (O key for performance monitor toggle)
        scene.input.keyboard.on('keydown-O', function () {
            // Skip if debug keys are disabled
            if (this.debugKeysDisabled) return;

            // Toggle debug mode and stats visibility
            DebugSystem.toggleDebugMode(this);
        }, scene);

        // Add debug key (M key for toggling music)
        scene.input.keyboard.on('keydown-M', function () {
            // Skip if debug keys are disabled
            if (this.debugKeysDisabled) return;

            // Toggle music if MusicSystem is available
            if (window.MusicSystem) {
                const musicEnabled = MusicSystem.setMusicEnabled(!MusicSystem.musicEnabled);
                console.log(`Debug: Music ${musicEnabled ? 'enabled' : 'disabled'}`);
            } else {
                console.log("Debug: MusicSystem not available");
            }
        }, scene);
    },

    // Skip to the next enemy phase for testing
    skipToNextPhase: function () {
        // Get the current minutes elapsed
        const currentMinutes = elapsedTime / 60;

        // Find the next phase timing based on rankEnemyStartTimes
        // Convert the start times from seconds to minutes
        const phaseTimings = Object.values(rankEnemyStartTimes).map(time => time / 60);

        // Sort the phase timings to ensure they're in ascending order
        phaseTimings.sort((a, b) => a - b);

        // Find the next phase timing
        let nextPhaseMinutes = null;
        for (const phaseTime of phaseTimings) {
            if (phaseTime > currentMinutes) {
                nextPhaseMinutes = phaseTime;
                break;
            }
        }

        // If no next phase was found, add 12 minutes (common phase interval)
        if (nextPhaseMinutes === null) {
            // Find the highest phase timing and add 12 minutes
            const highestPhase = Math.max(...phaseTimings);
            nextPhaseMinutes = Math.floor(currentMinutes / 12) * 12 + 12;

            // Ensure we're actually advancing time
            if (nextPhaseMinutes <= currentMinutes) {
                nextPhaseMinutes = currentMinutes + 12;
            }
        }

        // Update elapsedTime to the new phase time (in seconds)
        const oldElapsedTime = elapsedTime;
        elapsedTime = nextPhaseMinutes * 60;

        // Log the action
        console.log(`Debug: Time skipped from ${Math.floor(oldElapsedTime / 60)} minutes to ${nextPhaseMinutes} minutes`);

        // Update the level display
        GameUI.updateStatusDisplay(this, elapsedTime, score);

        // Update enemy spawners to reflect the new time
        EnemySystem.updateEnemySpawners();
    },

    // Disable debug keys during special game states (e.g., level up)
    disableDebugKeys: function (scene) {
        // Set the flag to disable debug keys (same flag used by RomajiChallengeSystem)
        scene.debugKeysDisabled = true;
    },

    // Restore debug keys to their original state
    restoreDebugKeys: function (scene) {
        // Set the flag to enable debug keys
        scene.debugKeysDisabled = false;
    },

    // Clean up resources (call during game restart)
    cleanup: function () {
        // Clean up performance monitor
        if (this.statsText) {
            this.statsText.destroy();
            this.statsText = null;
        }

        // Reset state
        this.debugModeEnabled = false;
        this.statsVisible = false;
    }
};

// Export the debug system
window.DebugSystem = DebugSystem;

// ======= droppers.js =======
// Dropper Component System for Word Survivors
// Manages entities that are dropped by the player and remain in the world

// Global list to store all active drops
const drops = [];

// Behavior definitions for different types of drops
const DropBehaviors = {
    // projectile behavior - detonates on enemy contact
    projectile: function (scene, drop, enemy) {
        // Apply damage to the enemy using the contact damage system
        applyContactDamage.call(
            scene,
            drop.entity,
            enemy,
            drop.entity.damage,
            drop.damageInterval
        );

        // Apply effect component if specified
        if (drop.options && drop.options.effectComponent) {
            const componentName = drop.options.effectComponent;
            const component = ProjectileComponentSystem.componentTypes[componentName];

            if (component && component.onHit) {
                // Create a minimal synthetic projectile with necessary properties
                const syntheticProjectile = {
                    damage: drop.entity.damage,
                    x: drop.entity.x,
                    y: drop.entity.y,
                    damageSourceId: drop.entity.damageSourceId + '_effect'
                };

                // Apply the effect
                component.onHit(syntheticProjectile, enemy, scene);
            }
        }

        // Reduce drop health by 1
        drop.health -= 1;

        // Show damage visual effect
        VisualEffects.createDamageFlash(scene, drop.entity);

        // Only destroy if health reaches 0 or below
        if (drop.health <= 0) {
            DropperSystem.destroyDrop(drop);
        }
    },

    // Persistent behavior - deals continuous damage while enemies overlap
    persistent: function (scene, drop, enemy) {
        // Apply contact damage with the specified cooldown
        applyContactDamage.call(
            scene,
            drop.entity,
            enemy,
            drop.entity.damage,
            drop.damageInterval
        );
    },

    // Area effect behavior - deals damage to all enemies in range periodically
    areaEffect: function (scene, drop, enemy) {
        // Reduce drop health by 1
        drop.health -= 1;

        // Show damage visual effect
        VisualEffects.createDamageFlash(scene, drop.entity);

        // Only destroy if health reaches 0 or below
        if (drop.health <= 0) {
            DropperSystem.destroyDrop(drop);
        }
    }
};

// Main Dropper System
const DropperSystem = {
    // Initialize the system
    init: function () {
        // Clear any existing drops
        this.clearAll();
        console.log("Dropper system initialized");
    },

    // Create a new drop entity
    create: function (scene, config) {
        // Default configuration with fallbacks
        const defaults = {
            symbol: '★',                 // Text symbol to display
            color: '#ffff00',            // Color of the drop
            fontSize: 32,                // Size of the font
            x: player.x,                 // X position (default to player position)
            y: player.y,                 // Y position (default to player position)
            behaviorType: 'projectile',  // Behavior type ('projectile', 'persistent', 'areaEffect')
            damage: playerDamage,        // Damage dealt to enemies
            damageInterval: 500,         // Minimum time between damage instances in ms
            colliderSize: 0.8,           // Size multiplier for collision detection
            lifespan: null,              // Time in ms before auto-destruction (null for permanent)
            health: 1,                   // NEW: Health points (1 = dies on first hit)
            options: {}                  // Additional options for specific behaviors
        };

        // Merge provided config with defaults
        const dropConfig = { ...defaults, ...config };

        // Create the drop entity as a text object
        const entity = scene.add.text(
            dropConfig.x,
            dropConfig.y,
            dropConfig.symbol,
            {
                fontFamily: 'Arial',
                fontSize: `${dropConfig.fontSize}px`,
                color: dropConfig.color,
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);

        if (dropConfig.options.opacity !== undefined) {
            entity.setAlpha(dropConfig.options.opacity);
        }

        // Add physics to the drop for enemy overlap detection
        scene.physics.world.enable(entity);
        entity.body.setSize(entity.width * dropConfig.colliderSize, entity.height * dropConfig.colliderSize);
        entity.body.setImmovable(true);  // Drops don't move when collided with

        // Store unique ID for damage source (used for cooldown tracking)
        entity.damageSourceId = `drop_${Date.now()}_${Math.random()}`;

        // Store damage value on the entity
        entity.damage = dropConfig.damage;

        // Create the drop object that tracks all properties
        const drop = {
            entity: entity,
            behaviorType: dropConfig.behaviorType,
            damageInterval: dropConfig.damageInterval,
            createdAt: scene.time.now,
            lifespan: dropConfig.lifespan,
            areaEffectInterval: dropConfig.options.areaEffectInterval ?? 1000,
            areaEffectRadius: dropConfig.options.areaEffectRadius ?? 100,
            health: dropConfig.health,   // NEW: Store health in the drop object
            options: dropConfig.options,
            destroyed: false             // Flag to mark for cleanup
        };

        // Add to global list
        drops.push(drop);

        // Register for cleanup
        window.registerEffect('entity', entity);

        // If this is an area effect, set up its timer using CooldownManager
        if (drop.behaviorType === 'areaEffect') {
            drop.areaEffectTimer = CooldownManager.createTimer({
                statName: 'luck',
                baseCooldown: drop.areaEffectInterval,
                formula: 'sqrt',
                component: drop, // Reference for cleanup
                callback: function () {
                    if (gameOver || gamePaused || drop.destroyed ||
                        !drop.entity || !drop.entity.active) return;

                    // Process the area effect
                    DropperSystem.processAreaEffect(scene, drop, scene.time.now);
                },
                callbackScope: scene,
                loop: true
            });
        }

        // Get the appropriate behavior function
        const behavior = DropBehaviors[dropConfig.behaviorType] ?? DropBehaviors.projectile;

        // Add overlap with enemies based on behavior
        scene.physics.add.overlap(entity, EnemySystem.enemiesGroup, function (dropEntity, enemy) {
            // Skip if drop is already marked as destroyed
            if (drop.destroyed) return;

            // Call the appropriate behavior function
            behavior(scene, drop, enemy);
        }, null, scene);

        // Visual effect when spawning
        scene.tweens.add({
            targets: entity,
            scale: { from: dropConfig.initialScale, to: 1 },
            duration: 500,
            ease: 'Back.out'
        });

        // Any custom visual effect is applied here
        applyVisualEffects(scene, entity, dropConfig.options);

        // Set up auto-destruction timer if lifespan is specified
        if (drop.lifespan !== null) {
            const timer = scene.time.delayedCall(drop.lifespan, function () {
                DropperSystem.destroyDrop(drop);
            });

            // Register the timer for cleanup
            window.registerEffect('timer', timer);
        }

        return drop;
    },

    // Update all drops
    update: function (scene, time) {
        // Skip if no drops or game state prevents updates
        if (gameOver || gamePaused || drops.length === 0) return;

        // Clean up destroyed drops
        this.cleanupInactive();
    },

    // Process area effect for a drop
    processAreaEffect: function (scene, drop, time) {
        // Get all active enemies
        const allEnemies = EnemySystem.enemiesGroup.getChildren();

        // Get center position of the drop
        const centerX = drop.entity.x;
        const centerY = drop.entity.y;

        // Calculate radius based on base radius and playerLuck
        let radius = drop.areaEffectRadius;
        // If radiusScalesWithLuck flag is set, apply luck scaling
        if (drop.options.radiusScalesWithLuck) {
            radius = radius * Math.sqrt(playerLuck / BASE_STATS.LUK);
        }

        // Get the color from drop options or use default yellow
        const effectColor = drop.options.pulseColor ?? 0xffff00;

        // Always create visual effect regardless of enemy hits
        this.createPulseEffect(scene, centerX, centerY, radius, effectColor);

        // Apply damage or effects to all enemies in range
        let hitCount = 0;

        // Check if this area effect has a component
        const componentName = drop.options.effectComponent;
        const component = componentName ?
            ProjectileComponentSystem.componentTypes[componentName] : null;

        allEnemies.forEach(enemy => {
            if (!enemy.active) return;

            // Calculate distance from the drop
            const dx = enemy.x - centerX;
            const dy = enemy.y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If within effect radius, apply effect
            if (distance <= radius) {
                // Always apply regular damage
                const damageAmount = drop.entity.damage;
                const areaSourceId = `${drop.entity.damageSourceId}_area_${enemy.id ?? Math.random()}`;

                applyContactDamage.call(
                    scene,
                    {
                        damageSourceId: areaSourceId,
                        damage: damageAmount,
                        active: true
                    },
                    enemy,
                    damageAmount,
                    0 // No cooldown since the area effect has its own interval timing
                );

                // If there's a component with onHit method, call it as well
                if (component && component.onHit) {
                    // Create a synthetic projectile with minimal required properties
                    const syntheticProjectile = {
                        damage: drop.entity.damage,
                        x: centerX,
                        y: centerY,
                        // Add other properties that might be needed
                        damageSourceId: `${drop.entity.damageSourceId}_component_${Date.now()}_${Math.random()}`
                    };

                    // Call the component's onHit method directly
                    component.onHit(syntheticProjectile, enemy, scene);
                }

                hitCount++;
            }
        });
    },

    // New helper method to create the pulse visual effect
    createPulseEffect: function (scene, x, y, radius, color) {
        return VisualEffects.createExplosion(scene, x, y, radius, color);
    },

    // Clean up inactive drops
    cleanupInactive: function () {
        for (let i = drops.length - 1; i >= 0; i--) {
            const drop = drops[i];
            if (drop.destroyed || !drop.entity || !drop.entity.active) {
                drops.splice(i, 1);
            }
        }
    },

    // Clear all drops
    clearAll: function () {
        // Destroy all drop entities
        drops.forEach(drop => {
            if (drop.entity && drop.entity.active) {
                drop.entity.destroy();
            }
        });

        // Clear the array
        drops.length = 0;
    },

    // Get all active drops
    getAll: function () {
        return drops.filter(drop => !drop.destroyed && drop.entity && drop.entity.active);
    },

    // Get count of active drops
    getCount: function () {
        return this.getAll().length;
    },

    // Setup periodic drops
    // Modified setupPeriodicDrops function for droppers.js
    // This fixes the trail mode by using a flag instead of early returns

    setupPeriodicDrops: function (scene, config) {
        // Default options
        const defaults = {
            getConfig: function () { return {}; },  // Function that returns drop configuration
            cooldown: 4000,                        // Time between drops in ms
            positionMode: 'player',                // 'player', 'random', or 'trail'
            trailInterval: 32,                    // For 'trail' mode, min distance to place new drop
            lastDropPos: { x: 0, y: 0 },           // For 'trail' mode, last position where we dropped
            enabled: true                          // Whether drops are currently enabled
        };

        // Merge provided config with defaults
        const dropperConfig = { ...defaults, ...config };

        // Initialize lastDropPos with player's current position for trail mode
        if (dropperConfig.positionMode === 'trail' && player) {
            dropperConfig.lastDropPos.x = player.x;
            dropperConfig.lastDropPos.y = player.y;
        }

        // Calculate cooldown based on player stats if needed
        let cooldown = dropperConfig.cooldown;
        if (typeof cooldown === 'function') {
            cooldown = cooldown();
        }

        // Create timer to spawn drops
        const timer = scene.time.addEvent({
            delay: cooldown,
            callback: function () {
                // Skip if disabled
                if (!dropperConfig.enabled) return;

                // Skip if game state prevents updates
                if (gameOver || gamePaused) return;

                // Get fresh configuration each time (in case player stats changed)
                const dropConfig = dropperConfig.getConfig();

                // Determine position based on mode
                let x, y;
                let shouldCreateDrop = true; // Flag to determine if we create a drop this cycle

                switch (dropperConfig.positionMode) {
                    case 'random':
                        // Random position on screen without padding
                        x = Phaser.Math.Between(0, game.config.width);
                        y = Phaser.Math.Between(0, game.config.height);
                        break;

                    case 'trail':
                        // Make sure player exists
                        if (!player || !player.active) {
                            shouldCreateDrop = false;
                            break;
                        }

                        // Calculate distance moved since last drop
                        const dx = player.x - dropperConfig.lastDropPos.x;
                        const dy = player.y - dropperConfig.lastDropPos.y;
                        const distanceMoved = Math.sqrt(dx * dx + dy * dy);

                        // Debug info - uncomment if needed for troubleshooting
                        //console.log(`Trail check: moved ${distanceMoved.toFixed(2)}px, need ${dropperConfig.trailInterval}px`);

                        if (distanceMoved >= dropperConfig.trailInterval) {
                            // Far enough to place a new drop
                            x = player.x;
                            y = player.y;

                            // Update last drop position
                            dropperConfig.lastDropPos.x = x;
                            dropperConfig.lastDropPos.y = y;
                        } else {
                            // Not far enough from last drop, skip this cycle
                            shouldCreateDrop = false;
                        }
                        break;

                    case 'player':
                    default:
                        // Place at player position
                        x = player.x;
                        y = player.y;
                        break;
                }

                // Only create the drop if our flag is still true
                if (shouldCreateDrop) {
                    // Assign position to drop config
                    dropConfig.x = x;
                    dropConfig.y = y;

                    // Create the drop
                    DropperSystem.create(scene, dropConfig);
                }
            },
            callbackScope: scene,
            loop: true
        });

        // Register timer for cleanup
        window.registerEffect('timer', timer);

        // Return a controller object
        return {
            timer: timer,
            config: dropperConfig,

            // Enable/disable drops
            setEnabled: function (enabled) {
                dropperConfig.enabled = enabled;
            },

            // Change cooldown
            setCooldown: function (newCooldown) {
                if (timer && timer.delay) {
                    timer.delay = newCooldown;
                    timer.reset({
                        delay: newCooldown,
                        callback: timer.callback,
                        callbackScope: timer.callbackScope,
                        loop: timer.loop
                    });
                }
            }
        };
    },

    // Process drop effect based on type
    processDropEffect: function (scene, drop) {
        // Check symbol to determine effect type
        if (drop.entity.text === '花') { // Flower
            // Fire defensive burst for flowers
            window.createDefensiveBurst(scene, drop.entity.x, drop.entity.y, {
                projectileCount: playerLuck * 2,
                visualEffect: true
            });
        }
        // Can add more effect types here as needed
    },

    // Create a timer for a drop's periodic effect
    createDropEffectTimer: function (scene, drop) {
        // Get cooldown from options or use default
        const baseCooldown = drop.options.periodicEffectCooldown ?? 10000;

        // If drop should fire immediately, process effect now
        if (drop.options.fireImmediately && !drop.hasInitiallyFired) {
            // Mark as having fired to prevent duplicates
            drop.hasInitiallyFired = true;

            // Process effect immediately
            this.processDropEffect(scene, drop);
        }

        // Create timer using CooldownManager
        drop.effectTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: baseCooldown,
            formula: 'sqrt',
            component: drop, // Store reference for easier cleanup
            callback: function () {
                if (gameOver || gamePaused) return;

                // Check if drop still exists
                if (!drop.entity || !drop.entity.active || drop.destroyed) {
                    // Timer will be cleaned up automatically by destroyDrop
                    return;
                }

                // Process the effect
                DropperSystem.processDropEffect(scene, drop);
            },
            callbackScope: scene,
            loop: true
        });
    },

    // Setup system for drops with periodic effects
    setupPeriodicEffectsSystem: function (scene) {
        // Create a timer to periodically check all drops with effects
        const checkTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: 1000, // Check every second
            formula: 'divide',
            callback: function () {
                if (gameOver || gamePaused) return;

                // Get all active drops
                const allDrops = DropperSystem.getAll();

                // Filter for drops with periodic effects
                const dropsWithEffects = allDrops.filter(drop =>
                    drop.options && drop.options.hasPeriodicEffect);

                // Process each drop
                dropsWithEffects.forEach(drop => {
                    // Skip if already destroyed
                    if (drop.destroyed) return;

                    // Initialize effect timer if it doesn't exist
                    if (!drop.effectTimer) {
                        DropperSystem.createDropEffectTimer(scene, drop);
                    }
                });
            },
            callbackScope: scene,
            loop: true
        });

        // Register for cleanup
        window.registerEffect('timer', checkTimer);
    },

    // Enhanced destroyDrop function that cleans up timers
    destroyDrop: function (drop) {
        // Clean up effect timer if it exists
        if (drop.effectTimer) {
            CooldownManager.removeTimer(drop.effectTimer);
            drop.effectTimer = null;
        }

        // Also clean up area effect timer if it exists
        if (drop.areaEffectTimer) {
            CooldownManager.removeTimer(drop.areaEffectTimer);
            drop.areaEffectTimer = null;
        }

        // Destroy the entity if it exists
        if (drop.entity && drop.entity.active) {
            drop.entity.destroy();
        }

        // Mark as destroyed for cleanup
        drop.destroyed = true;
    }
};

function applyVisualEffects(scene, entity, options) {
    if (!options || !window.VisualEffects) return;

    // Check for standard pulsing effect (for backward compatibility)
    if (options.needsPulsing) {
        VisualEffects.createPulsing(scene, entity);
    }

    // Process any effects specified in visualEffect object
    if (options.visualEffect) {
        // If it's a string, assume it's the name of a VisualEffects function
        if (typeof options.visualEffect === 'string') {
            const effectName = options.visualEffect;

            // Check if the effect exists in VisualEffects
            if (typeof VisualEffects[effectName] === 'function') {
                // Handle special case for createPulsing which takes entity directly
                if (effectName === 'createPulsing') {
                    VisualEffects[effectName](scene, entity);
                } else {
                    // Call the effect function with position
                    VisualEffects[effectName](scene, entity.x, entity.y);
                }
            }
        }
        // If it's an object, it should have a type and optionally config
        else if (typeof options.visualEffect === 'object') {
            const effectName = options.visualEffect.type;
            const effectConfig = options.visualEffect.config || {};

            // Check if the effect exists
            if (typeof VisualEffects[effectName] === 'function') {
                // Handle special case for createPulsing which takes entity directly
                if (effectName === 'createPulsing') {
                    VisualEffects[effectName](scene, entity, effectConfig);
                } else {
                    // Call the effect function with position and config
                    VisualEffects[effectName](scene, entity.x, entity.y, effectConfig);
                }
            }
        }
    }
}

// Export for use in other files
window.setupPeriodicEffectsSystem = DropperSystem.setupPeriodicEffectsSystem.bind(DropperSystem);

// Export the system for use in other files
window.DropperSystem = DropperSystem;

// ======= enemy.js =======
// enemy.js - Enemy management system for Word Survivors

// Enemy-related global variables
let enemyCountScaleFactor = 1.25;     // How quickly enemy count increases over time
let enemySpeedFactor = 1.0;           // Global modifier for enemy speed
let currentEnemyRank = 1;             // Current highest enemy rank
let currentEnemyHealth = 40;          // Current base enemy health value

// Boss state tracking
let bossMode = false;
let activeBoss = null;
let bossSpawned = false;

// Rank timing configurations
const rankEnemyStartTimes = {
    1: 0,            // Rank 1 enemies start immediately
    2: 8 * 60,      // Rank 2 enemies start after 10 minutes
    3: 14 * 60,      // Rank 3 after 18 minutes
    4: 20 * 60,      // Rank 4 after 24 minutes
    5: 30 * 60,      // Rank 5 after 30 minutes
    6: 36 * 60       // Rank 6 after 36 minutes
};

// Spawn delay configurations for each rank
const rankSpawnDelays = {
    1: { base: 3000, min: 400 },
    2: { base: 6000, min: 800 },
    3: { base: 12000, min: 1200 },
    4: { base: 16000, min: 2000 },
    5: { base: 20000, min: 3000 },
    6: { base: 24000, min: 4000 }
};

// Enemy System namespace
const EnemySystem = {
    // References to Phaser groups
    enemiesGroup: null,

    // Track spawners for different ranks
    enemySpawners: {},

    // Reference to the active scene
    scene: null,

    // Initialize the enemy system
    initialize: function (scene) {
        // Store scene reference
        this.scene = scene;

        // Create enemy group (or use existing one)
        this.enemiesGroup = scene.physics.add.group();

        // Make global reference available (for backward compatibility)
        window.enemies = this.enemiesGroup;

        // Initialize enemy tier assignments
        initializeEnemyTiers();

        console.log("Enemy system initialized");

        return this;
    },

    // Function to spawn enemy of specific rank
    spawnEnemyOfRank: function (rank) {
        // Skip if game is over
        if (gameOver) return null;

        // Ensure we have a valid scene
        const scene = this.scene;
        if (!scene) return null;

        // Get a random enemy type of this rank
        const enemyType = getRandomEnemyTypeByRank(rank);

        // Get the enemy data with rank defaults applied
        const enemyData = getEnemyData(enemyType);

        // Choose a random spawn position outside the screen
        let x, y;
        if (Math.random() < 0.5) {
            // Spawn on left or right side
            x = Math.random() < 0.5 ? -50 : game.config.width + 50;
            y = Phaser.Math.Between(50, game.config.height - 50);
        } else {
            // Spawn on top or bottom
            x = Phaser.Math.Between(50, game.config.width - 50);
            y = Math.random() < 0.5 ? -50 : game.config.height + 50;
        }

        // Create the enemy with data-driven properties
        const enemy = scene.add.text(x, y, enemyType, {
            fontFamily: 'Arial',
            fontSize: `${enemyData.size}px`,
            color: enemyData.color,
            fontStyle: 'bold'
        }).setOrigin(0.5);

        // Add to physics group
        this.enemiesGroup.add(enemy);

        // Set enemy properties
        enemy.body.setSize(enemy.width, enemy.height);
        enemy.body.setCollideWorldBounds(false);
        enemy.body.setImmovable(false);
        enemy.body.pushable = true;
        enemy.body.setMass(1);
        enemy.body.setDrag(1);
        enemy.body.setBounce(0.5);

        // Set enemy health based on data and current scaling
        enemy.health = Math.ceil(currentEnemyHealth * enemyData.healthMultiplier);

        // Set enemy speed based on data
        enemy.speed = Phaser.Math.Between(enemyData.speedMin, enemyData.speedMax);

        // Store additional properties from data
        enemy.damage = enemyData.damage;
        enemy.rank = enemyData.rank;
        enemy.expValue = enemyData.expValue || 1;

        // Store all language and educational properties
        enemy.kana = enemyData.kana;
        enemy.romaji = enemyData.romaji;
        enemy.english = enemyData.english;

        return enemy;
    },

    // Apply damage to an enemy
    applyDamage: function (source, enemy, damage, cooldownMs = 1000) {
        // Skip if either object is already destroyed
        if (!source.active || !enemy.active) return false;

        // Ensure the cooldown tracking property exists on the enemy
        enemy.lastContactDamage = enemy.lastContactDamage ?? {};

        // Create a unique key for this damage source
        const sourceKey = source.damageSourceId ?? (source.damageSourceId = `damage_${Date.now()}_${Math.random()}`);

        // Check if we're still in the cooldown period for this damage source
        const currentTime = this.scene.time.now;
        if (!enemy.lastContactDamage[sourceKey] || (currentTime - enemy.lastContactDamage[sourceKey] > cooldownMs)) {
            // Apply damage to enemy
            enemy.health -= damage;
            //console.log(enemy.health);
            enemy.lastContactDamage[sourceKey] = currentTime;

            // Show visual damage effect
            this.showDamageEffect(enemy);

            // Check if enemy is defeated
            if (enemy.health <= 0) {
                this.defeatEnemy(enemy);
                return true; // Signal that enemy was defeated
            }

            // If damage was applied and this is the boss, update health bar
            if (enemy.isBoss) {
                this.updateBossHealthBar(enemy);
            }

            return true; // Signal that damage was applied
        }

        return false; // Signal that no damage was applied (cooldown)
    },

    // Handle enemy defeat
    defeatEnemy: function (enemy) {
        // Check if this is the boss
        if (enemy.isBoss) {
            // Handle boss defeat before calling the original method
            this.onBossDefeated();
        }

        // Only show learning feedback for enemies of the current (highest) rank
        if (this.scene.learningFeedback && enemy.rank === currentEnemyRank) {
            // Set white color for this text
            const textColor = '#ffffff';

            // Update the text
            this.scene.learningFeedback.setText(
                `${enemy.text} (${enemy.kana}) [${enemy.romaji}] - ${enemy.english}`
            );

            // Reset scale for animation
            this.scene.learningFeedback.setScale(1);

            // Create subtle scale animation (grow, then back to normal)
            this.scene.tweens.add({
                targets: this.scene.learningFeedback,
                scale: { from: 0.95, to: 1 }, // Grow slightly
                duration: 80, // Fast animation
                ease: 'Sine.easeOut'
            });
        }

        // Destroy the enemy entity
        enemy.destroy();

        // Increment score
        score++;

        // Add experience
        heroExp += enemy.expValue;

        // Update exp bar
        GameUI.updateExpBar(this.scene);
    },

    // Show visual effect for enemy damage
    showDamageEffect: function (enemy) {
        if (!enemy || !enemy.active) return;
        VisualEffects.createDamageFlash(this.scene, enemy);
    },

    // Update the enemy spawners
    updateEnemySpawners: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Check if it's time to spawn the boss (based on elapsed time reaching the boss rank's start time)
        if (!bossSpawned && elapsedTime >= rankEnemyStartTimes[BOSS_CONFIG.max_rank]) {
            console.log("Boss spawn condition met - spawning boss!");
            bossSpawned = true;
            this.spawnBoss();

            // Update currentEnemyRank for consistency
            currentEnemyRank = BOSS_CONFIG.max_rank;

            // Remove any existing spawners for max rank or above
            for (let rank = BOSS_CONFIG.max_rank; rank <= 6; rank++) {
                if (this.enemySpawners[rank]) {
                    console.log(`Removing spawner for rank ${rank}`);
                    this.enemySpawners[rank].remove();
                    delete this.enemySpawners[rank];
                }
            }
        }

        // Process each rank for spawner updates
        Object.keys(rankEnemyStartTimes).forEach(rank => {
            const rankNum = parseInt(rank);

            // Skip ranks at or above max_rank if boss has spawned
            if (bossSpawned && rankNum >= BOSS_CONFIG.max_rank) {
                return;
            }

            const startTime = rankEnemyStartTimes[rank];
            const rankConfig = rankSpawnDelays[rank];

            // Check if this rank's enemies should start spawning yet
            if (elapsedTime >= startTime) {
                // Create a spawner if it doesn't exist
                if (!this.enemySpawners[rank]) {
                    // Create the spawner with initial delay using a single unified spawn function
                    this.enemySpawners[rank] = registerTimer(this.scene.time.addEvent({
                        delay: rankConfig.base,
                        callback: () => { this.spawnEnemyOfRank(rankNum); },
                        callbackScope: this,
                        loop: true
                    }));

                    // If it's not rank 1, show an introduction and update current enemy rank
                    if (rankNum > 1) {
                        this.showRankIntroduction(rankNum);
                    }
                } else {
                    // Update existing spawner's delay based on elapsed time
                    // Calculate time since this rank started
                    const rankMinutesActive = (elapsedTime - startTime) / 60;

                    // Only scale up to 12 minutes of active time for this rank
                    const scalingMinutes = Math.min(12, rankMinutesActive);

                    // Calculate new delay with minimum floor
                    const newSpawnDelay = Math.max(
                        rankConfig.min,
                        rankConfig.base / Math.pow(enemyCountScaleFactor, scalingMinutes)
                    );

                    // Update the timer if needed
                    if (Math.abs(this.enemySpawners[rank].delay - newSpawnDelay) > (this.enemySpawners[rank].delay * 0.1)) {
                        this.enemySpawners[rank].delay = newSpawnDelay;
                        this.enemySpawners[rank].reset({
                            delay: newSpawnDelay,
                            callback: () => { this.spawnEnemyOfRank(rankNum); },
                            callbackScope: this,
                            loop: true
                        });
                    }
                }
            }
        });
    },

    // Show a dramatic introduction when a new rank appears
    showRankIntroduction: function (rank) {
        // Update the current enemy rank when a new rank is introduced
        currentEnemyRank = rank;

        // Threat kanji: 危 (ki) - meaning danger/threat/peril
        const threatKanji = '危';

        // Create a more atmospheric introduction with multiple kanji
        const kanjiCount = 8; // Number of kanji to show
        const duration = 4000; // Total duration: 4 seconds

        // Scale kanji size based on rank
        const baseSize = 128; // Base font size for kanji
        const sizeFactor = Math.min(1.5, 1 + (rank - 1) * 0.25); // Increase size for higher ranks

        // Create multiple kanji at different positions
        for (let i = 0; i < kanjiCount; i++) {
            // Calculate random position weighted toward the center
            const randomAngle = Math.random() * Math.PI * 2;
            const randomDistance = Math.random() * 300 + 100;

            const x = game.config.width / 2 + Math.cos(randomAngle) * randomDistance;
            const y = game.config.height / 2 + Math.sin(randomAngle) * randomDistance;

            // Randomize appearance time within the duration
            const delay = Math.random() * 3000; // Random delay up to 3 seconds

            // Create the kanji text with varying properties
            const kanji = this.scene.add.text(x, y, threatKanji, {
                fontFamily: 'Arial',
                fontSize: `${baseSize * sizeFactor}px`,
                color: '#ff0000',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);

            // Set initial alpha to 0
            kanji.setAlpha(0);

            // Fast fade in then fast fade out - total 1 second per kanji
            this.scene.tweens.add({
                targets: kanji,
                alpha: { from: 0, to: 0.7 }, // Not fully opaque
                scale: { from: 0.8, to: 1.2 },
                duration: 500, // 0.5 second fade in
                delay: delay,
                ease: 'Sine.easeInOut',
                onComplete: () => {
                    this.scene.tweens.add({
                        targets: kanji,
                        alpha: { from: 0.7, to: 0 },
                        scale: { from: 1.2, to: 1.5 },
                        duration: 500, // 0.5 second fade out
                        ease: 'Sine.easeInOut',
                        onComplete: () => {
                            kanji.destroy();
                        }
                    });
                }
            });
        }

        // After all kanji effects, show rank name briefly
        // Get the rank name from bestiary.js
        const rankName = ENEMY_RANK_NAMES[rank] || `${rank}`;

        // Wait for most of the kanji to appear, then show the rank
        this.scene.time.delayedCall(2500, () => {
            const rankText = this.scene.add.text(game.config.width / 2, game.config.height / 2, rankName, {
                fontFamily: 'Arial',
                fontSize: '200px',
                color: '#ff0000',
                stroke: '#000000',
                strokeThickness: 8
            }).setOrigin(0.5);
            rankText.setAlpha(0);

            // Dramatic appearance of the rank number
            this.scene.tweens.add({
                targets: rankText,
                alpha: { from: 0, to: 0.9 },
                scale: { from: 0.5, to: 1.2 },
                duration: 800,
                ease: 'Cubic.easeOut',
                onComplete: () => {
                    this.scene.tweens.add({
                        targets: rankText,
                        alpha: { from: 0.9, to: 0 },
                        scale: { from: 1.2, to: 1.5 },
                        duration: 700,
                        delay: 300,
                        ease: 'Cubic.easeIn',
                        onComplete: () => {
                            rankText.destroy();
                        }
                    });
                }
            });
        });
    },

    // Initialize enemy spawners
    initializeEnemySpawners: function () {
        // Clean up any existing spawners
        Object.values(this.enemySpawners).forEach(spawner => {
            if (spawner) {
                spawner.remove();
            }
        });

        // Reset the spawners object
        this.enemySpawners = {};

        // Rank 1 spawner will be created in the first update
        // Other ranks will be created when their time comes
    },

    // Update all enemies (movement, etc.)
    updateEnemies: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Get all active enemies
        const activeEnemies = this.enemiesGroup.getChildren();

        // Update each enemy
        activeEnemies.forEach(enemy => {
            // Ensure enemy and its body are valid and active
            if (enemy && enemy.active && enemy.body) {
                // Target position (player)
                const targetX = player.x;
                const targetY = player.y;

                // Vector from enemy to player
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;

                // Distance to player
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Define the maximum speed the enemy should reach.
                // Use the 'speed' property we assigned during spawn.
                const maxSpeed = enemy.speed * enemySpeedFactor;

                // Define the acceleration rate
                const accelerationRate = maxSpeed * 8;

                // Avoid division by zero and applying acceleration if already very close
                if (distance > 1) { // Small threshold (1 pixel)
                    // Normalize the direction vector
                    const dirX = dx / distance;
                    const dirY = dy / distance;

                    // Calculate acceleration components based on direction and rate
                    const accelX = dirX * accelerationRate;
                    const accelY = dirY * accelerationRate;

                    // Apply the calculated acceleration
                    enemy.body.setAcceleration(accelX, accelY);
                } else {
                    // If very close, stop accelerating
                    enemy.body.setAcceleration(0, 0);
                }

                // Manually cap speed
                const velocity = enemy.body.velocity;
                const currentSpeedSq = velocity.lengthSq(); // Use squared length for efficiency

                if (currentSpeedSq > maxSpeed * maxSpeed) {
                    // If current speed squared exceeds max speed squared, scale velocity back
                    const currentSpeed = Math.sqrt(currentSpeedSq);
                    const scale = maxSpeed / currentSpeed;

                    // Apply the scale factor to the velocity components
                    enemy.body.setVelocity(velocity.x * scale, velocity.y * scale);
                }
            }
        });
    },

    // Count enemies by rank
    countEnemiesByRank: function (rank) {
        return this.enemiesGroup.getChildren().filter(enemy =>
            enemy && enemy.active && enemy.rank === rank
        ).length;
    },

    // Get total enemy count
    getEnemyCount: function () {
        return this.enemiesGroup.getChildren().filter(enemy =>
            enemy && enemy.active
        ).length;
    },

    spawnBoss: function () {
        // Get the scene
        const scene = this.scene;
        if (!scene) return null;

        // Choose a random boss type from the highest rank
        const bossType = getRandomEnemyTypeByRank(BOSS_CONFIG.max_rank);

        // Get the enemy data
        const enemyData = getEnemyData(bossType);

        // Spawn position (center of screen)
        const x = game.config.width / 2;
        const y = -250;

        // Create the boss with data-driven properties
        const boss = scene.add.text(x, y, bossType, {
            fontFamily: 'Arial',
            fontSize: `${enemyData.size}px`,
            color: enemyData.color,
            fontStyle: 'bold'
        }).setOrigin(0.5);

        // Add to physics group
        this.enemiesGroup.add(boss);

        // Set physics properties
        boss.body.setSize(boss.width, boss.height);
        boss.body.setCollideWorldBounds(false);
        boss.body.setImmovable(false);
        boss.body.pushable = true;
        boss.body.setMass(4);  // Make boss harder to push
        boss.body.setDrag(1);
        boss.body.setBounce(0.5);

        // Calculate boss health (normal health * boss multiplier)
        boss.health = Math.ceil(currentEnemyHealth * enemyData.healthMultiplier * BOSS_CONFIG.health_multiplier);
        boss.maxHealth = boss.health; // Store max health for UI bar

        // Set boss speed to fixed value from config
        boss.speed = BOSS_CONFIG.speed;

        // Store additional properties from data
        boss.damage = enemyData.damage;
        boss.rank = enemyData.rank;
        boss.expValue = enemyData.expValue;

        // Store all language and educational properties
        boss.kana = enemyData.kana;
        boss.romaji = enemyData.romaji;
        boss.english = enemyData.english;

        // Mark as boss for special handling
        boss.isBoss = true;

        // Store reference to active boss
        activeBoss = boss;

        // Set background to boss mode
        if (window.BackgroundAnimationSystem) BackgroundAnimationSystem.setBossMode(true);

        // Set music to boss mode
        MusicSystem.applyBossFightEffect();

        // Update UI to show boss name and health
        this.showBossUI(boss);

        return boss;
    },

    // Show boss UI (name and health bar)
    showBossUI: function (boss) {
        const scene = this.scene;
        if (!scene) return;

        // Store the original feedback text if we need to restore it later
        if (scene.learningFeedback && !scene.originalFeedbackText) {
            scene.originalFeedbackText = scene.learningFeedback.text;
        }

        // Update learning feedback to show boss info
        if (scene.learningFeedback) {
            scene.learningFeedback.setText(
                `${boss.text} (${boss.kana}) [${boss.romaji}] - ${boss.english}`
            );
        }

        // Create boss health bar
        this.createBossHealthBar(scene);

        // Update health bar to full
        this.updateBossHealthBar(boss);
    },

    // Create boss health bar elements
    createBossHealthBar: function (scene) {
        // Clean up existing health bar if any
        if (scene.bossHealthBar) {
            scene.bossHealthBar.destroy();
        }
        if (scene.bossHealthBarBg) {
            scene.bossHealthBarBg.destroy();
        }
        if (scene.bossHealthBarBorder) {
            scene.bossHealthBarBorder.destroy();
        }

        // Get dimensions from UI health bar constants for consistency
        const kajisuliScale = (typeof KAJISULI_MODE !== 'undefined' && KAJISULI_MODE) ? 1.5 : 1;
        const width = UI.healthBar.width() * kajisuliScale;
        const height = UI.healthBar.height();
        const borderWidth = UI.healthBar.borderWidth;
        const innerMargin = UI.healthBar.innerMargin;
        const centerX = UI.healthBar.centerX();
        const y = game.config.height * 0.9125; // 730/800 = 0.9125 -- Position near the bottom for boss health bar

        // Create gold border with black background (like the player health bar)
        scene.bossHealthBarBorder = scene.add.rectangle(
            centerX,
            y,
            width + (borderWidth * 2),
            height + (borderWidth * 2),
            UI.colors.gold
        ).setDepth(100);

        // Create inner black background
        scene.bossHealthBarBg = scene.add.rectangle(
            centerX,
            y,
            width,
            height,
            UI.colors.black
        ).setDepth(100);

        // Calculate the starting position for the health bar (accounting for margin)
        const startX = centerX - (width / 2) + innerMargin;

        // Create health bar foreground (initially full)
        scene.bossHealthBar = scene.add.rectangle(
            startX,
            y,
            width - (innerMargin * 2), // Account for margin on both sides
            height - (innerMargin * 2), // Account for margin on both sides
            0xff0000 // Red color for health
        ).setOrigin(0, 0.5).setDepth(101);
    },

    // Update boss health bar based on current health
    updateBossHealthBar: function (boss) {
        const scene = this.scene;
        if (!scene || !scene.bossHealthBar || !boss) return;

        // Calculate health percentage
        const healthPercent = boss.health / boss.maxHealth;

        // Get width from UI health bar constants (minus margins)
        const kajisuliScale = (typeof KAJISULI_MODE !== 'undefined' && KAJISULI_MODE) ? 1.5 : 1;
        const fullWidth = UI.healthBar.width() * kajisuliScale - (UI.healthBar.innerMargin * 2);

        // Update health bar width based on percentage
        scene.bossHealthBar.width = fullWidth * healthPercent;
    },

    // Handle boss defeat
    onBossDefeated: function () {
        const scene = this.scene;
        if (!scene) return;

        // Reset background to normal
        if (window.BackgroundAnimationSystem) BackgroundAnimationSystem.setBossMode(false);

        // Reset music to normal
        MusicSystem.removeBossFightEffect();

        // End the game with victory
        this.showVictoryScreen();

        // Clean up all boss-related UI objects thoroughly
        this.cleanupBossUI(scene);

        // Reset boss state
        bossMode = false;
        activeBoss = null;
    },

    cleanupBossUI: function (scene) {
        // Clean up health bar elements
        if (scene.bossHealthBar) {
            scene.bossHealthBar.destroy();
            scene.bossHealthBar = null;
        }
        if (scene.bossHealthBarBg) {
            scene.bossHealthBarBg.destroy();
            scene.bossHealthBarBg = null;
        }
        if (scene.bossHealthBarBorder) {
            scene.bossHealthBarBorder.destroy();
            scene.bossHealthBarBorder = null;
        }

        // Restore original feedback text if needed
        if (scene.learningFeedback && scene.originalFeedbackText) {
            scene.learningFeedback.setText(scene.originalFeedbackText);
            scene.originalFeedbackText = null;
        }
    },

    // Show victory screen
    showVictoryScreen: function () {
        const scene = this.scene;
        if (!scene) return;

        // Set game over state
        gameOver = true;

        // Pause the game physics to stop all movement
        PauseSystem.pauseGame();

        // Show victory screen using our new GameEndMenu
        window.GameEndMenu.showVictoryScreen(scene);

        // Old code - legacy support for direct DOM elements
        // This can be removed once the new GameEndMenu is fully integrated
        if (typeof gameOverText !== 'undefined' && gameOverText.setVisible) {
            gameOverText.setVisible(false);
        }
        if (typeof restartButton !== 'undefined' && restartButton.setVisible) {
            restartButton.setVisible(false);
        }
    },

    // Reset the enemy system
    reset: function () {
        // Clear existing enemies
        if (this.enemiesGroup) {
            this.enemiesGroup.clear(true, true);
        }

        // Clean up spawners
        Object.values(this.enemySpawners).forEach(spawner => {
            if (spawner) {
                spawner.remove();
            }
        });

        // Reset spawners
        this.enemySpawners = {};

        // Reset boss-related state
        bossMode = false;
        activeBoss = null;
        bossSpawned = false;

        // Reset backgrounds
        if (window.BackgroundAnimationSystem) BackgroundAnimationSystem.setBossMode(false);


        // Clean up any boss UI elements
        const scene = this.scene;
        if (scene) {
            this.cleanupBossUI(scene);
        }

        // Reset enemy rank
        currentEnemyRank = 1;

        // Initialize enemy tiers with dynamic assignments
        initializeEnemyTiers();

        console.log("Enemy system reset");
    }
};

// Export the system for use in other files
window.EnemySystem = EnemySystem;

// Export the enemy-related variables for global access
window.enemyCountScaleFactor = enemyCountScaleFactor;
window.enemySpeedFactor = enemySpeedFactor;
window.currentEnemyRank = currentEnemyRank;
window.currentEnemyHealth = currentEnemyHealth;
window.rankEnemyStartTimes = rankEnemyStartTimes;
window.rankSpawnDelays = rankSpawnDelays;

// Make boss variables accessible globally
window.bossMode = bossMode;
window.activeBoss = activeBoss;
window.bossSpawned = bossSpawned;
window.BOSS_CONFIG = BOSS_CONFIG;

// Setter functions to modify variables
EnemySystem.setEnemyCountScaleFactor = function (value) {
    enemyCountScaleFactor = value;
    window.enemyCountScaleFactor = value;
};

EnemySystem.setEnemySpeedFactor = function (value) {
    enemySpeedFactor = value;
    window.enemySpeedFactor = value;
};

EnemySystem.setCurrentEnemyHealth = function (value) {
    currentEnemyHealth = value;
    window.currentEnemyHealth = value;
};

// Legacy wrapper function for backward compatibility
window.applyContactDamage = function (source, enemy, damage, cooldownMs = 1000) {
    if (!EnemySystem.scene) {
        // If not initialized, use this as scene context
        EnemySystem.scene = this;
    }

    return EnemySystem.applyDamage(source, enemy, damage, cooldownMs);
};

// Direct function to spawn enemies (for easy referencing)
window.spawnEnemyOfRank = function (rank) {
    return EnemySystem.spawnEnemyOfRank(rank);
};

// ======= entrapments.js =======
// Maps perks to dropper effects like landmines and traps

// Registry system for dropper perks
const DropperPerkRegistry = {
    // Map perks to their dropper configurations
    perkDropperConfigs: {},

    // Register a perk that creates drops
    registerDropperPerk: function (perkId, config) {
        this.perkDropperConfigs[perkId] = {
            getConfig: config.getConfig ?? function () { return {}; }, // Function that returns drop config
            cooldown: config.cooldown ?? 4000,                        // Cooldown between drops
            positionMode: config.positionMode ?? 'player',            // How drops are positioned
            activationMethod: config.activationMethod ?? 'periodic'   // How drops are created
        };
    },

    // Apply a perk's dropper effect
    applyDropperPerk: function (scene, perkId) {
        // Check if we have a configuration for this perk
        const perkConfig = this.perkDropperConfigs[perkId];
        if (!perkConfig) return false;

        console.log(`Applying dropper perk: ${perkId}`);

        // Handle different activation methods
        switch (perkConfig.activationMethod) {
            case 'immediate':
                // Create a single drop immediately
                const dropConfig = perkConfig.getConfig();
                dropConfig.x = player.x;
                dropConfig.y = player.y;
                DropperSystem.create(scene, dropConfig);
                break;

            case 'periodic':
                // Set up periodic drops
                return DropperSystem.setupPeriodicDrops(scene, {
                    getConfig: perkConfig.getConfig,
                    cooldown: perkConfig.cooldown,
                    positionMode: perkConfig.positionMode,
                });

            default:
                console.log(`Unknown activation method: ${perkConfig.activationMethod}`);
                return false;
        }

        return true;
    }
};

// Register the Amber Beetle perk (landmines)
DropperPerkRegistry.registerDropperPerk('AMBER_BEETLE', {
    getConfig: function () {
        const amberDamage = playerDamage * 2;

        return {
            symbol: '★',
            color: '#ffbf00', // Amber color
            fontSize: getEffectiveSize(projectileSizeFactor, amberDamage),
            behaviorType: 'projectile',
            damage: amberDamage,
            lifespan: null,
            options: {
                visualEffect: 'createPulsing'
            }
        };
    },
    cooldown: function () {
        // Calculate cooldown based on Agility
        return 4000 / (Math.sqrt(playerFireRate / BASE_STATS.AGI));
    },
    positionMode: 'player',
    activationMethod: 'periodic'
});

// Function to activate the Amber Beetle perk (landmines)
// This replaces the activateLandmines function in index.html
window.activateLandmines = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (scene) {
        // Apply the dropper perk
        DropperPerkRegistry.applyDropperPerk(scene, 'AMBER_BEETLE');
    }
};

DropperPerkRegistry.registerDropperPerk('MAGMA_FLOOR', {
    getConfig: function () {
        return {
            symbol: '熔', // Kanji for "magma/melting"
            color: '#FF4400', // Orange-red color for magma
            fontSize: 64, // Very large size as requested
            behaviorType: 'persistent', // Persistent type to stay and deal damage
            damage: playerDamage, // Full player damage
            damageInterval: 1000, // 1 second between damage applications
            lifespan: playerLuck * 1000, // Lasts for playerLuck seconds
            options: {
                visualEffect: 'createPulsing', // Add pulsing animation for better visibility
                opacity: 0.8 // Slightly transparent
            }
        };
    },
    cooldown: function () {
        // Base cooldown is 8 seconds, scaled by player luck
        return 8000 / (Math.sqrt(playerLuck / BASE_STATS.LUK));
    },
    positionMode: 'player', // Drop at player position
    activationMethod: 'periodic' // Periodically create magma floors
});

// Function to activate the MAGMA_FLOOR perk
window.activateMagmaFloor = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a magma floor configuration
    const magmaConfig = DropperPerkRegistry.perkDropperConfigs['MAGMA_FLOOR'].getConfig();

    // Create the first magma floor immediately
    magmaConfig.x = player.x;
    magmaConfig.y = player.y;
    DropperSystem.create(scene, magmaConfig);

    // Apply the dropper perk for future magma floors
    return DropperPerkRegistry.applyDropperPerk(scene, 'MAGMA_FLOOR');
};

// Register the Green Dream perk (afterimages)
DropperPerkRegistry.registerDropperPerk('GREEN_DREAM', {
    getConfig: function () {
        return {
            symbol: HERO_CHARACTER, // Use the player's character (dynamically)
            color: '#00cc66', // Green color
            fontSize: 32, // Same size as player
            initialScale: 1, // Start at full size (no grow animation)
            behaviorType: 'persistent', // Deals continuous damage on overlap
            damage: playerDamage,
            damageInterval: 500, // Half second between damage applications
            lifespan: playerLuck * 1000, // Last for playerLuck seconds
            options: {
                opacity: 0.5 // Half opacity
            }
        };
    },
    cooldown: 2000, // Drop a new afterimage every 2 seconds
    positionMode: 'player', // Drop at player position
    activationMethod: 'periodic'
});

// Function to activate the Green Dream perk (afterimages)
// This replaces the activateAfterImages function in index.html
window.activateAfterImages = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the dropper perk
    DropperPerkRegistry.applyDropperPerk(scene, 'GREEN_DREAM');
};

// Register the Blooming Flower perk
DropperPerkRegistry.registerDropperPerk('BLOOMING_FLOWER', {
    getConfig: function () {
        return {
            symbol: '花', // Kanji for "flower"
            color: '#FF66AA', // Pink color for flower
            fontSize: 24, // Smaller size as requested
            behaviorType: 'projectile', // Dies on enemy contact
            damage: playerDamage, // Full player damage on contact
            lifespan: null, // Indefinite lifespan until touched by enemy
            options: {
                hasPeriodicEffect: true, // Generic flag for drops with periodic effects
                periodicEffectCooldown: 4000, // Base cooldown for the effect
                fireImmediately: true, // Flag to indicate it should fire immediately on spawn
                visualEffect: 'createPulsing' // Flag for visual pulsing effect
            }
        };
    },
    cooldown: function () {
        // Base 31 second cooldown, scaled by luck
        return 31000 / (Math.sqrt(playerLuck / BASE_STATS.LUK));
    },
    positionMode: 'random', // Random position on screen
    activationMethod: 'periodic' // Periodically spawn flowers
});

// Function to activate the Blooming Flower perk
window.activateBloomingFlower = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Setup periodic effects for drops (only needs to be done once)
    setupPeriodicEffectsSystem(scene);

    // Create a flower configuration
    const flowerConfig = DropperPerkRegistry.perkDropperConfigs['BLOOMING_FLOWER'].getConfig();

    // Explicitly set random position for the first flower
    flowerConfig.x = Phaser.Math.Between(0, game.config.width);
    flowerConfig.y = Phaser.Math.Between(0, game.config.height);

    // Create the first flower immediately
    DropperSystem.create(scene, flowerConfig);

    // Apply the dropper perk for future flowers
    const controller = DropperPerkRegistry.applyDropperPerk(scene, 'BLOOMING_FLOWER');

    return controller;
};

// Register a simple Area Effect Perk for testing
// Updated area effect perk with custom color
DropperPerkRegistry.registerDropperPerk('AREA_PULSE', {
    getConfig: function () {
        return {
            symbol: '◯', // Simple circle symbol
            color: '#ff00ff', // Magenta color for the symbol
            fontSize: 24,
            behaviorType: 'areaEffect', // Use the area effect behavior
            damage: playerDamage * 5, // 5x player damage per pulse
            damageInterval: 0, // Not used for area effects
            lifespan: null, // 
            options: {
                areaEffectInterval: 6000, // Pulse every 2 seconds
                areaEffectRadius: 400, // 400px radius
                pulseColor: 0xff00ff // Magenta color for the pulse effect
            }
        };
    },
    cooldown: 3500, // 15 seconds between drops
    positionMode: 'player', // Drop at player position
    activationMethod: 'periodic' // Periodically create pulses
});

// Function to activate the Area Pulse perk
window.activateAreaPulse = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the dropper perk
    DropperPerkRegistry.applyDropperPerk(scene, 'AREA_PULSE');
};

// Register the perk with DropperPerkRegistry in entrapments.js
DropperPerkRegistry.registerDropperPerk('POISON_FLOWER', {
    getConfig: function () {
        return {
            symbol: '毒', // Kanji for "poison"
            color: '#2aad27', // Green color for poison
            fontSize: 28, // Medium size
            behaviorType: 'areaEffect', // Use area effect behavior
            damage: playerDamage * 1,
            damageInterval: 0, // Not used for area effects
            lifespan: null, // Permanent until touched by enemy
            options: {
                areaEffectInterval: 8000, //
                areaEffectRadius: 320, // Base radius
                pulseColor: 0x2aad27, // Green color for the pulse effect
                visualEffect: 'createPulsing', // Add pulsing animation
                effectComponent: 'poisonEffect' // Use the poisonEffect component
            }
        };
    },
    cooldown: function () {
        // Base 15 second cooldown, scaled by luck
        return 15000 / (Math.sqrt(playerLuck / BASE_STATS.LUK));
    },
    positionMode: 'random', // Random position on screen
    activationMethod: 'periodic' // Periodically create poison flowers
});

// Function to activate the poison flower perk
window.activatePoisonFlower = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a flower configuration
    const flowerConfig = DropperPerkRegistry.perkDropperConfigs['POISON_FLOWER'].getConfig();

    // Explicitly set random position for the first flower
    flowerConfig.x = Phaser.Math.Between(0, game.config.width);
    flowerConfig.y = Phaser.Math.Between(0, game.config.height);

    // Create the first flower immediately
    DropperSystem.create(scene, flowerConfig);

    // Apply the dropper perk for future flowers
    return DropperPerkRegistry.applyDropperPerk(scene, 'POISON_FLOWER');
};

DropperPerkRegistry.registerDropperPerk('COLD_FLOWER', {
    getConfig: function () {
        return {
            symbol: '冷', // Kanji for "cold"
            color: '#00ffff', // Cyan color for frost
            fontSize: 28, // Medium size
            behaviorType: 'areaEffect', // Use area effect behavior
            damage: playerDamage,
            damageInterval: 0, // Not used for area effects
            lifespan: null, // Permanent until touched by enemy
            options: {
                areaEffectInterval: 7000, //
                areaEffectRadius: 240, //
                pulseColor: 0x00ffff, // Cyan color for the pulse effect
                visualEffect: 'createPulsing', // Add pulsing animation
                effectComponent: 'slowEffect' // Use the slowEffect component
            }
        };
    },
    cooldown: function () {
        // Base 12 second cooldown, scaled by luck
        return 20000 / (Math.sqrt(playerLuck / BASE_STATS.LUK));
    },
    positionMode: 'random', // Random position on screen
    activationMethod: 'periodic' // Periodically create frost flowers
});

// Function to activate the Cold Flower perk
window.activateColdFlower = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a flower configuration
    const flowerConfig = DropperPerkRegistry.perkDropperConfigs['COLD_FLOWER'].getConfig();

    // Explicitly set random position for the first flower
    flowerConfig.x = Phaser.Math.Between(0, game.config.width);
    flowerConfig.y = Phaser.Math.Between(0, game.config.height);

    // Create the first flower immediately
    DropperSystem.create(scene, flowerConfig);

    // Apply the dropper perk for future flowers
    return DropperPerkRegistry.applyDropperPerk(scene, 'COLD_FLOWER');
};

DropperPerkRegistry.registerDropperPerk('FROST_SHRAPNEL', {
    getConfig: function () {
        return {
            symbol: '氷',  // Kanji for "ice"
            color: '#00FFFF', // Cyan color for frost
            fontSize: 16, // Medium size for visibility
            behaviorType: 'projectile', // Projectile type as requested
            damage: playerDamage * 0.2, // 1/5th of player damage
            damageInterval: 1000, // 1 second between damage applications
            lifespan: null, // Permanent until destroyed
            options: {
                effectComponent: 'slowEffect' // Apply slow effect like Azure Frost
            }
        };
    },
    cooldown: function () {
        // Base cooldown is 4 seconds, scaled by player fire rate
        return 4000 / (Math.sqrt(playerFireRate / BASE_STATS.AGI));
    },
    positionMode: 'player', // Drop at player position
    activationMethod: 'periodic' // Periodically create shrapnel
});

// Function to activate the FROST_SHRAPNEL perk
window.activateFrostShrapnel = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a shrapnel configuration
    const shrapnelConfig = DropperPerkRegistry.perkDropperConfigs['FROST_SHRAPNEL'].getConfig();

    // Create the first shrapnel immediately
    shrapnelConfig.x = player.x;
    shrapnelConfig.y = player.y;
    DropperSystem.create(scene, shrapnelConfig);

    // Apply the dropper perk for future shrapnel pieces
    return DropperPerkRegistry.applyDropperPerk(scene, 'FROST_SHRAPNEL');
};

// Register TOXIC_TRAIL perk with DropperPerkRegistry
DropperPerkRegistry.registerDropperPerk('TOXIC_TRAIL', {
    getConfig: function () {
        return {
            symbol: '毒', // Kanji for "toxic"
            color: '#33cc33', // Green color for poison theme
            fontSize: 16, // Small size for trail elements
            behaviorType: 'projectile', // Dies on enemy contact
            damage: playerDamage * 0.5,
            lifespan: Math.ceil(4000 * Math.sqrt(playerLuck / BASE_STATS.LUK)), // 4 seconds * luck factor
            options: {
                effectComponent: 'poisonEffect', // Apply poison effect component
                visualEffect: 'createPulsing' // Add pulsing visual effect
            }
        };
    },
    cooldown: 200, // Fixed 200ms cooldown (very fast)
    positionMode: 'trail', // Follow player's movement
    trailInterval: 32, // Minimum 32px distance between drops
    activationMethod: 'periodic' // Periodically create drops
});

// Function to activate the TOXIC_TRAIL perk
window.activateToxicTrail = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a trail configuration
    const trailConfig = DropperPerkRegistry.perkDropperConfigs['TOXIC_TRAIL'].getConfig();

    // Explicitly set initial position to player's position
    trailConfig.x = player.x;
    trailConfig.y = player.y;

    // Create the first drop immediately
    DropperSystem.create(scene, trailConfig);

    // Apply the dropper perk for future trail elements
    return DropperPerkRegistry.applyDropperPerk(scene, 'TOXIC_TRAIL');
};

// Export the registry for use in other files
window.DropperPerkRegistry = DropperPerkRegistry;

// ======= familiars.js =======
// Enhanced Familiar System for Word Survivors
// Manages orbital entities that have firing behavior

// Registry for different familiar behaviors
const FamiliarBehaviors = {
    // Sniper behavior - fires high-damage shots at random enemies
    sniper: function (scene, orbital, time) {
        // Calculate shot properties (can be moved to config)
        const damage = playerDamage * 2;
        const speed = 800; // 2x normal speed
        const projectileColor = '#FF55AA';

        // Find a random enemy to target
        const target = findRandomVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            fireFamiliarProjectile(scene, orbital, target, {
                damage: damage,
                speed: speed,
                color: projectileColor
            });

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    // Copy behavior - fires weaker shots at the closest enemy
    copy: function (scene, orbital, time) {
        // Calculate shot properties
        const damage = playerDamage * 0.5; // Half player damage


        // Find the closest enemy to the player
        const target = findClosestVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            fireFamiliarProjectile(scene, orbital, target, {
                damage: damage
            });

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    cold: function (scene, orbital, time) {
        // Calculate shot properties
        const damage = playerDamage * 0.5; // Half player damage
        const projectileColor = '#00FFFF'; // Cyan color for cold theme

        // Find the closest enemy to the player
        const target = findClosestVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            const projectile = fireFamiliarProjectile(scene, orbital, target, {
                damage: damage,
                color: projectileColor
            });

            // Add slow effect component to the projectile
            if (projectile) {
                ProjectileComponentSystem.addComponent(projectile, 'slowEffect');
            }

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    // fun behavior - fires random effect projectiles
    fun: function (scene, orbital, time) {
        // Calculate shot properties
        const damage = playerDamage * 0.5; // Half player damage
        const speed = 400; // Normal speed

        // Available effect components with their colors
        const availableEffects = [
            { component: 'slowEffect', color: '#00FFFF' },         // Cyan for slow
            { component: 'poisonEffect', color: '#2AAD27' },       // Green for poison
            { component: 'fireEffect', color: '#FF4500' },         // Orange-red for fire
            { component: 'explosionEffect', color: '#FF9500' },    // Amber for explosion
            { component: 'splitEffect', color: '#1E90FF' }          // Blue for split
        ];

        // Select a random effect
        const randomEffect = availableEffects[Math.floor(Math.random() * availableEffects.length)];

        // Find a random enemy to target
        const target = findRandomVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            const projectile = fireFamiliarProjectile(scene, orbital, target, {
                damage: damage,
                color: randomEffect.color, // Color based on effect
                symbol: randomEffect.symbol // Symbol based on effect
            });

            // Add the selected effect component to the projectile
            if (projectile) {
                ProjectileComponentSystem.addComponent(projectile, randomEffect.component);
            }

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    // Berserk behavior - fires at random enemies at higher rate
    berserk: function (scene, orbital, time) {
        // Calculate shot properties
        const damage = playerDamage * 0.5; // Half player damage
        const speed = 400; // Faster than normal

        // Find a random enemy to target
        const target = findRandomVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            fireFamiliarProjectile(scene, orbital, target, {
                damage: damage
            });

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    healer: function (scene, orbital, time) {
        // Calculate shot properties
        const damage = playerDamage * 0.5; // Half player damage
        const projectileColor = '#00ff00'; // Light green color
        const projectileSymbol = '癒'; // Healing kanji

        // Find the closest enemy
        const target = findClosestVisibleEnemy(scene);

        // If a target was found, fire at it
        if (target) {
            // Create projectile with custom properties
            const projectile = fireFamiliarProjectile(scene, orbital, target, {
                damage: damage,
                color: projectileColor,
                symbol: projectileSymbol
            });

            // Add healing effect component to the projectile
            if (projectile) {
                ProjectileComponentSystem.addComponent(projectile, 'healingAuraEffect');
            }

            return true; // Shot fired successfully
        }

        return false; // No shot fired
    },

    finger: function (scene, orbital, time, options = {}) {
        // Default options
        const defaults = {
            damage: playerDamage,    // Default to full damage
            speed: 1000,             // Very fast speed
            color: '#FFFF00',        // Default to yellow
            symbol: '　',             // Invisible character by default
            componentName: null      // No component by default
        };

        // Merge with provided options
        const config = { ...defaults, ...options };

        // We don't need a target since we fire in the direction the orbital is facing
        // Use the standard firing method but with an angle instead of a target

        // Calculate the angle from the orbital's angle property (set by directionFollowing)
        const angle = orbital.angle;

        // Create the projectile using the standard function
        const projectile = fireFamiliarProjectile(scene, orbital, null, {
            damage: config.damage,
            color: config.color,
            symbol: config.symbol,
            speed: config.speed,
            // Override the angle calculation since we're not targeting an enemy
            overrideAngle: angle
        });

        // Add piercing component
        if (projectile) {
            ProjectileComponentSystem.addComponent(projectile, 'piercingEffect');
        }

        // Add any additional component that was specified
        if (projectile && config.componentName &&
            ProjectileComponentSystem.componentTypes[config.componentName]) {
            ProjectileComponentSystem.addComponent(projectile, config.componentName);
        }

        return true; // Shot fired successfully
    },

    deathFinger: function (scene, orbital, time) {
        return FamiliarBehaviors.finger(scene, orbital, time, {
            damage: playerDamage,
            speed: 1000,
            color: '#FFFF00',
            symbol: '　',
            componentName: null
        });
    },

    // Add a new decayFinger behavior that uses the generic finger
    decayFinger: function (scene, orbital, time) {
        return FamiliarBehaviors.finger(scene, orbital, time, {
            damage: playerDamage * 0.5,
            speed: 1000,
            color: '#FFFF00',
            symbol: '　',
            componentName: 'poisonEffect'
        });
    },
};

// Helper function to find a random visible enemy within a maximum distance
function findRandomVisibleEnemy(scene, maxDistance = 400) {
    // Get all active enemies 
    const activeEnemies = EnemySystem.enemiesGroup.getChildren().filter(enemy => {
        if (!enemy || !enemy.active) return false;

        // If maxDistance is specified, check distance from player
        if (maxDistance !== Infinity) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= maxDistance;
        }

        return true;
    });

    // Return a random enemy from the list, or null if none found
    if (activeEnemies.length === 0) return null;

    return Phaser.Utils.Array.GetRandom(activeEnemies);
}

// Helper function to find the closest visible enemy to the player within a maximum distance
function findClosestVisibleEnemy(scene, maxDistance = 400) {
    // Get all active enemies
    const activeEnemies = EnemySystem.enemiesGroup.getChildren().filter(enemy => {
        return enemy && enemy.active;
    });

    if (activeEnemies.length === 0) return null;

    let closestEnemy = null;
    let closestDistance = maxDistance;

    // Find the closest enemy to the player
    activeEnemies.forEach(enemy => {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < closestDistance) {
            closestDistance = distance;
            closestEnemy = enemy;
        }
    });

    return closestEnemy;
}


// Helper function to fire a projectile from a familiar
function fireFamiliarProjectile(scene, orbital, target, options = {}) {
    // Default options
    const config = {
        damage: playerDamage * 0.5, // Default to half player damage for familiars
        speed: 400,
        color: '#ffff00',
        symbol: '★',
        ...options
    };

    // Calculate direction to the target or use overrideAngle if provided
    const angle = target ? Phaser.Math.Angle.Between(
        orbital.entity.x, orbital.entity.y,
        target.x, target.y
    ) : config.overrideAngle ?? 0; // Use overrideAngle or default to 0

    // Calculate the appropriate size based on the actual damage
    const familiarProjectileSize = getEffectiveSize(projectileSizeFactor, config.damage);

    // Create the projectile using WeaponSystem
    const projectile = WeaponSystem.createProjectile(scene, {
        x: orbital.entity.x,
        y: orbital.entity.y,
        angle: angle,
        symbol: config.symbol,
        color: config.color,
        speed: config.speed,
        damage: config.damage,
        fontSize: familiarProjectileSize,
        skipComponents: true // Skip components for familiar projectiles, apply them manually if needed
    });

    // Add visual effect for the shot
    scene.tweens.add({
        targets: projectile,
        alpha: { from: 0.7, to: 1 },
        scale: { from: 0.7, to: 1 },
        duration: 200
    });

    return projectile;
}

// Generic function to setup a familiar firing timer
function setupFamiliarFiringTimer(scene, orbital, behaviorType, baseCooldown = 4000) {
    // Skip if familiar is invalid
    if (!orbital || !orbital.entity || !orbital.entity.active) return null;

    // Get the behavior function
    const behaviorFn = FamiliarBehaviors[behaviorType];
    if (!behaviorFn) {
        console.warn(`Unknown familiar behavior type: ${behaviorType}`);
        return null;
    }

    // Set up orbital properties needed for proper cooldown management
    orbital.baseCooldown = baseCooldown;
    orbital.behaviorType = behaviorType;

    // Create firing timer using CooldownManager - keeping this LUK-based as before
    const firingTimer = CooldownManager.createTimer({
        statName: 'luck', // LUK-based timing
        baseCooldown: baseCooldown,
        formula: 'sqrt',
        component: orbital,  // Store reference to the orbital
        callback: function () {
            // Skip if game is over/paused or orbital is destroyed
            if (gameOver || gamePaused ||
                !orbital || orbital.destroyed ||
                !orbital.entity || !orbital.entity.active) {
                return;
            }

            // Calculate max distance based on player's AGI (fire rate)
            const baseDistance = 400; // Base distance
            let maxDistance = baseDistance * (Math.sqrt(playerFireRate / BASE_STATS.AGI));

            // Apply range modifier from options if available
            const rangeModifier = orbital.options?.rangeModifier ?? 1.0;
            maxDistance *= rangeModifier;

            // Add time-based variation if specified in options
            if (orbital.options?.useRangeVariation) {
                const variation = Math.sin(scene.time.now * 0.001) * 0.2; // ±20% variation
                maxDistance *= (1.0 + variation);
            }

            // Execute the behavior with the calculated max distance
            behaviorFn(scene, orbital, scene.time.now, maxDistance);
        },
        callbackScope: scene,
        loop: true
    });

    return firingTimer;
}

// Helper function to set up color-changing for a fairy
function setupFairyColorChanger(scene, orbital) {
    if (!orbital || !orbital.entity || !scene) return;

    // Array of vibrant colors for the fun fairy
    const colors = [
        '#FF55FF', // Pink
        '#55FFFF', // Cyan
        '#FFFF55', // Yellow
        '#55FF55', // Green
        '#FF5555', // Red
        '#5555FF'  // Blue
    ];

    let colorIndex = 0;

    // Create the color change timer (every 2 seconds as requested)
    const colorTimer = scene.time.addEvent({
        delay: 2000,
        callback: function () {
            if (!orbital.entity || !orbital.entity.active) {
                colorTimer.remove();
                return;
            }

            // Move to next color
            colorIndex = (colorIndex + 1) % colors.length;

            // Apply new color with tween for smooth transition
            scene.tweens.add({
                targets: orbital.entity,
                duration: 500,
                onUpdate: function () {
                    orbital.entity.setColor(colors[colorIndex]);
                }
            });
        },
        callbackScope: scene,
        loop: true
    });

    // Register the timer for cleanup
    window.registerEffect('timer', colorTimer);

    // Store reference to timer on orbital for cleanup
    orbital.colorTimer = colorTimer;

    return colorTimer;
}

window.FamiliarSystem = {
    behaviors: FamiliarBehaviors,
    findRandomVisibleEnemy: findRandomVisibleEnemy,
    findClosestVisibleEnemy: findClosestVisibleEnemy,
    fireFamiliarProjectile: fireFamiliarProjectile,
    setupFamiliarFiringTimer: setupFamiliarFiringTimer,
    setupFairyColorChanger: setupFairyColorChanger
};

// ======= hero.js =======
// Hero kanji with readings and translation
const HERO_CHARACTER = '勇';
const HERO_KANA = 'ゆう';
const HERO_ROMAJI = 'yuu';
const HERO_ENGLISH = 'Brave';

// Base player stats
const BASE_STATS = {
    POW: 4,
    AGI: 4,
    LUK: 4,
    END: 4,
};

// Perk cooldowns in milliseconds
const shieldBaseCd = 80000;
const godHammerBaseCd = 120000;
const divineBeaconBaseCd = 120000;
const fatedShieldBaseCd = 60000;
const angelHoneyBaseCd = 180000;

// Player Status Component System for Word Survivors
// This system manages special behaviors and status effects for the player

// Player status component system
const PlayerComponentSystem = {
    // Component definitions
    componentTypes: {},

    // Active components on player
    activeComponents: {},

    // Register a new component type
    registerComponent: function (name, componentDef) {
        this.componentTypes[name] = componentDef;
    },

    // Add a component to the player
    addComponent: function (componentName, config = {}) {
        // Skip if component already exists or type not registered
        if (this.activeComponents[componentName] || !this.componentTypes[componentName]) {
            return false;
        }

        // Create component from registered type
        const componentDef = this.componentTypes[componentName];
        const component = { ...componentDef };

        // Apply configuration
        Object.assign(component, config);

        // Store component reference
        this.activeComponents[componentName] = component;

        // Call initialize function if it exists
        if (component.initialize) {
            component.initialize(player);
        }

        return true;
    },

    // Remove a component from the player
    removeComponent: function (componentName) {
        const component = this.activeComponents[componentName];
        if (!component) return false;

        console.log(`Removing component: ${componentName}`);

        // Call cleanup function if it exists
        if (component.cleanup) {
            component.cleanup(player);
        }

        // Check for and clean up timers created by CooldownManager
        // Components typically store timer references in properties
        for (const key in component) {
            const value = component[key];

            // Check if property is a timer from CooldownManager
            if (value &&
                (typeof value === 'object') &&
                (value.delay !== undefined || value.paused !== undefined || value.elapsed !== undefined)) {

                console.log(`Found potential timer in ${componentName}.${key}`);

                // Try to remove via CooldownManager first
                if (window.CooldownManager && window.CooldownManager.removeTimer) {
                    window.CooldownManager.removeTimer(value);
                }

                // Also try directly removing the timer as backup
                if (value.remove) {
                    value.remove();
                }

                // Clear reference
                component[key] = null;
            }
        }

        // Remove the component
        delete this.activeComponents[componentName];
        return true;
    },


    // Process a specific event for all components
    processEvent: function (eventName, ...args) {
        // Call the event handler on each component that has it
        Object.values(this.activeComponents).forEach(component => {
            if (component[eventName]) {
                component[eventName](player, ...args);
            }
        });
    },

    // Check if a component is active
    hasComponent: function (componentName) {
        return !!this.activeComponents[componentName];
    },

    // Get an active component
    getComponent: function (componentName) {
        return this.activeComponents[componentName];
    },

    // Reset all components
    resetAll: function () {
        console.log("Resetting all player components...");

        // Get a list of all component names first to avoid modification during iteration
        const componentNames = Object.keys(this.activeComponents);

        // Clean up each component
        componentNames.forEach(name => {
            this.removeComponent(name);
        });

        // Ensure activeComponents is empty
        this.activeComponents = {};

        console.log("All player components reset complete");
    }
};

// Register component for berserker state (Crimson Fury)
PlayerComponentSystem.registerComponent('berserkerState', {
    // Store original values for restoration
    originalColor: null,

    // Track our contribution to the global berserkMultiplier
    damageMultiplier: 1.0, // Changed from 2.0 to 1.0 (represents +100%)
    colorTween: null,

    initialize: function (player) {
        // Store original color
        this.originalColor = player.style.color || '#ffffff';

        // Create color pulsing tween
        const scene = game.scene.scenes[0];
        if (scene) {
            this.colorTween = scene.tweens.add({
                targets: player,
                colorTween: { from: 0, to: 1 },
                duration: 1000, // 1 second in each direction
                yoyo: true,
                repeat: -1,
                onUpdate: function (tween, target) {
                    // Interpolate between white and red based on tween value
                    const value = target.colorTween;
                    const r = Math.floor(255); // Red always at max
                    const g = Math.floor(255 * (1 - value)); // Green reduces to 0
                    const b = Math.floor(255 * (1 - value)); // Blue reduces to 0

                    player.setColor(`rgb(${r},${g},${b})`);
                }
            });
        }

        // Add our multiplier to the global value
        // Now we're adding our contribution rather than directly setting it
        berserkMultiplier += this.damageMultiplier;

        console.log("BERSERK!");

        // Update player stats display to show new values
        GameUI.updateStatCircles(scene);
    },

    update: function (player) {
        // Check if we should deactivate (health above threshold)
        const healthPercentage = playerHealth / maxPlayerHealth;
        if (healthPercentage > 0.25) {
            PlayerComponentSystem.removeComponent('berserkerState');
        }
    },

    cleanup: function (player) {
        // Subtract our contribution from the multiplier
        berserkMultiplier -= this.damageMultiplier;

        // Ensure multiplier doesn't go below 1.0
        if (berserkMultiplier < 1.0) {
            berserkMultiplier = 1.0;
        }

        // Stop color tween if it exists
        if (this.colorTween) {
            this.colorTween.stop();
            this.colorTween = null;
        }

        // Restore original color
        player.setColor(this.originalColor || '#ffffff');

        // Update player stats display
        const scene = game.scene.scenes[0];
        if (scene) {
            GameUI.updateStatCircles(scene);
        }
    }
});

// Registry for mapping perks to player components
const PlayerPerkRegistry = {
    // Store perk-to-component mappings
    perkEffects: {},

    // Register a perk effect that applies a component to the player
    registerPerkEffect: function (perkId, options) {
        this.perkEffects[perkId] = {
            componentName: options.componentName || null,
            configGenerator: options.configGenerator || null,
            condition: options.condition || null
        };
    },

    // Check and apply perk effects based on conditions
    checkAndApplyEffects: function () {
        // Process all registered perk effects
        Object.entries(this.perkEffects).forEach(([perkId, effectInfo]) => {
            // Check if player has this perk
            if (hasPerk(perkId)) {
                // Check if there's a condition function
                let conditionMet = true;
                if (effectInfo.condition) {
                    conditionMet = effectInfo.condition();
                }

                // Apply or remove component based on condition
                if (conditionMet) {
                    // Only add if it's not already active
                    if (!PlayerComponentSystem.hasComponent(effectInfo.componentName)) {
                        // Generate config if needed
                        let config = {};
                        if (effectInfo.configGenerator) {
                            config = effectInfo.configGenerator();
                        }

                        // Add the component
                        PlayerComponentSystem.addComponent(effectInfo.componentName, config);
                    }
                } else {
                    // Remove if active but condition no longer met
                    if (PlayerComponentSystem.hasComponent(effectInfo.componentName)) {
                        PlayerComponentSystem.removeComponent(effectInfo.componentName);
                    }
                }
            }
        });
    }
};

// Register known perk effects
PlayerPerkRegistry.registerPerkEffect('CRIMSON_FURY', {
    componentName: 'berserkerState',
    condition: function () {
        // Active when health is below 25%
        return playerHealth / maxPlayerHealth <= 0.25;
    }
});

// Register component for archer state (Eternal Rhythm)
PlayerComponentSystem.registerComponent('eternalRhythmState', {
    // Store original values and state
    maxMultiplier: 2.0,
    currentMultiplier: 1.0,
    isActive: false,
    accumulator: 0,
    lastUpdateTime: 0,
    velocityThreshold: 10, // Minimum velocity to consider player moving
    particles: [],
    particleTimer: null,

    initialize: function (player) {

        // Reset accumulator and multiplier
        this.accumulator = 0;
        this.currentMultiplier = 1.0;

        // Reset global multiplier
        archerMultiplier = 1.0;

        // Remember the time
        this.lastUpdateTime = game.scene.scenes[0].time.now;

        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Initialize particle array
        this.particles = [];

        // Set up particle creation timer (but initially paused/inactive)
        if (this.particleTimer) {
            this.particleTimer.remove();
        }

        this.particleTimer = scene.time.addEvent({
            delay: (this.currentMultiplier - 1),
            callback: this.createParticle,
            callbackScope: this,
            loop: true,
            paused: true // Start paused
        });

        // Register for cleanup
        window.registerEffect('timer', this.particleTimer);
    },

    // Function to create a single particle
    createParticle: function () {
        const scene = game.scene.scenes[0];
        if (!scene || !player || !player.active) return;

        // Create a particle
        const angle = Math.random() * Math.PI * 2;
        const distance = 20 + Math.random() * 10;
        const x = player.x + Math.cos(angle) * distance;
        const y = player.y + Math.sin(angle) * distance;

        // Create particle as a small text
        const particle = scene.add.text(x, y, '✦', {
            fontFamily: 'Arial',
            fontSize: '12px',
            color: '#FFDD00'
        }).setOrigin(0.5);

        // Add to our tracking array
        this.particles.push(particle);

        // Create animation for particle
        scene.tweens.add({
            targets: particle,
            alpha: { from: 0.7, to: 0 },
            scale: { from: 0.5, to: 1.5 },
            x: particle.x + (Math.random() - 0.5) * 30,
            y: particle.y + (Math.random() - 0.5) * 30,
            duration: 500,
            onComplete: () => {
                // Remove from array and destroy
                const index = this.particles.indexOf(particle);
                if (index !== -1) {
                    this.particles.splice(index, 1);
                }
                particle.destroy();
            }
        });
    },

    update: function (player) {
        // Get current time and calculate delta time in seconds
        const scene = game.scene.scenes[0];
        const currentTime = scene.time.now;
        const deltaTime = (currentTime - this.lastUpdateTime) / 1000; // Convert to seconds
        this.lastUpdateTime = currentTime;

        // Skip if delta time is unreasonably large (e.g., after tab switching)
        if (deltaTime > 0.5) return;

        // Check player velocity directly
        const velocity = player.body.velocity;
        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);

        // Determine if player is moving based on velocity
        const isPlayerMoving = speed > this.velocityThreshold;

        // Only log changes in movement state to reduce spam
        const wasMoving = this.accumulator > 0 && this.currentMultiplier > 1.01;
        if (isPlayerMoving) {
            // Player is moving - increase multiplier
            const maxTimeSeconds = 60 / playerLuck;

            // Calculate increment based on delta time and max time
            const increment = deltaTime / maxTimeSeconds;

            // Increase accumulator
            this.accumulator = Math.min(1.0, this.accumulator + increment);

            // Calculate new multiplier (linear interpolation from 1.0 to maxMultiplier)
            const newMultiplier = 1.0 + (this.accumulator * (this.maxMultiplier - 1.0));

            // Only update if there's a meaningful change
            if (Math.abs(this.currentMultiplier - newMultiplier) > 0.01) {
                this.currentMultiplier = newMultiplier;
                archerMultiplier = this.currentMultiplier;

                // Update the projectile firer with new delay
                this.updateProjectileFiringRate(scene);

                // Update particle timer frequency based on multiplier
                if (this.particleTimer) {
                    // Adjust delay - faster particles at higher multiplier
                    const newDelay = Math.max(50, 150 - (this.currentMultiplier - 1.0) * 100);

                    if (Math.abs(this.particleTimer.delay - newDelay) > 10) {
                        this.particleTimer.delay = newDelay;
                        this.particleTimer.reset({
                            delay: newDelay,
                            callback: this.createParticle,
                            callbackScope: this,
                            loop: true
                        });
                    }

                    // Ensure timer is running
                    if (this.particleTimer.paused) {
                        this.particleTimer.paused = false;
                    }
                }
            }

            // Visual effect when reaching full speed
            if (!this.isActive && this.accumulator >= 0.99) {
                this.isActive = true;

                // Create burst effect when reaching max speed
                for (let i = 0; i < 15; i++) {
                    this.createParticle();
                }
            }
        } else {
            // Player stopped moving - reset multiplier IMMEDIATELY
            if (this.accumulator > 0 || this.currentMultiplier > 1.0) {
                // Instant reset
                this.accumulator = 0;
                this.currentMultiplier = 1.0;
                archerMultiplier = 1.0;
                this.isActive = false;

                // Pause particle creation
                if (this.particleTimer && !this.particleTimer.paused) {
                    this.particleTimer.paused = true;
                }

                // Update projectile firer
                this.updateProjectileFiringRate(scene);
            }
        }
    },

    // Helper function to update projectile firing rate
    updateProjectileFiringRate: function (scene) {
        // Previously referenced projectileFirer directly
        // Now we'll use the WeaponSystem

        if (!scene || !WeaponSystem) return;

        // Calculate new delay based on current multiplier
        const effectiveFireRate = playerFireRate * archerMultiplier;

        // Log the values to understand what's happening

        // Instead of manipulating the timer directly, we'll use WeaponSystem's updateFiringRate
        WeaponSystem.updateFiringRate(scene);

        GameUI.updateStatCircles(scene);
    },

    cleanup: function (player) {

        // Reset multiplier
        archerMultiplier = 1.0;

        // Stop and destroy particle timer
        if (this.particleTimer) {
            this.particleTimer.remove();
            this.particleTimer = null;
        }

        // Clean up any remaining particles
        this.particles.forEach(particle => {
            if (particle && particle.active) {
                particle.destroy();
            }
        });
        this.particles = [];
    }
});
// Register perk effect
PlayerPerkRegistry.registerPerkEffect('ETERNAL_RHYTHM', {
    componentName: 'eternalRhythmState',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Shield system - core functionality for all shield types
const ShieldSystem = {
    // Track if a shield is currently active
    isShieldActive: false,

    // Activate a shield effect
    activateShield: function (options = {}) {

        // Set shield as active
        this.isShieldActive = true;

        // Make shield visual visible
        if (shieldVisual) {
            shieldVisual.setVisible(true);

            // Add a visual effect if we're in a scene
            const scene = game.scene.scenes[0];
            if (scene) {
                scene.tweens.add({
                    targets: shieldVisual,
                    scale: { from: options.startScale ?? 0.5, to: options.endScale ?? 1 },
                    alpha: { from: options.startAlpha ?? 0.8, to: options.endAlpha ?? 0.4 },
                    duration: options.animDuration ?? 500,
                    ease: options.easeFunction ?? 'Cubic.out'
                });
            }
        }

        // Return true for successful activation
        return true;
    },

    // Deactivate the shield (without starting cooldown)
    deactivateShield: function () {

        // Set shield as inactive
        this.isShieldActive = false;

        // Hide shield visual
        if (shieldVisual) {
            shieldVisual.setVisible(false);
        }
    },

    // Called when a shield absorbs a hit
    onShieldHit: function () {

        // Deactivate the shield
        this.deactivateShield();

        // Notify any permanent shield component to start cooldown
        if (PlayerComponentSystem.hasComponent('permanentShieldAbility')) {
            const shieldComponent = PlayerComponentSystem.getComponent('permanentShieldAbility');
            shieldComponent.startCooldown();
        }
    },

    // Check if shield is currently active
    isActive: function () {
        return this.isShieldActive;
    }
};

// Register component for the second chance shield ability
PlayerComponentSystem.registerComponent('secondChanceShieldAbility', {
    // Store properties
    cooldownTimer: null,
    readyForUse: true, // Initially ready to use

    initialize: function (player) {
        this.readyForUse = true;
    },

    update: function (player) {
        // Check if we're ready to use and player is at 1 HP
        if (this.readyForUse && playerHealth === 1) {
            this.activateEmergencyShield();
        }
    },

    activateEmergencyShield: function () {
        // Mark as used
        this.readyForUse = false;

        // Activate shield
        ShieldSystem.activateShield();

        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Remove any existing cooldown timer
        if (this.cooldownTimer) {
            CooldownManager.removeTimer(this.cooldownTimer);
        }

        // Create cooldown timer
        this.cooldownTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: fatedShieldBaseCd,
            formula: 'divide',
            component: this,
            callback: this.resetAbility,
            callbackScope: this,
            loop: false
        });
    },

    resetAbility: function () {
        this.readyForUse = true;
    },

    cleanup: function () {
        // Remove cooldown timer if it exists
        if (this.cooldownTimer) {
            // First remove from CooldownManager's registry
            CooldownManager.removeTimer(this.cooldownTimer);

            // Also directly remove the timer to ensure it's destroyed
            if (this.cooldownTimer.remove) {
                this.cooldownTimer.remove();
            }

            this.cooldownTimer = null;
        }

        // Deactivate shield if this was the only shield provider
        ShieldSystem.deactivateShield();
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('FATED_SHIELD', {
    componentName: 'secondChanceShieldAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Register component for permanent shield ability (from Blue Whale perk)
PlayerComponentSystem.registerComponent('permanentShieldAbility', {
    // Store cooldown timer
    cooldownTimer: null,

    initialize: function (player) {

        // Activate shield immediately when component is created
        ShieldSystem.activateShield();
    },

    startCooldown: function () {

        // Remove any existing cooldown timer
        if (this.cooldownTimer) {
            CooldownManager.removeTimer(this.cooldownTimer);
        }

        // Create cooldown timer
        const scene = game.scene.scenes[0];
        if (!scene) return;

        this.cooldownTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: shieldBaseCd,
            formula: 'divide',
            component: this,
            callback: this.reactivateShield,
            callbackScope: this,
            loop: false
        });
    },

    reactivateShield: function () {
        // Shield cooldown is over, reactivate the shield
        ShieldSystem.activateShield();
    },

    cleanup: function () {
        // Remove cooldown timer if it exists
        if (this.cooldownTimer) {
            // First remove from CooldownManager's registry
            CooldownManager.removeTimer(this.cooldownTimer);

            // Also directly remove the timer to ensure it's destroyed
            if (this.cooldownTimer.remove) {
                this.cooldownTimer.remove();
            }

            this.cooldownTimer = null;
        }

        // Deactivate shield if this was the only shield provider
        ShieldSystem.deactivateShield();
    }
});

// Register the permanent shield perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('BLUE_WHALE', {
    componentName: 'permanentShieldAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Example of a one-off shield component (for future perks)
PlayerComponentSystem.registerComponent('temporaryShieldAbility', {
    // This is just an example - not used yet
    initialize: function (player) {

        // Activate shield with special visual effect
        ShieldSystem.activateShield({
            startScale: 0.2,
            endScale: 1.2,
            startAlpha: 1.0,
            endAlpha: 0.3,
            animDuration: 800,
            notificationText: 'TEMPORARY SHIELD ACTIVE!',
            notificationColor: '#FF9900'
        });
    },

    cleanup: function () {
        // No need to deactivate shield here, as it's handled by ShieldSystem.onShieldHit
    }
});

// Export shield interface for other files to use
window.isShieldActive = function () {
    return ShieldSystem.isActive();
};

window.triggerShieldHit = function () {
    ShieldSystem.onShieldHit();
};

window.activateShield = function (options) {
    return ShieldSystem.activateShield(options);
};

// God Hammer component
PlayerComponentSystem.registerComponent('godHammerAbility', {
    // Store timer reference
    hammerTimer: null,
    sceneReference: null, // Add explicit scene reference storage

    initialize: function (player) {
        // Get the scene and store reference
        const scene = game.scene.scenes[0];
        if (!scene) return;

        this.sceneReference = scene;

        // Create and register timer in one step
        this.hammerTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: godHammerBaseCd,
            formula: 'divide',
            component: this,
            callback: this.dropHammer, // Use component method instead of global function
            callbackScope: this, // Use this component as the scope
            loop: true // Ensure it's marked as looping
        });

        // Immediately drop first hammer using our own method
        this.dropHammer();
    },

    // Internal method to drop the hammer
    dropHammer: function () {
        const scene = this.sceneReference ?? game.scene.scenes[0];
        if (!scene || gameOver || gamePaused) return;

        // Call the original function but with proper context
        dropGodHammer.call(scene);
    },

    cleanup: function (player) {
        // Remove timer from CooldownManager's registry
        if (this.hammerTimer) {
            CooldownManager.removeTimer(this.hammerTimer);

            // Direct cleanup with additional safeguards
            if (this.hammerTimer.remove) {
                this.hammerTimer.remove();
            }

            // If the timer has a countdown event, also remove that
            if (this.hammerTimer.countdown) {
                this.hammerTimer.countdown.remove(false);
            }

            this.hammerTimer = null;
        }

        // Clear scene reference
        this.sceneReference = null;
    }
});

// Function to drop the God Hammer on enemies
function dropGodHammer() {
    // Skip if no enemies
    if (!EnemySystem.enemiesGroup || EnemySystem.enemiesGroup.getChildren().length === 0) return;

    // Get all active enemies on screen
    const activeEnemies = EnemySystem.enemiesGroup.getChildren().filter(enemy =>
        enemy.active &&
        enemy.x >= 0 && enemy.x <= game.config.width && enemy.y >= 0 && enemy.y <= game.config.height
    );

    if (activeEnemies.length === 0) return;

    // Select a random enemy to target
    const targetEnemy = Phaser.Utils.Array.GetRandom(activeEnemies);

    // Create the hammer at a position above the enemy
    const hammerX = targetEnemy.x;
    const hammerY = targetEnemy.y - 300;

    // Create the hammer object using the kanji for "hammer": 鎚
    const hammer = this.add.text(hammerX, hammerY, '鎚', {
        fontFamily: 'Arial',
        fontSize: '96px',
        color: '#FFD700',
        stroke: '#000000',
        strokeThickness: 4
    }).setOrigin(0.5);

    // Add physics body for collision detection
    this.physics.world.enable(hammer);
    hammer.body.setSize(hammer.width * 1, hammer.height * 1);

    // Set properties for the hammer
    hammer.damage = playerDamage * 10;
    hammer.damageSourceId = 'godHammer';

    // Register entity for cleanup
    window.registerEffect('entity', hammer);

    // Add overlap with enemies
    this.physics.add.overlap(hammer, EnemySystem.enemiesGroup, function (hammer, enemy) {
        applyContactDamage.call(this, hammer, enemy, hammer.damage);
    }, null, this);

    // Add falling animation
    this.tweens.add({
        targets: hammer,
        y: targetEnemy.y,
        duration: 500,
        ease: 'Bounce.easeOut',
        onComplete: function () {
            // Fade out and remove the hammer after a short delay
            this.parent.scene.tweens.add({
                targets: hammer,
                alpha: 0,
                duration: 500,
                delay: 500,
                onComplete: function () {
                    hammer.destroy();
                }
            });
        }
    });
}

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('GOD_HAMMER', {
    componentName: 'godHammerAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Activation function (will be called from perks.js)
window.activateGodHammer = function () {
    // Simply add the component through the component system
    PlayerComponentSystem.addComponent('godHammerAbility');
};

// Register component for Divine Beacon ability
PlayerComponentSystem.registerComponent('divineBeaconAbility', {
    // Store timer reference
    beaconTimer: null,

    initialize: function (player) {

        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create and register timer in one step
        this.beaconTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: divineBeaconBaseCd,
            formula: 'divide',
            component: this,
            callback: this.spawnBeacon,
            callbackScope: scene
        });

        // Immediately spawn first beacon
        this.spawnBeacon.call(scene);
    },

    spawnBeacon: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Random position on screen (with padding from edges)
        const x = Phaser.Math.Between(game.config.width * 0.017, game.config.width * 0.983); // 20/1200 to 1180/1200
        const y = Phaser.Math.Between(game.config.height * 0.025, game.config.height * 0.975); // 20/800 to 780/800

        // Create the beacon using the kanji for "heaven/sky": 天
        const beacon = this.add.text(x, y, '天', {
            fontFamily: 'Arial',
            fontSize: '16px',
            color: '#FFD700', // Gold color
            stroke: '#FFFFFF',
            strokeThickness: 4,
            shadow: {
                offsetX: 0,
                offsetY: 0,
                color: '#FFFFFF',
                blur: 10,
                stroke: true,
                fill: true
            }
        }).setOrigin(0.5);

        // Add physics body for collision detection
        this.physics.world.enable(beacon);
        beacon.body.setSize(beacon.width * 0.8, beacon.height * 0.8);

        // Set as immovable
        beacon.body.immovable = true;

        // Add a unique ID to prevent duplicate collection
        beacon.beaconId = 'beacon_' + Date.now() + '_' + Math.random();

        // Register entity for cleanup
        window.registerEffect('entity', beacon);

        // Add overlap with player
        this.physics.add.overlap(beacon, player, function (beacon, player) {
            // Only collect if not already collected
            if (beacon.collected) return;

            // Mark as collected to prevent multiple triggers
            beacon.collected = true;

            // Trigger hammer drop
            dropGodHammer.call(this);

            // Visual effect for collection
            this.tweens.add({
                targets: beacon,
                alpha: 0,
                scale: 2,
                duration: 500,
                onComplete: function () {
                    beacon.destroy();
                }
            });

            // Create radial flash effect
            const flash = this.add.circle(beacon.x, beacon.y, 5, 0xFFFFFF, 1);
            this.tweens.add({
                targets: flash,
                radius: 100,
                alpha: 0,
                duration: 500,
                onComplete: function () {
                    flash.destroy();
                }
            });

        }, null, this);

        // Add pulsing animation
        VisualEffects.createPulsing(this, beacon);
    },

    cleanup: function (player) {
        // Remove timer from CooldownManager's registry
        CooldownManager.removeTimer(this.beaconTimer);

        // Also directly remove the timer to ensure it's destroyed
        if (this.beaconTimer && this.beaconTimer.remove) {
            this.beaconTimer.remove();
        }

        this.beaconTimer = null;
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('DIVINE_BEACON', {
    componentName: 'divineBeaconAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Register component for Angel Honey ability
PlayerComponentSystem.registerComponent('angelHoneyAbility', {
    // Store timer reference
    honeyTimer: null,

    initialize: function (player) {
        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create and register timer in one step
        this.honeyTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: angelHoneyBaseCd,
            formula: 'divide',
            component: this,
            callback: this.spawnHoney,
            callbackScope: scene
        });

        // Immediately spawn first honey
        this.spawnHoney.call(scene);
    },

    spawnHoney: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Random position on screen (with padding from edges)
        const x = Phaser.Math.Between(game.config.width * 0.017, game.config.width * 0.983); // 20/1200 to 1180/1200
        const y = Phaser.Math.Between(game.config.height * 0.025, game.config.height * 0.975); // 20/800 to 780/800

        // Create the honey using the kanji for "honey": 蜜
        const honey = this.add.text(x, y, '蜜', {
            fontFamily: 'Arial',
            fontSize: '20px',
            color: '#00CC00', // Green color
            stroke: '#FFFFFF',
            strokeThickness: 4,
            shadow: {
                offsetX: 0,
                offsetY: 0,
                color: '#FFFFFF',
                blur: 10,
                stroke: true,
                fill: true
            }
        }).setOrigin(0.5);

        // Add physics body for collision detection
        this.physics.world.enable(honey);
        honey.body.setSize(honey.width * 0.8, honey.height * 0.8);

        // Set as immovable
        honey.body.immovable = true;

        // Add a unique ID to prevent duplicate collection
        honey.honeyId = 'honey_' + Date.now() + '_' + Math.random();

        // Register entity for cleanup
        window.registerEffect('entity', honey);

        // Add overlap with player
        this.physics.add.overlap(honey, player, function (honey, player) {
            // Only collect if not already collected
            if (honey.collected) return;

            // Mark as collected to prevent multiple triggers
            honey.collected = true;

            // Use the global fullHeal function
            window.fullHeal();

            // Visual effect for collection
            this.tweens.add({
                targets: honey,
                alpha: 0,
                scale: 2,
                duration: 500,
                onComplete: function () {
                    honey.destroy();
                }
            });

            // Create radial flash effect
            const flash = this.add.circle(honey.x, honey.y, 5, 0x00FF00, 1);
            this.tweens.add({
                targets: flash,
                radius: 100,
                alpha: 0,
                duration: 500,
                onComplete: function () {
                    flash.destroy();
                }
            });

        }, null, this);

        // Add pulsing animation
        VisualEffects.createPulsing(this, honey);
    },

    cleanup: function (player) {
        // Remove timer from CooldownManager's registry
        CooldownManager.removeTimer(this.honeyTimer);

        // Also directly remove the timer to ensure it's destroyed
        if (this.honeyTimer && this.honeyTimer.remove) {
            this.honeyTimer.remove();
        }

        this.honeyTimer = null;
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('ANGEL_HONEY', {
    componentName: 'angelHoneyAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Register component for Alien Clock ability
PlayerComponentSystem.registerComponent('alienClockAbility', {
    // Store timer reference
    clockTimer: null,
    beaconCooldown: 120000, // 2 minutes base cooldown

    initialize: function (player) {
        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create and register timer in one step
        this.clockTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: this.beaconCooldown,
            formula: 'divide',
            component: this,
            callback: this.spawnClockBeacon,
            callbackScope: scene
        });

        // Immediately spawn first clock beacon
        this.spawnClockBeacon.call(scene);
    },

    spawnClockBeacon: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Random position on screen (with padding from edges)
        const x = Phaser.Math.Between(game.config.width * 0.080, game.config.width * 0.920); // 100/1200 to 1100/1200
        const y = Phaser.Math.Between(game.config.height * 0.125, game.config.height * 0.875); // 100/800 to 700/800

        // Create the beacon using the kanji for "time": 時
        const beacon = this.add.text(x, y, '時', {
            fontFamily: 'Arial',
            fontSize: '20px',
            color: '#00FFFF', // Cyan color
            stroke: '#000000',
            strokeThickness: 3,
            shadow: {
                offsetX: 0,
                offsetY: 0,
                color: '#00FFFF',
                blur: 8,
                stroke: true,
                fill: true
            }
        }).setOrigin(0.5);

        // Add physics body for collision detection
        this.physics.world.enable(beacon);
        beacon.body.setSize(beacon.width * 0.8, beacon.height * 0.8);

        // Set as immovable
        beacon.body.immovable = true;

        // Add a unique ID to prevent duplicate collection
        beacon.beaconId = 'timeBeacon_' + Date.now() + '_' + Math.random();

        // Register entity for cleanup
        window.registerEffect('entity', beacon);

        // Add overlap with player
        this.physics.add.overlap(beacon, player, function (beacon, player) {
            // Only collect if not already collected
            if (beacon.collected) return;

            // Mark as collected to prevent multiple triggers
            beacon.collected = true;

            // Calculate slow motion duration based on luck
            const slowdownDuration = Math.sqrt(playerLuck / BASE_STATS.LUK) * 1000;

            // Activate time dilation
            window.activateTimeDilation(slowdownDuration);

            // Visual effect for collection
            this.tweens.add({
                targets: beacon,
                alpha: 0,
                scale: 2,
                duration: 500,
                onComplete: function () {
                    beacon.destroy();
                }
            });

            // Create radial flash effect
            const flash = this.add.circle(beacon.x, beacon.y, 5, 0x00FFFF, 1);
            this.tweens.add({
                targets: flash,
                radius: 100,
                alpha: 0,
                duration: 800,
                onComplete: function () {
                    flash.destroy();
                }
            });

        }, null, this);

        // Add pulsing animation
        VisualEffects.createPulsing(this, beacon);
    },

    cleanup: function (player) {
        // Remove timer from CooldownManager's registry
        CooldownManager.removeTimer(this.clockTimer);

        // Also directly remove the timer to ensure it's destroyed
        if (this.clockTimer && this.clockTimer.remove) {
            this.clockTimer.remove();
        }

        this.clockTimer = null;
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('ALIEN_CLOCK', {
    componentName: 'alienClockAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

window.activateAlienClock = function () {
    // Now just add the component - no need to add timeDilationEffect
    PlayerComponentSystem.addComponent('alienClockAbility');
};

// Lightning strike function in hero.js (outside the component)
function createLightningStrike(scene, x, y, options = {}) {
    // Skip if game is over or paused
    if (gameOver || gamePaused) return;

    // Default options
    const damage = options.damage ?? (playerDamage * 4); // 4x damage as in your code
    const color = options.color ?? '#FFDD00';
    const size = options.size ?? 32;
    const symbol = options.symbol ?? '雷';
    const segmentCount = options.segmentCount ?? 8; // 8 segments as in your code

    // Create a lightning column of kanjis with decreasing opacity
    const lightningSegments = [];

    // Create the main lightning at the impact point
    const mainLightning = scene.add.text(x, y, symbol, {
        fontFamily: 'Arial',
        fontSize: `${size}px`,
        color: color,
        fontStyle: 'bold'
    }).setOrigin(0.5);

    // Register for cleanup
    window.registerEffect('entity', mainLightning);
    lightningSegments.push(mainLightning);

    // Create lightning segments above with decreasing opacity
    for (let i = 1; i < segmentCount; i++) {
        const opacity = 0.8 - (i * 0.1); // From 0.8 down to 0.1 as in your code
        const segment = scene.add.text(x, y - (i * size), symbol, {
            fontFamily: 'Arial',
            fontSize: `${size}px`,
            color: color,
            fontStyle: 'bold'
        }).setOrigin(0.5).setAlpha(opacity);

        // Register for cleanup
        window.registerEffect('entity', segment);
        lightningSegments.push(segment);
    }

    // Create flash effect simultaneously with the lightning
    VisualEffects.createLightningFlash(scene, x, y, {
        radius: 48, // 48px radius as in your code
        color: 0xFFFF66,
        alpha: 0.7,
        duration: 1000 // Match the fade-out duration of the lightning
    });

    // Apply damage to nearby enemies immediately
    const hitRadius = 64; // 64px hit radius as in your code
    const targets = scene.physics.overlapCirc(x, y, hitRadius, true, true);

    // Create unique ID for this lightning strike
    const strikeId = `lightning_${Date.now()}_${Math.random()}`;

    // Apply damage to all enemies in radius
    targets.forEach(body => {
        if (body.gameObject && body.gameObject.active) {
            applyContactDamage.call(
                scene,
                {
                    damageSourceId: strikeId,
                    damage: damage,
                    active: true
                },
                body.gameObject,
                damage,
                0 // No cooldown needed for one-time effect
            );
        }
    });

    // Fade everything out together
    scene.tweens.add({
        targets: lightningSegments,
        alpha: 0,
        duration: 1000,
        onComplete: function () {
            // Clean up all elements
            lightningSegments.forEach(segment => segment.destroy());
        }
    });

    // Return the segments array for any additional manipulation
    return lightningSegments;
}

// Register component for Storm Caller ability in hero.js
PlayerComponentSystem.registerComponent('stormCallerAbility', {
    // Store timer reference
    stormTimer: null,

    initialize: function () {
        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create and register timer
        this.stormTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: 2000, //
            formula: 'sqrt',
            component: this,
            callback: function () {
                // Skip if game is over or paused
                if (gameOver || gamePaused) return;

                // Get a random target position on screen
                const targetX = Phaser.Math.Between(game.config.width * 0.083, game.config.width * 0.917); // 100/1200 to 1100/1200
                const targetY = Phaser.Math.Between(game.config.height * 0.125, game.config.height * 0.875); // 100/800 to 700/800

                // Call the lightning strike function
                createLightningStrike(scene, targetX, targetY);
            },
            callbackScope: scene,
            loop: true
        });

        // Create initial lightning immediately
        const targetX = Phaser.Math.Between(game.config.width * 0.083, game.config.width * 0.917); // 100/1200 to 1100/1200
        const targetY = Phaser.Math.Between(game.config.height * 0.125, game.config.height * 0.875); // 100/800 to 700/800
        createLightningStrike(scene, targetX, targetY);
    },

    // Cleanup on removal
    cleanup: function () {
        // Remove timer
        if (this.stormTimer) {
            CooldownManager.removeTimer(this.stormTimer);
            this.stormTimer = null;
        }
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('STORM_CALLER', {
    componentName: 'stormCallerAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Function to activate storm caller
window.activateStormCaller = function () {
    // Simply add the component through the component system
    PlayerComponentSystem.addComponent('stormCallerAbility');
};

// Make the function globally accessible for other perks
window.createLightningStrike = createLightningStrike;

// Register component for Storm Bringer ability in hero.js
PlayerComponentSystem.registerComponent('stormBringerAbility', {
    // Store timer reference
    beaconTimer: null,

    initialize: function () {
        // Get the scene
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create and register timer
        this.beaconTimer = CooldownManager.createTimer({
            statName: 'luck',
            baseCooldown: 30000, // 30 seconds base cooldown
            formula: 'sqrt',
            component: this,
            callback: this.spawnBeacon,
            callbackScope: scene,
            loop: true
        });

        // Spawn initial beacon
        this.spawnBeacon.call(scene);
    },

    // Method to spawn a storm beacon
    spawnBeacon: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Random position on screen (with padding from edges)
        const x = Phaser.Math.Between(game.config.width * 0.2, game.config.width * 0.8); // 360/1200 to (1200-360)/1200
        const y = Phaser.Math.Between(game.config.height * 0.2, game.config.height * 0.8); // 360/800 to (800-360)/800

        // Create the beacon using the kanji for "storm"
        const beacon = this.add.text(x, y, '嵐', {
            fontFamily: 'Arial',
            fontSize: '24px',
            color: '#00DDFF', // Bright cyan color
            stroke: '#FFFFFF',
            strokeThickness: 2,
            shadow: {
                offsetX: 0,
                offsetY: 0,
                color: '#FFFFFF',
                blur: 8,
                stroke: true,
                fill: true
            }
        }).setOrigin(0.5);

        // Add physics body for collision detection
        this.physics.world.enable(beacon);
        beacon.body.setSize(beacon.width * 0.8, beacon.height * 0.8);

        // Set as immovable
        beacon.body.immovable = true;

        // Add a unique ID to prevent duplicate collection
        beacon.beaconId = 'storm_beacon_' + Date.now() + '_' + Math.random();

        // Register entity for cleanup
        window.registerEffect('entity', beacon);

        // Add overlap with player
        this.physics.add.overlap(beacon, player, function (beacon, player) {
            // Only collect if not already collected
            if (beacon.collected) return;

            // Mark as collected to prevent multiple triggers
            beacon.collected = true;

            // Create a lightning storm at this position
            const centerX = beacon.x;
            const centerY = beacon.y;
            const lightningCount = 8; // 8 lightning strikes
            const radius = 360; // Radius around the center point

            // Create first lightning at the center
            createLightningStrike(this, centerX, centerY);

            // Create remaining lightning strikes with delays
            for (let i = 1; i < lightningCount; i++) {
                // Calculate position - random point within radius
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;

                // Schedule with increasing delay
                this.time.delayedCall(i * 300, function () {
                    if (gameOver || gamePaused) return;
                    createLightningStrike(this, x, y);
                }, [], this);
            }

            // Visual effect for collection
            this.tweens.add({
                targets: beacon,
                alpha: 0,
                scale: 2,
                duration: 500,
                onComplete: function () {
                    beacon.destroy();
                }
            });

            // Create radial flash effect
            const flash = this.add.circle(beacon.x, beacon.y, 50, 0x00DDFF, 0.7);
            window.registerEffect('entity', flash);

            this.tweens.add({
                targets: flash,
                radius: 200,
                alpha: 0,
                duration: 800,
                onComplete: function () {
                    flash.destroy();
                }
            });

        }, null, this);

        // Add pulsing animation
        VisualEffects.createPulsing(this, beacon);
    },

    // Cleanup on removal
    cleanup: function () {
        // Remove timer
        if (this.beaconTimer) {
            CooldownManager.removeTimer(this.beaconTimer);
            this.beaconTimer = null;
        }
    }
});

// Register the perk with the PlayerPerkRegistry
PlayerPerkRegistry.registerPerkEffect('STORM_BRINGER', {
    componentName: 'stormBringerAbility',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Function to activate storm bringer
window.activateStormBringer = function () {
    // Simply add the component through the component system
    PlayerComponentSystem.addComponent('stormBringerAbility');
};

// Function to update player status in game loop
function updatePlayerStatus() {
    // Skip if game is over or paused
    if (gameOver || gamePaused) return;

    // Check perk conditions and apply/remove components
    PlayerPerkRegistry.checkAndApplyEffects();

    // Process update event for all active components
    PlayerComponentSystem.processEvent('update');

    // Update cooldowns based on stat changes
    CooldownManager.update();
}

// Function to reset player status (call during game restart)
function resetPlayerStatus() {
    PlayerComponentSystem.resetAll();
    berserkMultiplier = 1.0;
}

// ======= input.js =======
// input.js - Custom input handling enhancements for Word Survivors

// Input system for managing extended behavior beyond Phaser's defaults
const InputSystem = {
    // Variables to track cursor state
    lastMouseX: 0,
    lastMouseY: 0,
    cursorHideTimer: null,
    isCursorHidden: false,
    cursorHideDelay: 1000, // 1 second delay before hiding
    isInitialized: false,
    isTabActive: true,     // Track if tab is active/visible

    // Initialize the cursor hiding feature
    setupCursorHiding: function (scene) {
        // Skip if already initialized
        if (this.isInitialized) return;

        // Store reference to the scene
        this.scene = scene;

        // Pointer move handler
        scene.input.on('pointermove', this.handlePointerMove, this);

        // Show cursor when pressing any button
        scene.input.on('pointerdown', this.handlePointerDown, this);

        // Always show cursor when leaving game area
        scene.game.canvas.addEventListener('mouseout', this.handleMouseOut.bind(this));

        // Handle tab visibility changes
        document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));

        // Handle window focus/blur
        window.addEventListener('focus', this.handleWindowFocus.bind(this));
        window.addEventListener('blur', this.handleWindowBlur.bind(this));

        // Force cursor state reset on initialization
        this.resetCursorState();

        // Mark as initialized
        this.isInitialized = true;

        console.log("Enhanced cursor hiding system initialized");
    },

    // Handle pointer movement
    handlePointerMove: function (pointer) {
        // If the cursor position has changed
        if (pointer.x !== this.lastMouseX || pointer.y !== this.lastMouseY) {
            // Update last known position
            this.lastMouseX = pointer.x;
            this.lastMouseY = pointer.y;

            // Show cursor if it was hidden
            if (this.isCursorHidden) {
                document.body.style.cursor = 'auto';
                this.isCursorHidden = false;
            }

            // Reset the hide timer
            this.resetCursorTimer();
        }
    },

    // Handle pointer button press
    handlePointerDown: function () {
        if (this.isCursorHidden) {
            document.body.style.cursor = 'auto';
            this.isCursorHidden = false;
        }

        // Reset the timer
        this.resetCursorTimer();
    },

    // Handle mouse leaving the game area
    handleMouseOut: function () {
        document.body.style.cursor = 'auto';
        this.isCursorHidden = false;

        this.clearCursorTimer();
    },

    // Handle tab visibility changes
    handleVisibilityChange: function () {
        if (document.hidden) {
            this.isTabActive = false;
            // Show cursor when tab is hidden
            document.body.style.cursor = 'auto';
            this.isCursorHidden = false;
            this.clearCursorTimer();
        } else {
            this.isTabActive = true;
            // Reset cursor timer when tab becomes visible
            this.resetCursorState();
        }
    },

    // Handle window focus
    handleWindowFocus: function () {
        // Reset cursor state when window regains focus
        this.resetCursorState();
    },

    // Handle window blur
    handleWindowBlur: function () {
        // Show cursor when window loses focus
        document.body.style.cursor = 'auto';
        this.isCursorHidden = false;
        this.clearCursorTimer();
    },

    // Helper function to reset the cursor hiding timer
    resetCursorTimer: function () {
        // Don't set timers if tab is not active
        if (!this.isTabActive) return;

        // Clear existing timer if any
        this.clearCursorTimer();

        // Set new timer to hide cursor after delay
        this.cursorHideTimer = this.scene.time.delayedCall(
            this.cursorHideDelay,
            function () {
                if (this.isTabActive) {
                    document.body.style.cursor = 'none';
                    this.isCursorHidden = true;
                }
            },
            [],
            this
        );
    },

    // Helper function to clear the cursor timer
    clearCursorTimer: function () {
        if (this.cursorHideTimer) {
            if (this.scene && this.scene.time && this.scene.time.removeEvent) {
                this.scene.time.removeEvent(this.cursorHideTimer);
            }
            this.cursorHideTimer = null;
        }
    },

    // Force a complete reset of cursor state
    resetCursorState: function () {
        // Show cursor initially
        document.body.style.cursor = 'auto';
        this.isCursorHidden = false;

        // Reset timer
        this.clearCursorTimer();
        this.resetCursorTimer();

        // Manually check for mouse movement after a short delay
        if (this.scene) {
            this.scene.time.delayedCall(100, function () {
                // Get the current pointer position
                const pointer = this.scene.input.activePointer;
                if (pointer) {
                    // Force an update of the last position
                    this.lastMouseX = pointer.x;
                    this.lastMouseY = pointer.y;
                }
            }, [], this);
        }
    },

    // Clean up event listeners (call this on game reset if needed)
    cleanup: function () {
        if (!this.isInitialized || !this.scene) return;

        // Remove event listeners
        this.scene.input.off('pointermove', this.handlePointerMove, this);
        this.scene.input.off('pointerdown', this.handlePointerDown, this);

        // Remove canvas listener
        if (this.scene.game && this.scene.game.canvas) {
            this.scene.game.canvas.removeEventListener('mouseout', this.handleMouseOut);
        }

        // Remove document and window listeners
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        window.removeEventListener('focus', this.handleWindowFocus);
        window.removeEventListener('blur', this.handleWindowBlur);

        // Clear timer
        this.clearCursorTimer();

        // Reset cursor visibility
        document.body.style.cursor = 'auto';
        this.isCursorHidden = false;

        // Reset initialization flag
        this.isInitialized = false;
        this.scene = null;
    }
};

// Export the system for use in other files
window.InputSystem = InputSystem;

// ======= life.js =======
// life.js - Health and life management system for Word Survivors
// Manages player health regeneration and healing

// LifeSystem namespace
const LifeSystem = {
    // State tracking
    healthRegenTimer: null,
    isInitialized: false,

    // Initialize the life system
    initialize: function (scene) {
        // Skip if already initialized
        if (this.isInitialized) return;

        // Set up health regeneration
        this.setupHealthRegeneration(scene);

        // Mark as initialized
        this.isInitialized = true;

        console.log("Life system initialized");
    },

    // Setup health regeneration
    setupHealthRegeneration: function (scene) {
        // Calculate delay based on max health (100s / maxHealth)
        const regenDelay = Math.ceil(100000 / maxPlayerHealth); // In milliseconds

        // Remove any existing regen timer
        if (this.healthRegenTimer) {
            this.healthRegenTimer.remove();
        }

        // Create and register health regeneration timer
        this.healthRegenTimer = registerTimer(scene.time.addEvent({
            delay: regenDelay,
            callback: this.regenerateHealth,
            callbackScope: scene,
            loop: true
        }));

        GameUI.updateHealthBar(scene);

        console.log(`Health regeneration timer set: +1 HP every ${regenDelay / 1000} seconds`);
    },

    // Regenerate health
    regenerateHealth: function () {
        // This function is called with scene as context (via callbackScope)
        if (gameOver || gamePaused) return;

        // Only regenerate if health is below max
        if (playerHealth < maxPlayerHealth) {
            // Add 1 HP
            playerHealth = Math.min(playerHealth + 1, maxPlayerHealth);

            // Update health bar and text
            GameUI.updateHealthBar(this);

            // Show visual effect
            LifeSystem.showRegenEffect(this);
        }
    },

    // Show visual effect for health regeneration
    showRegenEffect: function (scene) {
        // Create a healing indicator
        const healEffect = scene.add.text(player.x, player.y - 20, '+1', {
            fontFamily: 'Arial',
            fontSize: '16px',
            color: '#00ff00'
        }).setOrigin(0.5);

        // Animate the healing indicator
        scene.tweens.add({
            targets: healEffect,
            y: healEffect.y - 15,
            alpha: 0,
            duration: 800,
            onComplete: function () {
                healEffect.destroy();
            }
        });
    },

    // Fully heal the player
    fullHeal: function () {
        // Set health to maximum
        playerHealth = maxPlayerHealth;

        // Update the health bar (get active scene)
        const scene = game.scene.scenes[0];
        if (scene) {
            GameUI.updateHealthBar(scene);

            // Show healing particles or effect
            const healEffect = scene.add.text(player.x, player.y - 40, '+HEAL', {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#00ff00'
            }).setOrigin(0.5);

            // Animate the effect
            scene.tweens.add({
                targets: healEffect,
                y: healEffect.y - 30,
                alpha: 0,
                duration: 1000,
                onComplete: function () {
                    healEffect.destroy();
                }
            });
        }
    },

    // Reset the life system (call during game restart)
    reset: function () {
        // Remove health regen timer
        if (this.healthRegenTimer) {
            this.healthRegenTimer.remove();
            this.healthRegenTimer = null;
        }

        // Reset state
        this.isInitialized = false;

        console.log("Life system reset");
    }
};

// Export for use in other files
window.LifeSystem = LifeSystem;

// Export legacy function reference to maintain backward compatibility
window.fullHeal = LifeSystem.fullHeal;

// ======= menu.js =======
// menu.js - UI Elements for Word Survivors

// UI Element constants with relative positioning
const UI = {
    kajisuli: {
        enabled: function () {
            // Access the global KAJISULI_MODE defined in index.html
            return (typeof KAJISULI_MODE !== 'undefined') ? KAJISULI_MODE : false;
        }
    },

    // Functions to get current game dimensions
    game: {
        getWidth: function () {
            return 1200; // Default width if no game instance available
        },
        getHeight: function () {
            return 800; // Default height if no game instance available
        },
        init: function (scene) {
            // Update getters to use actual canvas dimensions instead of config
            if (scene && scene.sys && scene.sys.game) {
                // Get the actual rendered canvas size rather than the config size
                this.getWidth = function () {
                    const canvas = scene.sys.game.canvas;
                    return canvas ? canvas.width : scene.sys.game.config.width;
                };
                this.getHeight = function () {
                    const canvas = scene.sys.game.canvas;
                    return canvas ? canvas.height : scene.sys.game.config.height;
                };

                // Log the dimensions for debugging
                //console.log(`UI initialized with dimensions: ${this.getWidth()}x${this.getHeight()}`);
            }
        }
    },

    // Helper functions for relative positioning
    rel: {
        width: function (percentage) {
            return UI.game.getWidth() * (percentage / 100);
        },
        height: function (percentage) {
            return UI.game.getHeight() * (percentage / 100);
        },
        x: function (percentage) {
            return UI.game.getWidth() * (percentage / 100);
        },
        y: function (percentage) {
            return UI.game.getHeight() * (percentage / 100);
        },
        // Function to calculate font size relative to screen height
        fontSize: function (percentage) {
            return Math.floor(UI.game.getHeight() * (percentage / 100));
        }
    },

    // Health bar configuration
    healthBar: {
        width: function () { return UI.rel.width(25); },       // 25% of screen width
        height: function () { return UI.rel.height(1.25); },   // 1.25% of screen height
        borderWidth: 2,
        innerMargin: 2,
        segmentGap: function () { return UI.rel.width(0.33); }, // 0.33% of screen width
        y: function () { return UI.rel.y(2.5); },              // 2.5% from top
        centerX: function () { return UI.rel.x(50); },         // Center of screen
        startX: function () { return UI.rel.x(37.5); }         // 37.5% of screen width
    },

    // Experience bar configuration
    expBar: {
        width: function () { return UI.rel.width(16.7); },     // 16.7% of screen width
        height: function () { return UI.rel.height(0.625); },  // 0.625% of screen height
        borderWidth: 2,
        innerMargin: 1,
        y: function () { return UI.rel.y(5.5); },              // 5.5% from top
        centerX: function () { return UI.rel.x(50); },         // Center of screen
        startX: function () { return UI.rel.x(41.7); },        // 41.7% from left
        textColor: "#00ffff",
        barColor: 0x00ffff,
        bgColor: 0x333333
    },

    // Status display (timer and kills)
    statusDisplay: {
        timerY: function () { return UI.rel.y(3.75); },        // 3.75% from top
        killsY: function () { return UI.rel.y(3.75); },        // Same Y as timer
        x: function () { return UI.rel.x(1.33); },             // 1.33% from left
        timerWidth: function () { return UI.rel.width(10); },  // 10% of screen width
        killsWidth: function () { return UI.rel.width(10); },  // Same width as timer
        killsX: function () { return UI.rel.x(13.33); },       // Position to right of timer
        height: function () { return UI.rel.height(2.5); },    // 2.5% of screen height
        borderWidth: 2,
        textPadding: function () { return UI.rel.width(0.33); }, // 0.33% of screen width
        clockSymbol: "時",  // Kanji for time/clock
        deathSymbol: "殺",  // Kanji for kill/death
        fontSize: function () { return UI.rel.fontSize(2); }   // 2% of screen height
    },

    // Stat display (POW, AGI, LUK, END)
    statDisplay: {
        y: function () { return UI.rel.y(3.75); },            // 3.75% from top
        x: function () { return UI.rel.x(76.7); },            // 76.7% from left (right side)
        spacing: function () { return UI.rel.width(5.83); },  // 5.83% of screen width
        width: function () { return UI.rel.width(4.17); },    // 4.17% of screen width
        height: function () { return UI.rel.height(3); },     // 3% of screen height
        borderWidth: 2,
        textPadding: function () { return UI.rel.width(0.33); }, // 0.33% of screen width
        fontSize: function () { return UI.rel.fontSize(2.5); }, // 2.5% of screen height
        symbols: {
            POW: "力", // Kanji for power/strength
            AGI: "速", // Kanji for speed
            LUK: "運", // Kanji for luck
            END: "耐"  // Kanji for endurance
        },
        symbolColors: {
            POW: "#cc0000", // Red
            AGI: "#0088ff", // Blue
            LUK: "#aa55cc", // Purple
            END: "#00aa00"  // Green
        }
    },

    // Color constants
    colors: {
        gold: 0xFFD700,
        green: 0x00cc00,
        black: 0x000000,
        grey: 0x333333
    },

    // Depth constants
    depth: {
        ui: 100
    },

    // Font definitions
    fonts: {
        level: {
            size: function () { return `${UI.rel.fontSize(2.25)}px`; },
            family: 'Arial',
            color: '#FFD700'
        },
        xpNeeded: {
            size: function () { return `${UI.rel.fontSize(1.5)}px`; },
            family: 'Arial',
            color: '#00ffff'
        },
        stats: {
            size: function () { return `${UI.rel.fontSize(2.5)}px`; },
            family: 'Arial',
            color: '#FFFFFF'
        },
        timer: {
            size: function () { return `${UI.rel.fontSize(2.25)}px`; },
            family: 'Arial',
            color: '#FFFFFF'
        },
        kills: {
            size: function () { return `${UI.rel.fontSize(2.25)}px`; },
            family: 'Arial',
            color: '#FFFFFF'
        }
    }
};

// Health bar functions
const HealthBar = {
    create: function (scene) {
        // Initialize relative dimensions
        UI.game.init(scene);

        // Remove old health bar elements if they exist
        if (scene.healthBar) scene.healthBar.destroy();
        if (scene.healthBarBg) scene.healthBarBg.destroy();
        if (scene.healthText) scene.healthText.destroy();

        // Get kajisuli scale factors - wider not thicker
        const kajisuliScaleWidth = UI.kajisuli.enabled() ? 1.5 : 1;
        const kajisuliScaleHeight = 1; // Keep the same height

        // Store the scale factors for later use
        scene.healthBarScales = {
            width: kajisuliScaleWidth,
            height: kajisuliScaleHeight
        };

        // Get calculated dimensions
        const width = UI.healthBar.width() * kajisuliScaleWidth;
        const height = UI.healthBar.height() * kajisuliScaleHeight;
        const borderWidth = UI.healthBar.borderWidth;
        const innerMargin = UI.healthBar.innerMargin;
        const centerX = UI.healthBar.centerX();
        const y = UI.healthBar.y();

        // Create new container with golden border
        scene.healthBarBg = scene.add.rectangle(
            centerX,
            y,
            width + (borderWidth * 2),
            height + (borderWidth * 2),
            UI.colors.gold
        ).setDepth(UI.depth.ui);

        // Create inner black background
        scene.healthBarInnerBg = scene.add.rectangle(
            centerX,
            y,
            width,
            height,
            UI.colors.black
        ).setDepth(UI.depth.ui);

        // Create a container for segments
        scene.healthSegments = scene.add.group();

        // Container for separators
        scene.healthSeparators = scene.add.group();

        // Initial health segments
        this.update(scene);
    },

    update: function (scene) {
        // If segments don't exist yet or scene is not available, exit
        if (!scene.healthSegments || !scene.healthSegments.scene) return;

        // Clear existing segments and separators
        scene.healthSegments.clear(true, true);
        if (scene.healthSeparators) scene.healthSeparators.clear(true, true);

        // Get the scale factors from the scene
        const kajisuliScaleWidth = scene.healthBarScales?.width ?? (UI.kajisuli.enabled() ? 1.5 : 1);
        const kajisuliScaleHeight = scene.healthBarScales?.height ?? 1;

        // Get calculated dimensions
        const width = UI.healthBar.width() * kajisuliScaleWidth;
        const height = UI.healthBar.height() * kajisuliScaleHeight;
        const innerMargin = UI.healthBar.innerMargin;
        const centerX = UI.healthBar.centerX();
        const y = UI.healthBar.y();

        // Calculate content dimensions (accounting for margin)
        const contentWidth = width - (innerMargin * 2);
        const contentHeight = height - (innerMargin * 2);

        // Calculate segment dimensions
        const segmentGapWidth = UI.healthBar.segmentGap() * kajisuliScaleWidth;
        const totalGapWidth = (maxPlayerHealth - 1) * segmentGapWidth;
        const segmentWidth = (contentWidth - totalGapWidth) / maxPlayerHealth;

        // Calculate the starting position for the first segment (like the boss health bar)
        const startX = centerX - (width / 2) + innerMargin;

        // Create each segment
        for (let i = 0; i < maxPlayerHealth; i++) {
            // Only create filled segments for current health
            const isFilled = i < playerHealth;

            // Calculate segment position - important: this is where the proper spacing happens
            const segmentX = startX + (i * (segmentWidth + segmentGapWidth));

            // Create segment with high depth
            const segment = scene.add.rectangle(
                segmentX + (segmentWidth / 2), // Center the segment at its position
                y,
                segmentWidth,
                contentHeight,
                isFilled ? UI.colors.green : UI.colors.grey
            ).setDepth(UI.depth.ui);

            // Add to group for easy management
            scene.healthSegments.add(segment);

            // Add golden separator after each segment (except the last one)
            if (i < maxPlayerHealth - 1) {
                const separatorX = segmentX + segmentWidth + (segmentGapWidth / 2);
                const separator = scene.add.rectangle(
                    separatorX,
                    y,
                    2, // Fixed width for separator
                    contentHeight,
                    UI.colors.gold
                ).setDepth(UI.depth.ui);
                scene.healthSeparators.add(separator);
            }
        }
    }
};


// Helper function to format large numbers with 4 significant digits + kanji
function formatLargeNumber(number) {
    // Return original number if it's less than 5 digits
    if (number < 10000) {
        return number.toString();
    }

    // Kanji units for powers of 10
    const kanjiUnits = [
        { value: 1000000000000, kanji: '兆' },  // trillion
        { value: 100000000000, kanji: '千億' }, // 100 billion
        { value: 10000000000, kanji: '百億' },  // 10 billion
        { value: 1000000000, kanji: '十億' },   // billion
        { value: 100000000, kanji: '億' },      // 100 million
        { value: 10000000, kanji: '千万' },     // 10 million
        { value: 1000000, kanji: '百万' },      // million
        { value: 100000, kanji: '十万' },       // 100 thousand
        { value: 10000, kanji: '万' },          // 10 thousand
        { value: 1000, kanji: '千' },           // thousand
        { value: 100, kanji: '百' },            // hundred
        { value: 10, kanji: '十' }              // ten
    ];

    // Find the appropriate unit
    for (const unit of kanjiUnits) {
        if (number >= unit.value) {
            // Calculate the significant part (keeping 4 digits)
            const scaleFactor = unit.value / 1000; // We want 4 significant digits (1000-9999)
            const significantPart = Math.floor(number / scaleFactor);

            // Format with the unit
            return `${significantPart}${unit.kanji}`;
        }
    }

    // Fallback to original number (shouldn't reach here given our units cover all cases)
    return number.toString();
}

// Experience bar functions
const ExpBar = {
    create: function (scene) {
        // Initialize relative dimensions
        UI.game.init(scene);

        // Remove old exp bar elements if they exist
        if (scene.expBar) scene.expBar.destroy();
        if (scene.expBarBg) scene.expBarBg.destroy();
        if (scene.expText) scene.expText.destroy();
        if (scene.levelText) scene.levelText.destroy();
        if (scene.xpNeededText) scene.xpNeededText.destroy();

        // Get kajisuli scale factors - wider not thicker
        const kajisuliScaleWidth = UI.kajisuli.enabled() ? 1.5 : 1;
        const kajisuliScaleHeight = 1; // Keep the same height

        // Store the scale factors for later use
        scene.expBarScales = {
            width: kajisuliScaleWidth,
            height: kajisuliScaleHeight
        };

        // Get calculated dimensions
        const width = UI.expBar.width() * kajisuliScaleWidth;
        const height = UI.expBar.height() * kajisuliScaleHeight;
        const borderWidth = UI.expBar.borderWidth;
        const innerMargin = UI.expBar.innerMargin;
        const centerX = UI.expBar.centerX();
        const y = UI.expBar.y();

        // Create new container with golden border
        scene.expBarBg = scene.add.rectangle(
            centerX,
            y,
            width + (borderWidth * 2),
            height + (borderWidth * 2),
            UI.colors.gold
        ).setDepth(UI.depth.ui);

        // Create inner black background
        scene.expBarInnerBg = scene.add.rectangle(
            centerX,
            y,
            width,
            height,
            UI.colors.black
        ).setDepth(UI.depth.ui);

        // Calculate the starting position for the exp bar (at the left edge)
        const startX = centerX - (width / 2) + innerMargin;

        // Create the exp bar itself (initially empty)
        scene.expBar = scene.add.rectangle(
            startX, // Left edge
            y,
            0, // Initial width is 0
            height - (innerMargin * 2),
            UI.expBar.barColor
        ).setOrigin(0, 0.5).setDepth(UI.depth.ui);

        // Increase spacing in kajisuli mode
        const textSpacing = UI.kajisuli.enabled() ? UI.rel.width(5) : UI.rel.width(2.5);

        // Create level text to the left of the bar
        scene.levelText = scene.add.text(
            centerX - (width / 2) - textSpacing,
            y,
            "1",
            {
                fontFamily: UI.fonts.level.family,
                fontSize: UI.kajisuli.enabled() ?
                    parseInt(UI.fonts.level.size()) * 1.2 + 'px' :
                    UI.fonts.level.size(),
                color: UI.fonts.level.color
            }
        ).setOrigin(0.5).setDepth(UI.depth.ui);

        // Create XP needed text to the right of the bar
        scene.xpNeededText = scene.add.text(
            centerX + (width / 2) + textSpacing,
            y,
            "5",
            {
                fontFamily: UI.fonts.xpNeeded.family,
                fontSize: UI.kajisuli.enabled() ?
                    parseInt(UI.fonts.xpNeeded.size()) * 1.2 + 'px' :
                    UI.fonts.xpNeeded.size(),
                color: UI.fonts.xpNeeded.color
            }
        ).setOrigin(0.5).setDepth(UI.depth.ui);

        // Initial update
        this.update(scene);
    },

    update: function (scene) {
        // If elements don't exist yet, exit
        if (!scene.expBar || !scene.levelText || !scene.xpNeededText) return;

        // Get scale factors
        const kajisuliScaleWidth = scene.expBarScales?.width ?? (UI.kajisuli.enabled() ? 1.5 : 1);
        const kajisuliScaleHeight = scene.expBarScales?.height ?? 1;

        // Get width with scaling
        const width = UI.expBar.width() * kajisuliScaleWidth;
        const innerMargin = UI.expBar.innerMargin;
        const contentWidth = width - (innerMargin * 2);

        // Calculate experience percentage
        const expPercentage = Math.max(0, Math.min(1, heroExp / xpForNextLevel(playerLevel)));

        // Set the width of the exp bar based on percentage
        scene.expBar.width = expPercentage * contentWidth;

        // Update the level text
        scene.levelText.setText(`${playerLevel}`);

        // Calculate and update the XP REMAINING text with formatting for large numbers
        const xpRemaining = xpForNextLevel(playerLevel) - heroExp;
        scene.xpNeededText.setText(formatLargeNumber(xpRemaining));
    }
};

// Status display for timer and kills
const StatusDisplay = {
    create: function (scene) {
        // Initialize relative dimensions
        UI.game.init(scene);

        // Clean up existing elements if they exist
        if (scene.timerBox) scene.timerBox.destroy();
        if (scene.timerBoxInner) scene.timerBoxInner.destroy();
        if (scene.timerText) scene.timerText.destroy();
        if (scene.timerSymbol) scene.timerSymbol.destroy();

        if (scene.killsBox) scene.killsBox.destroy();
        if (scene.killsBoxInner) scene.killsBoxInner.destroy();
        if (scene.killsText) scene.killsText.destroy();
        if (scene.killsSymbol) scene.killsSymbol.destroy();

        // Size and position adjustments for kajisuli mode
        const kajisuliScale = UI.kajisuli.enabled() ? 1.4 : 1; // 40% wider in kajisuli mode
        const fontSizeScale = UI.kajisuli.enabled() ? 0.9 : 1; // Slightly smaller font in kajisuli mode

        // Edge margin - further from edges in kajisuli mode
        const edgeMargin = UI.kajisuli.enabled() ?
            UI.rel.x(6) : // 6% from edges in kajisuli mode
            UI.statusDisplay.x(); // Default in normal mode

        // Create timer display with gold border
        const timerX = UI.kajisuli.enabled() ?
            edgeMargin + (UI.statusDisplay.timerWidth() * kajisuliScale / 2) : // Left side in kajisuli mode
            UI.statusDisplay.x() + (UI.statusDisplay.timerWidth() * kajisuliScale / 2); // Standard position

        scene.timerBox = scene.add.rectangle(
            timerX,
            UI.statusDisplay.timerY(),
            UI.statusDisplay.timerWidth() * kajisuliScale + (UI.statusDisplay.borderWidth * 2),
            UI.statusDisplay.height() + (UI.statusDisplay.borderWidth * 2),
            UI.colors.gold
        ).setDepth(UI.depth.ui).setOrigin(0.5);

        // Create inner black background for timer
        scene.timerBoxInner = scene.add.rectangle(
            timerX,
            UI.statusDisplay.timerY(),
            UI.statusDisplay.timerWidth() * kajisuliScale,
            UI.statusDisplay.height(),
            UI.colors.black
        ).setDepth(UI.depth.ui).setOrigin(0.5);

        // Create the timer text - centered in kajisuli mode
        if (UI.kajisuli.enabled()) {
            // Center time text in kajisuli mode without kanji
            scene.timerText = scene.add.text(
                timerX,
                UI.statusDisplay.timerY(),
                "00:00", // Shorter time format
                {
                    fontFamily: UI.fonts.timer.family,
                    fontSize: parseInt(UI.fonts.timer.size()) * fontSizeScale + 'px',
                    color: UI.fonts.timer.color
                }
            ).setDepth(UI.depth.ui).setOrigin(0.5);
        } else {
            // Create the timer kanji symbol in normal mode
            scene.timerSymbol = scene.add.text(
                UI.statusDisplay.x() + UI.statusDisplay.textPadding(),
                UI.statusDisplay.timerY(),
                UI.statusDisplay.clockSymbol,
                {
                    fontFamily: UI.fonts.timer.family,
                    fontSize: UI.fonts.timer.size(),
                    color: UI.fonts.timer.color
                }
            ).setDepth(UI.depth.ui).setOrigin(0, 0.5);

            // Create the timer text
            scene.timerText = scene.add.text(
                UI.statusDisplay.x() + UI.statusDisplay.timerWidth() - UI.statusDisplay.textPadding(),
                UI.statusDisplay.timerY(),
                "00:00", // Shorter time format
                {
                    fontFamily: UI.fonts.timer.family,
                    fontSize: UI.fonts.timer.size(),
                    color: UI.fonts.timer.color
                }
            ).setDepth(UI.depth.ui).setOrigin(1, 0.5);
        }

        // Adjust kills display positioning for kajisuli mode
        let killsX = UI.kajisuli.enabled() ?
            // Right side in kajisuli mode - further from edge
            UI.game.getWidth() - edgeMargin - (UI.statusDisplay.killsWidth() * kajisuliScale / 2) :
            // Normal position
            UI.statusDisplay.killsX() + (UI.statusDisplay.killsWidth() * kajisuliScale / 2);

        // Create kills display with gold border
        scene.killsBox = scene.add.rectangle(
            killsX,
            UI.statusDisplay.killsY(),
            UI.statusDisplay.killsWidth() * kajisuliScale + (UI.statusDisplay.borderWidth * 2),
            UI.statusDisplay.height() + (UI.statusDisplay.borderWidth * 2),
            UI.colors.gold
        ).setDepth(UI.depth.ui).setOrigin(0.5);

        // Create inner black background for kills
        scene.killsBoxInner = scene.add.rectangle(
            killsX,
            UI.statusDisplay.killsY(),
            UI.statusDisplay.killsWidth() * kajisuliScale,
            UI.statusDisplay.height(),
            UI.colors.black
        ).setDepth(UI.depth.ui).setOrigin(0.5);

        if (UI.kajisuli.enabled()) {
            // Create centered kills text in kajisuli mode
            scene.killsText = scene.add.text(
                killsX,
                UI.statusDisplay.killsY(),
                "0",
                {
                    fontFamily: UI.fonts.kills.family,
                    fontSize: parseInt(UI.fonts.kills.size()) * fontSizeScale + 'px',
                    color: UI.fonts.kills.color
                }
            ).setDepth(UI.depth.ui).setOrigin(0.5);
        } else {
            // Create the kills kanji symbol
            scene.killsSymbol = scene.add.text(
                UI.statusDisplay.killsX() + UI.statusDisplay.textPadding(),
                UI.statusDisplay.killsY(),
                UI.statusDisplay.deathSymbol,
                {
                    fontFamily: UI.fonts.kills.family,
                    fontSize: UI.fonts.kills.size(),
                    color: UI.fonts.kills.color
                }
            ).setDepth(UI.depth.ui).setOrigin(0, 0.5);

            // Create the kills text
            scene.killsText = scene.add.text(
                UI.statusDisplay.killsX() + UI.statusDisplay.killsWidth() - UI.statusDisplay.textPadding(),
                UI.statusDisplay.killsY(),
                "0",
                {
                    fontFamily: UI.fonts.kills.family,
                    fontSize: UI.fonts.kills.size(),
                    color: UI.fonts.kills.color
                }
            ).setDepth(UI.depth.ui).setOrigin(1, 0.5);
        }

        // Initial update
        this.update(scene);
    },

    update: function (scene, time, kills) {
        // Update timer text if it exists
        if (scene.timerText) {
            scene.timerText.setText(formatTime(time ?? elapsedTime));
        }

        // Update kills text if it exists
        if (scene.killsText) {
            scene.killsText.setText(formatLargeNumber(kills ?? score));
        }
    }
};

// Stat display rectangles for POW, AGI, LUK, END
const StatDisplay = {
    create: function (scene) {
        // Initialize relative dimensions
        UI.game.init(scene);

        // Clean up existing elements
        if (scene.statRects) {
            scene.statRects.forEach(stat => {
                if (stat.rectBg) stat.rectBg.destroy();
                if (stat.rectInner) stat.rectInner.destroy();
                if (stat.symbolText) stat.symbolText.destroy();
                if (stat.valueText) stat.valueText.destroy();
            });
        }

        // If in kajisuli mode, don't show stats on main screen
        if (UI.kajisuli.enabled()) {
            scene.statRects = [];
            return;
        }

        // Initialize the stat rectangles array
        scene.statRects = [];

        // Define stat order
        const stats = ['POW', 'AGI', 'LUK', 'END'];

        // Create each stat rectangle
        stats.forEach((stat, index) => {
            const x = UI.statDisplay.x() + (index * UI.statDisplay.spacing());

            // Create gold border rectangle
            const rectBg = scene.add.rectangle(
                x + UI.statDisplay.width() / 2,
                UI.statDisplay.y(),
                UI.statDisplay.width() + (UI.statDisplay.borderWidth * 2),
                UI.statDisplay.height() + (UI.statDisplay.borderWidth * 2),
                UI.colors.gold
            ).setDepth(UI.depth.ui).setOrigin(0.5);

            // Create inner black rectangle
            const rectInner = scene.add.rectangle(
                x + UI.statDisplay.width() / 2,
                UI.statDisplay.y(),
                UI.statDisplay.width(),
                UI.statDisplay.height(),
                UI.colors.black
            ).setDepth(UI.depth.ui).setOrigin(0.5);

            // Create the symbol text
            const symbolText = scene.add.text(
                x + UI.statDisplay.textPadding(),
                UI.statDisplay.y(),
                UI.statDisplay.symbols[stat],
                {
                    fontFamily: 'Arial',
                    fontSize: UI.statDisplay.fontSize(),
                    color: UI.statDisplay.symbolColors[stat]
                }
            ).setDepth(UI.depth.ui).setOrigin(0, 0.5);

            // Create the value text
            const valueText = scene.add.text(
                x + UI.statDisplay.width() - UI.statDisplay.textPadding(),
                UI.statDisplay.y(),
                "0",
                {
                    fontFamily: 'Arial',
                    fontSize: UI.fonts.stats.size(),
                    color: UI.fonts.stats.color
                }
            ).setDepth(UI.depth.ui).setOrigin(1, 0.5);

            // Store references
            scene.statRects[index] = {
                stat: stat,
                rectBg: rectBg,
                rectInner: rectInner,
                symbolText: symbolText,
                valueText: valueText
            };
        });

        // Initial update
        this.update(scene);
    },

    update: function (scene) {
        // Exit if elements don't exist
        if (!scene.statRects) return;

        // Update each stat value
        scene.statRects.forEach(item => {
            if (!item || !item.valueText) return;

            let value = 0;

            // Get the current value for each stat
            switch (item.stat) {
                case 'POW':
                    value = getEffectiveDamage() ?? 0;
                    break;
                case 'AGI':
                    value = getEffectiveFireRate() ?? 0;
                    break;
                case 'LUK':
                    value = playerLuck ?? 0;
                    break;
                case 'END':
                    value = maxPlayerHealth ?? 0;
                    break;
            }

            // Update the display
            item.valueText.setText(Math.floor(value).toString());
        });
    }
};

// Function to create all UI elements
function createUI(scene) {
    // Initialize relative dimensions with the scene
    UI.game.init(scene);

    HealthBar.create(scene);
    ExpBar.create(scene);
    StatusDisplay.create(scene);
    StatDisplay.create(scene);
}

// Method to update UI on window resize (to be called when game canvas is resized)
function resizeUI(scene) {
    // Re-create all UI elements with new dimensions
    createUI(scene);
}

// Export for use in the main game
window.GameUI = {
    createUI: createUI,
    updateHealthBar: HealthBar.update,
    updateExpBar: ExpBar.update,
    updateStatusDisplay: StatusDisplay.update,
    updateStatCircles: StatDisplay.update,
    resize: resizeUI
};

// Adding to the existing UI namespace in menu.js
UI.gameEndScreen = {
    width: function () { return UI.rel.width(50); },     // 50% of screen width
    height: function () { return UI.rel.height(60); },   // 60% of screen height
    y: function () { return UI.rel.y(50); },             // Center of screen vertically
    x: function () { return UI.rel.x(50); },             // Center of screen horizontally
    borderWidth: 4,
    innerPadding: function () { return UI.rel.width(2); }, // 2% padding inside
    fontSizes: {
        title: function () { return `${UI.rel.fontSize(4)}px`; },     // 4% of screen height
        subtitle: function () { return `${UI.rel.fontSize(3)}px`; },  // 3% of screen height
        stats: function () { return `${UI.rel.fontSize(2.5)}px`; },   // 2.5% of screen height
        button: function () { return `${UI.rel.fontSize(3)}px`; }     // 3% of screen height
    }
};

// Game End Menu System for Word Survivors
// Manages both victory and defeat end screens

// Adding to the existing UI namespace in menu.js
// Modified gameEndScreen to support minimum width for small screens
UI.gameEndScreen = {
    // Width with minimum size to prevent squashing on small screens
    width: function () {
        const calculatedWidth = UI.rel.width(50); // Original 50% of screen width
        return Math.max(calculatedWidth, 480); // Minimum 480px width
    },
    height: function () { return UI.rel.height(60); },   // 60% of screen height
    y: function () { return UI.rel.y(50); },             // Center of screen vertically
    x: function () { return UI.rel.x(50); },             // Center of screen horizontally
    borderWidth: 4,
    innerPadding: function () { return UI.rel.width(2); }, // 2% padding inside
    // Scale factor for text based on screen width relative to baseline 1200px
    scaleFactor: function () {
        // Calculate based on actual width and baseline of 1200px
        const minScale = 0.8; // Minimum scale factor (used at 480px width)
        const baselineWidth = 1200;
        const currentWidth = UI.game.getWidth();

        // Scale relative to the baseline, but not below minimum
        return Math.max(minScale, currentWidth / baselineWidth);
    },
    fontSizes: {
        title: function () {
            // Scale the font size by the scale factor
            return `${UI.rel.fontSize(4) * UI.gameEndScreen.scaleFactor()}px`;
        },
        subtitle: function () {
            return `${UI.rel.fontSize(3) * UI.gameEndScreen.scaleFactor()}px`;
        },
        stats: function () {
            return `${UI.rel.fontSize(2.5) * UI.gameEndScreen.scaleFactor()}px`;
        },
        button: function () {
            return `${UI.rel.fontSize(3) * UI.gameEndScreen.scaleFactor()}px`;
        }
    }
};

// Game End Menu component - modified for better small screen support
const GameEndMenu = {
    // UI elements
    elements: {
        container: null,         // Container for all elements
        background: null,        // Background rectangle
        borderRect: null,        // Golden border
        heroKanji: null,         // Hero kanji (white)
        titleText: null,         // Main title text (gold)
        enemyKanji: null,        // Enemy kanji (enemy color)
        subtitleText: null,      // Subtitle text (gold)
        statsText: null,         // Time and kills (gold)
        restartButton: null,     // Restart button
        restartButtonBorder: null // Button border
    },

    enterKeyHandler: null,

    // Create the game end screen (victory or defeat)
    create: function (scene, isVictory = false, enemyKanji = null, bossKanji = null) {
        // Clean up any existing menu first
        this.destroy();

        // Create a container with high depth for all elements
        this.elements.container = scene.add.container(0, 0);
        this.elements.container.setDepth(1000); // Same depth as pause screen

        // Create black semi-transparent background for full screen
        const fullscreenBg = scene.add.rectangle(
            UI.game.getWidth() / 2,
            UI.game.getHeight() / 2,
            UI.game.getWidth(),
            UI.game.getHeight(),
            0x000000, 0.7
        );
        this.elements.container.add(fullscreenBg);

        // Create panel black background (solid black)
        this.elements.background = scene.add.rectangle(
            UI.gameEndScreen.x(),
            UI.gameEndScreen.y(),
            UI.gameEndScreen.width(),
            UI.gameEndScreen.height(),
            0x000000
        );
        this.elements.container.add(this.elements.background);

        // Create golden border - as a stroke around the black background
        this.elements.borderRect = scene.add.rectangle(
            UI.gameEndScreen.x(),
            UI.gameEndScreen.y(),
            UI.gameEndScreen.width(),
            UI.gameEndScreen.height()
        );
        this.elements.borderRect.setStrokeStyle(UI.gameEndScreen.borderWidth, 0xFFD700); // Explicit gold color
        this.elements.container.add(this.elements.borderRect);

        // Determine content based on victory or defeat
        if (isVictory) {
            this.createVictoryContent(scene, bossKanji);
        } else {
            this.createDefeatContent(scene, enemyKanji);
        }

        // Create restart button (same for both victory and defeat)
        this.createRestartButton(scene);

        // Add keyboard handler for Enter key to restart
        this.setupKeyboardHandler(scene);

        return this.elements.container;
    },

    createEndGameContent: function (scene, options) {
        // Default options
        const defaults = {
            isVictory: false,           // Victory or defeat
            heroKanjiOffset: -200,      // X offset for hero kanji
            titleTextOffset: -150,      // X offset for title text
            titleText: "",              // Main title text
            subtitleText: "",           // Subtitle text
            subtitleCentered: false,    // Whether subtitle should be centered
            subtitleTextOffset: 0,      // X offset for subtitle
            enemyKanji: "敵",           // Kanji to show for enemy
            enemyKanjiOffset: 200,      // X offset for enemy kanji
            statsTemplate: ""           // Template for stats text
        };

        // Merge with provided options
        const config = { ...defaults, ...options };
        const centerX = UI.gameEndScreen.x();
        const titleY = UI.gameEndScreen.y() - UI.gameEndScreen.height() / 3;
        const subtitleY = UI.gameEndScreen.y() - UI.gameEndScreen.height() / 6;
        const scaleFactor = UI.gameEndScreen.scaleFactor();

        // Calculate positions with proper scaling
        const heroKanjiX = centerX + (config.heroKanjiOffset * scaleFactor);
        const titleTextX = centerX + (config.titleTextOffset * scaleFactor);

        // Subtitle position
        const subtitleTextX = config.subtitleCentered ?
            centerX :
            centerX + (config.subtitleTextOffset * scaleFactor);

        // Enemy position
        const enemyKanjiX = centerX + (config.enemyKanjiOffset * scaleFactor);

        // Create hero kanji in WHITE
        this.elements.heroKanji = scene.add.text(
            heroKanjiX,
            titleY,
            HERO_CHARACTER,
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.title(),
                color: '#FFFFFF', // White for hero
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);
        this.elements.container.add(this.elements.heroKanji);

        // Create title text in GOLD
        this.elements.titleText = scene.add.text(
            titleTextX,
            titleY,
            config.titleText,
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.title(),
                color: '#FFD700', // Gold color
                fontStyle: 'bold'
            }
        ).setOrigin(0, 0.5); // Left aligned
        this.elements.container.add(this.elements.titleText);

        // Create subtitle text in GOLD
        const subtitleOrigin = config.subtitleCentered ? 0.5 : 0.5;
        this.elements.subtitleText = scene.add.text(
            subtitleTextX,
            subtitleY,
            config.subtitleText,
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.title(),
                color: '#FFD700', // Gold color
                fontStyle: 'bold'
            }
        ).setOrigin(subtitleOrigin);
        this.elements.container.add(this.elements.subtitleText);

        // Create enemy kanji
        this.elements.enemyKanji = scene.add.text(
            enemyKanjiX,
            subtitleY,
            config.enemyKanji,
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.title(),
                color: '#FF5555', // Red color for enemy
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);
        this.elements.container.add(this.elements.enemyKanji);

        // Create stats line
        this.elements.statsText = scene.add.text(
            centerX,
            UI.gameEndScreen.y() + UI.gameEndScreen.height() / 10,
            config.statsTemplate,
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.stats(),
                color: '#FFD700', // Gold color
                align: 'center'
            }
        ).setOrigin(0.5);
        this.elements.container.add(this.elements.statsText);

        // If score system is available, animate the stats into score
        if (window.ScoreSystem) {
            // Calculate score based on victory condition
            const score = ScoreSystem.calculateScore(config.isVictory);

            // Animate the score reveal
            ScoreSystem.animateScoreReveal(scene, this.elements.statsText, score);
        }
    },

    // Create content for victory screen
    createVictoryContent: function (scene, bossKanji) {
        // The boss kanji to display (use a generic one if not specified)
        const bossSymbol = bossKanji ?? (activeBoss?.text ?? '魔');

        // Create victory screen content
        this.createEndGameContent(scene, {
            isVictory: true,
            heroKanjiOffset: -200,
            titleTextOffset: -150,
            titleText: 'ESCAPED THE LOOP',
            subtitleText: 'VANQUISHING',
            subtitleCentered: true,
            subtitleTextOffset: 0,
            enemyKanji: bossSymbol,
            enemyKanjiOffset: 180,
            statsTemplate: `IN ${formatTime(elapsedTime)}          FREED ${score}`
        });
    },


    // Create content for defeat screen
    createDefeatContent: function (scene, enemyKanji) {
        // The enemy kanji to display (use a generic one if not specified)
        const enemySymbol = enemyKanji ?? '敵';

        // Create defeat screen content
        this.createEndGameContent(scene, {
            isVictory: false,
            heroKanjiOffset: -220,
            titleTextOffset: -160,
            titleText: 'FOUND THEIR DEMISE',
            subtitleText: 'AT THE HANDS OF',
            subtitleCentered: false,
            subtitleTextOffset: -60,
            enemyKanji: enemySymbol,
            enemyKanjiOffset: 180,
            statsTemplate: `SURVIVED ${formatTime(elapsedTime)}          DEFEATED ${score}`
        });
    },

    // Create restart button for both screens
    createRestartButton: function (scene) {
        const buttonY = UI.gameEndScreen.y() + UI.gameEndScreen.height() / 3;
        const buttonX = UI.gameEndScreen.x();
        const buttonPadding = 20;

        // Create button text in GOLD
        this.elements.restartButton = scene.add.text(
            buttonX,
            buttonY,
            'RESTART THE LOOP',
            {
                fontFamily: 'Arial',
                fontSize: UI.gameEndScreen.fontSizes.button(),
                color: '#FFD700', // Explicit gold color
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);

        // Create button border as a rectangle with GOLD stroke
        const buttonWidth = this.elements.restartButton.width + buttonPadding * 2;
        const buttonHeight = this.elements.restartButton.height + buttonPadding * 2;

        this.elements.restartButtonBorder = scene.add.rectangle(
            buttonX,
            buttonY,
            buttonWidth,
            buttonHeight
        );
        this.elements.restartButtonBorder.setStrokeStyle(2, 0xFFD700); // Explicit gold color
        this.elements.container.add(this.elements.restartButtonBorder);
        this.elements.container.add(this.elements.restartButton);

        // Make button interactive - use the text element for interaction
        this.elements.restartButton.setInteractive({ useHandCursor: true });

        // Add hover effect - white text and thicker border
        this.elements.restartButton.on('pointerover', () => {
            // Change text to white
            this.elements.restartButton.setColor('#FFFFFF');
            // Make border thicker
            this.elements.restartButtonBorder.setStrokeStyle(3, 0xFFD700);
            // Scale up slightly
            scene.tweens.add({
                targets: [this.elements.restartButton, this.elements.restartButtonBorder],
                scale: 1.05,
                duration: 100
            });
        });

        // Reset on pointer out
        this.elements.restartButton.on('pointerout', () => {
            // Change text back to gold
            this.elements.restartButton.setColor('#FFD700');
            // Reset border thickness
            this.elements.restartButtonBorder.setStrokeStyle(2, 0xFFD700);
            // Scale back to normal
            scene.tweens.add({
                targets: [this.elements.restartButton, this.elements.restartButtonBorder],
                scale: 1,
                duration: 100
            });
        });

        this.elements.restartButton.on('pointerdown', function () {
            // Try to skip any active animation, with delay if successful
            const animationSkipped = window.ScoreSystem?.skipToFinalScore?.(scene) || false;

            // Restart immediately or with delay based on whether animation was skipped
            if (animationSkipped) {
                scene.time.delayedCall(250, () => startGame.call(scene));
            } else {
                startGame.call(scene);
            }
        });
    },

    // Setup keyboard handler for Enter key
    setupKeyboardHandler: function (scene) {
        // Clean up any existing handler first
        this.cleanupKeyboardHandler();

        // Create new enter key handler
        this.enterKeyHandler = function (event) {
            if (event.key === 'Enter') {
                // Remove this listener before restarting
                GameEndMenu.cleanupKeyboardHandler();

                // Start the game
                startGame.call(scene);
            }
        };

        // Add global keydown listener for Enter
        window.addEventListener('keydown', this.enterKeyHandler);
    },

    // Show the victory screen
    showVictoryScreen: function (scene) {
        // Get the boss kanji if available
        const bossKanji = activeBoss ? activeBoss.text : null;

        // Create the victory screen
        return this.create(scene, true, null, bossKanji);
    },

    // Show the defeat screen
    showDefeatScreen: function (scene, enemyKanji) {
        // Create the defeat screen
        return this.create(scene, false, enemyKanji);
    },

    // Add a cleanup function
    cleanupKeyboardHandler: function () {
        if (this.enterKeyHandler) {
            window.removeEventListener('keydown', this.enterKeyHandler);
            this.enterKeyHandler = null;
        }
    },

    // Modify destroy to use the cleanup function
    destroy: function () {
        this.cleanupKeyboardHandler();

        if (this.elements.container) {
            this.elements.container.destroy();
        }

        // Reset all element references
        Object.keys(this.elements).forEach(key => {
            this.elements[key] = null;
        });
    }
};

// Export the menu system for use in other files
window.GameEndMenu = GameEndMenu;

// ======= music.js =======
// Music System for Word Survivors
// Handles background music with smooth transitions and shuffled playlists
// Loads only one track at a time, when needed

const MusicSystem = {
    // Music tracks and playback state
    tracks: [],             // List of available track IDs (not loaded yet)
    playQueue: [],          // Shuffled play order
    currentTrackIndex: -1,  // Index of currently playing track in playQueue
    currentTrack: null,     // Reference to the currently playing Phaser Sound object
    fadeInTween: null,      // Reference to fade-in tween
    fadeOutTween: null,     // Reference to fade-out tween
    silenceTimer: null,     // Timer for silence between tracks
    nextTrackToPlay: null,  // The next track we plan to play
    isLoading: false,       // Flag to track if we're currently loading a track

    // Configuration
    silenceDuration: 4000,  // 4 seconds of silence between tracks
    fadeDuration: 4000,     // 4 seconds fade in/out
    volume: 0.7,            // Default maximum volume (0-1)
    musicEnabled: true,     // Music enabled/disabled flag
    currentRate: 1.0,       // Current playback rate (affected by time dilation)

    // Pause settings
    pausedVolume: 0.3,      // Volume level when paused (30% of normal)
    savedVolume: null,      // Store the original volume during pause
    pausePulseTween: null,  // Reference to pulse effect tween
    lowPassFilter: null,    // Reference to Web Audio low-pass filter

    // Boss fight effect settings
    bossFilterNode: null,   // High-pass filter for boss fights
    chorusNodes: [],        // Array of delay nodes for chorus effect
    isInBossFight: false,   // Track if boss fight mode is active
    originalAudioPath: null, // Store original audio routing

    // Initialize the music system
    initialize: function (scene) {
        console.log("Initializing music system");

        // Clear any existing tracks
        this.tracks = [];
        this.playQueue = [];
        this.currentTrackIndex = -1;
        this.currentRate = 1.0;
        this.nextTrackToPlay = null;
        this.isLoading = false;

        // Store scene reference for later use
        this.scene = scene;

        return this;
    },

    // Preload just track metadata, not actual audio content
    preload: function (scene) {
        // Just build a list of track IDs without loading them
        for (let i = 1; i <= 23; i++) {
            const trackId = `track-${String(i).padStart(2, '0')}`;
            this.tracks.push(trackId);
        }

        // Shuffle the tracks for initial play order
        this.shuffleArray(this.tracks);

        // Set up the play queue
        this.playQueue = [...this.tracks];
        this.currentTrackIndex = -1;

        console.log("Music system ready (tracks will load as needed)");
    },

    // Helper to shuffle an array
    shuffleArray: function (array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    },

    // Called after preload to set up the system
    create: function (scene) {
        // Nothing to do here - we'll load tracks as needed
        return this;
    },

    // Start playing music
    start: function () {
        if (!this.musicEnabled || !this.scene) return;

        // If nothing playing, start
        if (!this.currentTrack) {
            this.playNextTrack();
        }
    },

    // Load and play the next track
    playNextTrack: function () {
        if (!this.musicEnabled || !this.scene || this.isLoading) return;

        // If we've reached the end of the queue, create a new shuffled queue
        if (this.currentTrackIndex >= this.playQueue.length - 1) {
            this.createNewPlayQueue();
        }

        // Move to next track
        this.currentTrackIndex++;

        // Get the next track ID
        const nextTrackId = this.playQueue[this.currentTrackIndex];
        this.nextTrackToPlay = nextTrackId;

        console.log(`Preparing to play next track: ${nextTrackId}`);

        // Start silence period - we'll load the track during this time
        this.startSilencePeriod(nextTrackId);
    },

    // Start a silence period before playing the specified track
    startSilencePeriod: function (trackId) {
        console.log(`Starting silence period before track: ${trackId}`);

        // Clear any existing silence timer
        if (this.silenceTimer) {
            if (typeof this.silenceTimer === 'number') {
                clearTimeout(this.silenceTimer);
            } else if (this.silenceTimer.remove) {
                this.silenceTimer.remove();
            }
            this.silenceTimer = null;
        }

        // Start loading the track immediately
        this.loadTrack(trackId);

        // Schedule playback after the silence period
        this.silenceTimer = setTimeout(() => {
            // Check if track loaded successfully
            if (this.scene.sound.get(trackId)) {
                console.log("Silence period complete, starting track");
                this.startTrackWithFadeIn(trackId);
            } else {
                // If track isn't loaded yet, wait a bit more or skip
                console.log(`Track ${trackId} not loaded yet, waiting...`);
                this.silenceTimer = setTimeout(() => {
                    if (this.scene.sound.get(trackId)) {
                        this.startTrackWithFadeIn(trackId);
                    } else {
                        console.log(`Giving up on track ${trackId}, skipping to next`);
                        this.playNextTrack();
                    }
                }, 2000); // Wait 2 more seconds
            }
        }, this.silenceDuration);
    },

    // Load a track just-in-time
    loadTrack: function (trackId) {
        // Skip if already loaded
        if (this.scene.sound.get(trackId)) {
            console.log(`Track ${trackId} already loaded`);
            return;
        }

        // Mark as loading
        this.isLoading = true;
        console.log(`Loading track: ${trackId}`);

        const trackPath = `../music/${trackId}.mp3`;

        // Create a loader for just this track
        const loader = new Phaser.Loader.LoaderPlugin(this.scene);

        // Load the track
        loader.audio(trackId, trackPath);

        // Handle completion
        loader.once('complete', () => {
            console.log(`Finished loading track: ${trackId}`);

            // Add to sound manager
            this.scene.sound.add(trackId, {
                loop: false,
                volume: 0
            });

            this.isLoading = false;

            // If this is the track we're waiting to play and we're in silence, 
            // we can reduce the silence duration
            if (trackId === this.nextTrackToPlay && this.silenceTimer) {
                clearTimeout(this.silenceTimer);
                this.silenceTimer = setTimeout(() => {
                    this.startTrackWithFadeIn(trackId);
                }, 500); // Just wait half a second
            }
        });

        // Handle errors
        loader.once('loaderror', (fileObj) => {
            console.error(`Error loading track: ${trackId}`, fileObj);
            this.isLoading = false;

            // If this is the track we're waiting to play, skip to next
            if (trackId === this.nextTrackToPlay) {
                console.log("Skipping to next track due to load error");
                this.playNextTrack();
            }
        });

        // Start loading
        loader.start();
    },

    // Start playing a track with fade-in
    startTrackWithFadeIn: function (trackId) {
        if (!this.musicEnabled || !this.scene) return;

        // Get the sound object for this track
        const track = this.scene.sound.get(trackId);
        if (!track) {
            console.error(`Track not found: ${trackId}`);
            this.playNextTrack(); // Skip to next track
            return;
        }

        // Stop any currently playing track with immediate fade out
        if (this.currentTrack && this.currentTrack.isPlaying) {
            // Cancel existing fade out if any
            if (this.fadeOutTween) {
                this.fadeOutTween.stop();
                this.fadeOutTween = null;
            }

            // Create quick fade out (500ms)
            this.fadeOutTween = this.scene.tweens.add({
                targets: this.currentTrack,
                volume: 0,
                duration: 500,
                ease: 'Linear',
                onComplete: () => {
                    // Stop the old track
                    this.currentTrack.stop();
                    this.fadeOutTween = null;
                }
            });
        }

        // Store reference to current track
        this.currentTrack = track;

        // Set the initial playback rate based on current time dilation
        track.setRate(this.currentRate);

        // Start playing at 0 volume
        track.setVolume(0);
        track.play();

        // Re-apply boss fight effect if it was active
        if (this.isInBossFight) {
            console.log("Re-applying boss fight effect to new track");
            this.applyBossFightEffect();
        }

        // Create fade-in tween
        this.fadeInTween = this.scene.tweens.add({
            targets: track,
            volume: this.volume,
            duration: this.fadeDuration,
            ease: 'Linear',
            onComplete: () => {
                console.log("Fade-in complete");
                this.fadeInTween = null;

                // Calculate when to start fade-out
                const trackDuration = track.totalDuration * 1000; // Convert to ms
                const adjustedDuration = trackDuration / this.currentRate; // Adjust for time dilation
                const fadeOutTime = Math.max(0, adjustedDuration - this.fadeDuration);

                console.log(`Scheduling fade-out in ${fadeOutTime}ms (real time)`);

                // Early load the next track when we're about 20 seconds from the end
                if (fadeOutTime > 25000) {
                    setTimeout(() => {
                        const nextIdx = this.currentTrackIndex + 1;
                        if (nextIdx < this.playQueue.length) {
                            const nextTrackId = this.playQueue[nextIdx];
                            this.loadTrack(nextTrackId);
                        }
                    }, fadeOutTime - 20000);
                }

                // Use JavaScript setTimeout instead of Phaser timer
                // This continues to run even when game is paused
                setTimeout(() => {
                    console.log("Time to start fade-out (from real timer)");
                    this.startFadeOut();
                }, fadeOutTime);
            }
        });
    },

    // Create a new shuffled play queue
    createNewPlayQueue: function () {
        // Clone the tracks array
        const newQueue = [...this.tracks];

        // Shuffle using Fisher-Yates algorithm
        this.shuffleArray(newQueue);

        // If we already had a queue and it's not empty, make sure we don't repeat the last song
        if (this.playQueue.length > 0 && this.currentTrackIndex >= 0) {
            const lastPlayedTrack = this.playQueue[this.currentTrackIndex];

            // If the first track in our new queue is the same as the last played track
            if (newQueue[0] === lastPlayedTrack) {
                // Swap with a random track that's not at index 0
                const swapIndex = 1 + Math.floor(Math.random() * (newQueue.length - 1));
                [newQueue[0], newQueue[swapIndex]] = [newQueue[swapIndex], newQueue[0]];
            }
        }

        // Set the new queue
        this.playQueue = newQueue;
        this.currentTrackIndex = -1; // Reset to start of queue
    },

    // Apply time dilation to current music
    applyTimeDilation: function (timeScale) {
        // Skip if no track is currently playing
        if (!this.currentTrack || !this.currentTrack.isPlaying) return;

        // Store the current rate for reference
        this.currentRate = timeScale;

        // Apply time scale to music - this will affect both speed and pitch
        this.currentTrack.setRate(timeScale);
    },

    // Enable or disable music
    setMusicEnabled: function (enabled) {
        this.musicEnabled = enabled;

        // If disabling, stop current playback
        if (!enabled && this.currentTrack) {
            this.stopCurrentTrack();
        } else if (enabled && !this.currentTrack && this.scene) {
            // If enabling and nothing is playing, start playback
            this.playNextTrack();
        }

        return this.musicEnabled;
    },

    // Set music volume (affects maximum volume during playback)
    setVolume: function (volume) {
        this.volume = Phaser.Math.Clamp(volume, 0, 1);

        // Update volume of currently playing track during fade-in/fade-out
        if (this.currentTrack && this.currentTrack.isPlaying) {
            // For simplicity, we don't modify existing tweens, just cap their target value
            if (this.fadeInTween && this.fadeInTween.isPlaying()) {
                // Let the tween continue, but cap at new volume
                this.fadeInTween.updateTo('volume', this.volume, true);
            } else if (!this.fadeOutTween || !this.fadeOutTween.isPlaying()) {
                // If not in a transition, set to current volume directly
                this.currentTrack.setVolume(this.volume);
            }
        }

        return this.volume;
    },

    // Stop all music playback
    stop: function () {
        this.stopCurrentTrack();

        // Also clear any pending timers
        if (this.silenceTimer) {
            if (typeof this.silenceTimer === 'number') {
                clearTimeout(this.silenceTimer);
            } else if (this.silenceTimer.remove) {
                this.silenceTimer.remove();
            }
            this.silenceTimer = null;
        }
    },

    // Start fading out the current track
    startFadeOut: function () {
        if (!this.currentTrack || !this.currentTrack.isPlaying) return;

        // Create fade-out tween
        this.fadeOutTween = this.scene.tweens.add({
            targets: this.currentTrack,
            volume: 0,
            duration: this.fadeDuration,
            ease: 'Linear',
            onComplete: () => {
                // Stop the track and clean up
                this.stopCurrentTrack();

                // Play the next track
                this.playNextTrack();
            }
        });
    },

    // Stop the current track and clean up
    stopCurrentTrack: function () {
        // Clean up tweens
        if (this.fadeInTween) {
            this.fadeInTween.stop();
            this.fadeInTween = null;
        }

        if (this.fadeOutTween) {
            this.fadeOutTween.stop();
            this.fadeOutTween = null;
        }

        // Stop the track
        if (this.currentTrack && this.currentTrack.isPlaying) {
            this.currentTrack.stop();
        }

        this.currentTrack = null;
    },

    // Update method (call from scene's update)
    update: function (time, delta) {
        // Nothing to update - tweens and timers are handled automatically
    },

    // Clean up resources (call when changing scenes)
    cleanup: function () {
        this.stop();

        // Clear any silence timer
        if (this.silenceTimer) {
            if (typeof this.silenceTimer === 'number') {
                clearTimeout(this.silenceTimer);
            } else if (this.silenceTimer.remove) {
                this.silenceTimer.remove();
            }
            this.silenceTimer = null;
        }
    },

    onGamePause: function () {
        console.log("Game paused, applying muffled effect to music");

        // Skip if no track is playing
        if (!this.currentTrack || (!this.currentTrack.isPlaying && !this.currentTrack.isPaused)) {
            return;
        }

        try {
            // Save the current volume
            this.savedVolume = this.currentTrack.volume;

            // Apply volume reduction for muffled effect
            this.currentTrack.setVolume(this.pausedVolume || 0.3);

            // Try to apply low-pass filter (advanced effect)
            if (this.scene && this.scene.sound && this.scene.sound.context &&
                this.currentTrack.source && this.currentTrack.source.disconnect) {

                const audioContext = this.scene.sound.context;

                // Create a low-pass filter
                this.lowPassFilter = audioContext.createBiquadFilter();
                this.lowPassFilter.type = 'lowpass';
                this.lowPassFilter.frequency.value = 800; // Lower = more muffled
                this.lowPassFilter.Q.value = 0.5;

                // Get the current destination
                const destination = this.currentTrack.source.destination || audioContext.destination;

                // Connect through the filter
                this.currentTrack.source.disconnect();
                this.currentTrack.source.connect(this.lowPassFilter);
                this.lowPassFilter.connect(destination);

                console.log("Applied low-pass filter");
            }

            // Create a simple volume pulse effect
            const pulseData = { volume: this.pausedVolume || 0.3 };

            // Create a slow pulsing effect
            this.pausePulseTween = this.scene.tweens.add({
                targets: pulseData,
                volume: (this.pausedVolume || 0.3) * 0.7, // Pulse to 70% of pause volume
                duration: 2000,
                ease: 'Sine.easeInOut',
                yoyo: true,
                repeat: -1,
                onUpdate: () => {
                    // Only modify volume if track still exists
                    if (this.currentTrack) {
                        this.currentTrack.setVolume(pulseData.volume);
                    }
                }
            });
        } catch (err) {
            console.log("Error applying pause effects:", err);
        }
    },

    // Remove the muffled effect when game is resumed
    onGameResume: function () {
        console.log("Game resumed, removing muffled effect");

        // Skip if no track exists
        if (!this.currentTrack) {
            return;
        }

        try {
            // Stop the pulse effect if it exists
            if (this.pausePulseTween) {
                this.pausePulseTween.stop();
                this.pausePulseTween = null;
            }

            // Restore volume
            if (this.savedVolume !== undefined) {
                this.currentTrack.setVolume(this.savedVolume);
                this.savedVolume = undefined;
            } else {
                // Fallback to normal volume
                this.currentTrack.setVolume(this.volume);
            }

            // Remove low-pass filter if we applied one
            if (this.lowPassFilter && this.currentTrack.source &&
                this.currentTrack.source.disconnect) {
                try {
                    const audioContext = this.scene.sound.context;
                    const destination = this.currentTrack.source.destination || audioContext.destination;

                    // Reconnect without the filter
                    this.currentTrack.source.disconnect();
                    this.currentTrack.source.connect(destination);

                    console.log("Removed low-pass filter from track");

                    // If we're in boss fight mode, re-apply the boss fight effect
                    if (this.isInBossFight) {
                        console.log("Re-applying boss fight effect after pause");
                        this.applyBossFightEffect();
                    }
                } catch (err) {
                    console.log("Error removing filter:", err);
                }
            } else if (this.isInBossFight) {
                // If we didn't have a low-pass filter but we're in boss mode,
                // make sure the boss effect is applied
                console.log("Re-applying boss fight effect after pause (no low-pass filter)");
                this.applyBossFightEffect();
            }
        } catch (err) {
            console.log("Error removing pause effects:", err);
        }
    },

    // Helper method to apply low-pass filter
    applyLowPassFilter: function () {
        // Only attempt if Web Audio API is available
        if (!this.scene || !this.scene.sound || !this.scene.sound.context) {
            return;
        }

        try {
            const audioContext = this.scene.sound.context;

            // Create a low-pass filter
            if (!this.lowPassFilter) {
                this.lowPassFilter = audioContext.createBiquadFilter();
                this.lowPassFilter.type = 'lowpass';
                this.lowPassFilter.frequency.value = 800; // Lower = more muffled
                this.lowPassFilter.Q.value = 0.5;
            }

            // Only try to connect if we have access to the source
            if (this.currentTrack.source &&
                typeof this.currentTrack.source.disconnect === 'function' &&
                typeof this.currentTrack.source.connect === 'function') {

                // Get the current destination
                const destination = this.currentTrack.source.destination || audioContext.destination;

                // Connect through the filter
                this.currentTrack.source.disconnect();
                this.currentTrack.source.connect(this.lowPassFilter);
                this.lowPassFilter.connect(destination);

                console.log("Applied low-pass filter");
            }
        } catch (err) {
            console.log("Low-pass filter not supported:", err);
        }
    },

    // Helper method to create volume pulse effect
    createPauseVolumeEffect: function () {
        // Skip if we don't have a scene or the track isn't playing
        if (!this.scene || !this.currentTrack) {
            return;
        }

        // Clean up any existing pulse effect
        if (this.pausePulseTween) {
            this.pausePulseTween.stop();
            this.pausePulseTween = null;
        }

        // Create a simple data object to tween
        const pulseData = { volume: this.pausedVolume };

        try {
            // Create a slow pulsing effect
            this.pausePulseTween = this.scene.tweens.add({
                targets: pulseData,
                volume: this.pausedVolume * 0.7, // Pulse to 70% of pause volume
                duration: 2000,
                ease: 'Sine.easeInOut',
                yoyo: true,
                repeat: -1,
                onUpdate: () => {
                    // Only modify volume if track still exists
                    if (this.currentTrack) {
                        this.currentTrack.setVolume(pulseData.volume);
                    }
                }
            });

            console.log("Created pause pulse effect");
        } catch (err) {
            console.log("Error creating pulse effect:", err);
        }
    },

    // Helper to remove low-pass filter
    removeLowPassFilter: function () {
        if (!this.lowPassFilter || !this.currentTrack || !this.currentTrack.source) {
            return;
        }

        try {
            // Only attempt if we have the necessary methods
            if (typeof this.currentTrack.source.disconnect === 'function' &&
                typeof this.currentTrack.source.connect === 'function') {

                const audioContext = this.scene.sound.context;
                const destination = this.currentTrack.source.destination || audioContext.destination;

                // Reconnect without the filter
                this.currentTrack.source.disconnect();
                this.currentTrack.source.connect(destination);

                console.log("Removed low-pass filter");
            }
        } catch (err) {
            console.log("Error removing filter:", err);
        }
    },

    // We've tried various effects and none feel right. Maybe revisit later, leave it for now just in case
    applyBossFightEffect: function () {
        // No boss music effect - just set the flag and return
        this.isInBossFight = true;
        return true;
    },

    removeBossFightEffect: function () {
        // Just reset the flag and return
        this.isInBossFight = false;
        return true;
    }
};

// Export the music system
window.MusicSystem = MusicSystem;

// ======= nexus.js =======
// Orbital Component Registry for Word Survivors
// Maps perks to orbital effects and configurations

// Registry system for orbital perks
const OrbitalPerkRegistry = {
    // Map perks to their orbital configurations
    perkOrbitalConfigs: {},

    // Register a perk that creates orbitals
    registerPerkOrbital: function (perkId, config) {
        this.perkOrbitalConfigs[perkId] = {
            getConfig: config.getConfig ?? function () { return {}; }, // Function that returns orbital config
            count: config.count ?? 1,                                // Number of orbitals to create
            cooldown: config.cooldown ?? null,                       // Cooldown between creating orbitals (null for one-time)
            activationMethod: config.activationMethod ?? 'immediate' // How the orbital is activated (immediate, onHit, etc.)
        };
    },

    // Apply a perk's orbital effect
    applyPerkOrbital: function (scene, perkId) {
        // Check if we have a configuration for this perk
        const perkConfig = this.perkOrbitalConfigs[perkId];
        if (!perkConfig) return false;

        console.log(`Applying orbital perk: ${perkId}`);

        // Handle different activation methods
        switch (perkConfig.activationMethod) {
            case 'immediate':
                this.createOrbitalImmediately(scene, perkConfig);
                break;

            case 'timer':
                this.setupOrbitalTimer(scene, perkConfig);
                break;

            default:
                console.log(`Unknown activation method: ${perkConfig.activationMethod}`);
                return false;
        }

        return true;
    },

    // Create an orbital immediately
    createOrbitalImmediately: function (scene, perkConfig) {
        // Get the configuration for this orbital
        const orbitalConfig = perkConfig.getConfig();

        // Create the orbital(s)
        if (perkConfig.count > 1) {
            OrbitalSystem.createMultiple(scene, perkConfig.count, orbitalConfig);
        } else {
            OrbitalSystem.create(scene, orbitalConfig);
        }
    },

    // Setup a timer to periodically create orbitals
    setupOrbitalTimer: function (scene, perkConfig) {
        if (!perkConfig.cooldown) return;

        // Calculate cooldown based on player stats if needed
        let cooldown = perkConfig.cooldown;
        if (typeof cooldown === 'function') {
            cooldown = cooldown();
        }

        // Create timer to spawn orbitals
        const timer = scene.time.addEvent({
            delay: cooldown,
            callback: function () {
                // Get fresh configuration each time (in case player stats changed)
                const orbitalConfig = perkConfig.getConfig();

                // Create the orbital(s)
                if (perkConfig.count > 1) {
                    OrbitalSystem.createMultiple(scene, perkConfig.count, orbitalConfig);
                } else {
                    OrbitalSystem.create(scene, orbitalConfig);
                }
            },
            callbackScope: scene,
            loop: true
        });

        // Register timer for cleanup
        window.registerEffect('timer', timer);
    }
};

// Register the Wild Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('WILD_FAIRY', {
    getConfig: function () {
        return {
            symbol: '妖', // Kanji for "fairy/spirit"
            color: '#FF66CC', // Bright pink color
            fontSize: 20, // Smaller size as requested
            radius: 240, // Medium orbit radius
            speed: 0.006, //
            direction: 'counterclockwise',
            pattern: 'oscillating', // Erratic wobbling pattern
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.5, // Half player damage as requested
            damageInterval: 200, // 200ms between damage ticks as requested
            lifespan: null, // Permanent
            options: {
                wobbleFrequency: 6,  // Higher frequency for more erratic movement
                wobbleAmplitude: 180  // Larger amplitude for more dramatic wobbles
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to activate the Wild Fairy perk
window.activateWildFairy = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'WILD_FAIRY');
};

// Register the Teal Octopus perk (orbiting projectiles)
OrbitalPerkRegistry.registerPerkOrbital('TEAL_OCTOPUS', {
    getConfig: function () {
        return {
            symbol: '★',
            fontSize: getEffectiveSize(projectileSizeFactor, playerDamage),
            radius: 16 * playerLuck, // Scale radius with luck
            speed: 0.02,
            pattern: 'standard',
            collisionType: 'projectile', // Destroyed on hit
            damage: playerDamage,
            damageInterval: 0, // Not used for projectiles
            lifespan: null, // Permanent until hit
            options: {}
        };
    },
    count: 1,
    cooldown: function () {
        // Calculate cooldown based on Agi
        return 1000 / (Math.sqrt(playerFireRate / BASE_STATS.AGI));
    },
    activationMethod: 'timer'
});

// Function to activate the Teal Octopus perk
// This replaces the activateOrbitingProjectile function in index.html
window.activateOrbitingProjectile = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (scene) {
        // Create initial orbital immediately
        const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['TEAL_OCTOPUS'].getConfig();
        OrbitalSystem.create(scene, orbitalConfig);

        // Set up timer for subsequent orbitals
        OrbitalPerkRegistry.applyPerkOrbital(scene, 'TEAL_OCTOPUS');
    }
};

OrbitalPerkRegistry.registerPerkOrbital('INVERTED_OCTOPUS', {
    getConfig: function () {
        return {
            symbol: '★',
            fontSize: getEffectiveSize(projectileSizeFactor, playerDamage),
            radius: 16 * playerLuck, // Scale radius with luck - same as TEAL_OCTOPUS
            speed: 0.02,
            direction: 'counterclockwise', // Key difference: counter-clockwise rotation
            pattern: 'standard',
            collisionType: 'projectile', // Destroyed on hit
            damage: playerDamage,
            damageInterval: 0, // Not used for projectiles
            lifespan: null, // Permanent until hit
            options: {}
        };
    },
    count: 1,
    cooldown: function () {
        // Calculate cooldown based on Agi - same as TEAL_OCTOPUS
        return 1000 / (Math.sqrt(playerFireRate / BASE_STATS.AGI));
    },
    activationMethod: 'timer'
});

// Create activation function in nexus.js
window.activateInvertedOctopus = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create initial orbital immediately
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['INVERTED_OCTOPUS'].getConfig();
    OrbitalSystem.create(scene, orbitalConfig);

    // Set up timer for subsequent orbitals
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'INVERTED_OCTOPUS');
};

// First, register the perk with the registry
OrbitalPerkRegistry.registerPerkOrbital('TENTACLE_GRASP', {
    getConfig: function () {
        return {
            symbol: '✧', // Star symbol for tentacle segment
            color: '#8800AA', // Purple color
            fontSize: 24,
            radius: 80, // Medium orbit radius
            angle: Math.random() * Math.PI * 2, // Random starting angle
            speed: 0.01, // Moderate speed
            pattern: 'oscillating', // Use oscillating pattern for organic movement
            collisionType: 'projectile', // Destroyed on hit with enemies
            damage: playerDamage, //
            damageInterval: 0, // Not used for projectiles
            lifespan: null, // Permanent until hit
        };
    },
    cooldown: 30000, // 30 seconds base cooldown
    activationMethod: 'timer' // Create periodically on a timer
});

// Then modify the activateTentacleGrasp function to use the registry
window.activateTentacleGrasp = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Launch tentacles immediately
    launchTentacles(scene);

    // Apply the orbital perk using the registry (this ensures proper cleanup)
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'TENTACLE_GRASP');
};

// Helper function to launch tentacles with oscillating pattern
function launchTentacles(scene) {
    const tentacleCount = 4;

    // Define our radii
    const radii = [30, 50, 70, 90];

    // Create tentacles in evenly distributed angles
    for (let i = 0; i < tentacleCount; i++) {
        // Calculate the base angle for this tentacle
        const baseAngle = (i / tentacleCount) * Math.PI * 2;

        // Create each segment with slightly varied angles based on the same base
        radii.forEach((radius, index) => {
            // Add a small random variation to the angle for organic feel
            // More variation for outer segments
            const angleVariation = (Math.random() * 0.2 - 0.1) * (index * 0.5 + 1);
            const segmentAngle = baseAngle + angleVariation;

            // Customize wobble parameters for each segment
            // Outer segments wobble more for a more organic feel
            const wobbleFrequency = 2; // Increases with distance
            const wobbleAmplitude = radius * 0.1 * (index + 1); // Proportional to radius

            const orbitalConfig = {
                symbol: '✧', // Star symbol for tentacle segment
                color: '#8800AA', // Purple color
                fontSize: 24,
                radius: radius, // Use the current radius
                angle: segmentAngle, // Use the varied angle
                speed: 0.01, // Slower speed for better tentacle effect
                direction: 'clockwise',
                pattern: 'oscillating', // Use oscillating pattern for organic movement
                collisionType: 'projectile', // Destroyed on hit with enemies
                damage: playerDamage, //
                damageInterval: 0, // Not used for projectiles
                lifespan: null, // Permanent until hit
                options: {
                    wobbleFrequency: wobbleFrequency, // How quickly it oscillates
                    wobbleAmplitude: wobbleAmplitude // How far it oscillates
                }
            };

            // Create the orbital segment
            OrbitalSystem.create(scene, orbitalConfig);
        });
    }

    // Visual effect when launching tentacles
    scene.tweens.add({
        targets: player,
        scale: 1.2,
        duration: 200,
        yoyo: true,
        ease: 'Cubic.easeOut'
    });
}

// Track the current angle of immortal body parts
let immortalBodyAngle = Math.random() * Math.PI * 2; // Initial random angle

// Register the Immortal Arm perk (updated)
OrbitalPerkRegistry.registerPerkOrbital('IMMORTAL_ARM', {
    getConfig: function () {
        return {
            symbol: '腕', // Kanji for "arm"
            color: '#9932CC', // Deep purple color
            fontSize: 32, // Fixed size
            radius: 100, // Standard orbit radius
            angle: immortalBodyAngle, // Use the tracked angle
            speed: 0.01,
            pattern: 'standard',
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage,
            damageInterval: 500, // Half second cooldown between damage applications
            lifespan: null, // Permanent
            options: {}
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Register the Immortal Head perk (updated)
OrbitalPerkRegistry.registerPerkOrbital('IMMORTAL_HEAD', {
    getConfig: function () {
        return {
            symbol: '頭', // Kanji for "head"
            color: '#9932CC', // Deep purple color
            fontSize: 32, // Fixed size
            radius: 50, // Close orbit radius
            angle: immortalBodyAngle, // Use the tracked angle
            speed: 0.01,
            pattern: 'standard',
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage,
            damageInterval: 500, // Half second cooldown between damage applications
            lifespan: null, // Permanent
            options: {}
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Register the Immortal Leg perk (updated)
OrbitalPerkRegistry.registerPerkOrbital('IMMORTAL_LEG', {
    getConfig: function () {
        return {
            symbol: '脚', // Kanji for "leg"
            color: '#9932CC', // Deep purple color
            fontSize: 32, // Fixed size
            radius: 150, // Far orbit radius
            angle: immortalBodyAngle, // Use the tracked angle
            speed: 0.01,
            pattern: 'standard',
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage,
            damageInterval: 500, // Half second cooldown between damage applications
            lifespan: null, // Permanent
            options: {}
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to track the current immortal body parts
function updateImmortalBodyAngle() {
    // Get all active orbital entities
    const activeOrbitals = OrbitalSystem.getAll();

    // Find any immortal body part
    const immortalPart = activeOrbitals.find(orbital =>
        orbital.entity.text === '腕' ||
        orbital.entity.text === '頭' ||
        orbital.entity.text === '脚'
    );

    // If found, update the tracked angle
    if (immortalPart) {
        immortalBodyAngle = immortalPart.angle;
    }
}

// Modify the activation functions to update the angle first
window.activateImmortalArm = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;
    updateImmortalBodyAngle();
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'IMMORTAL_ARM');
};

window.activateImmortalHead = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;
    updateImmortalBodyAngle();
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'IMMORTAL_HEAD');
};

window.activateImmortalLeg = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;
    updateImmortalBodyAngle();
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'IMMORTAL_LEG');
};

// Register the Sniper Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('SNIPER_FAIRY', {
    getConfig: function () {
        return {
            symbol: '狙', // Kanji for "aim/target"
            color: '#FF55AA', // Pinkish color
            fontSize: 20, // Medium size
            radius: 80, // Medium orbit radius
            speed: 0.01, // Moderate speed
            pattern: 'standard', // Standard circular orbit
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'sniper',
                rangeModifier: 2 // 100% extra range
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to activate the Sniper Fairy perk (updated to use generic function)
window.activateSniperFairy = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['SNIPER_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Create firing timer for the orbital using the generic function
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            4000 // 4 seconds base cooldown
        );
    }
};

// Register the Copy Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('COPY_FAIRY', {
    getConfig: function () {
        return {
            symbol: '写', // Kanji for "copy"
            color: '#55FFAA', // Greenish color
            fontSize: 20, // Small size
            radius: 40, // Close orbit radius
            speed: 0.01, // Standard speed
            pattern: 'standard', // Standard circular orbit
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'copy'
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Register the Berserk Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('BERSERK_FAIRY', {
    getConfig: function () {
        return {
            symbol: '狂', // Kanji for "mad/crazy"
            color: '#FF5500', // Orange-red color
            fontSize: 20, // Small size
            radius: 200, // Far orbit radius
            speed: 0.02, // Faster speed
            pattern: 'standard', // Standard circular orbit
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'berserk'
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to activate the Copy Fairy perk
window.activateCopyFairy = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['COPY_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Create firing timer for the orbital using the generic function
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            1200 //
        );
    }
};

// Function to activate the Berserk Fairy perk
window.activateBerserkFairy = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['BERSERK_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Create firing timer for the orbital using the generic function
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            600 //
        );
    }
};

// Register the Cold Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('COLD_FAIRY', {
    getConfig: function () {
        return {
            symbol: '冷', // Kanji for "cold"
            color: '#00FFFF', // Cyan color
            fontSize: 20, // Small size like other fairies
            radius: 60, // Medium-close orbit radius
            speed: 0.01, // Standard speed
            direction: 'counterclockwise', // Counter-clockwise as requested
            pattern: 'standard', // Standard circular orbit
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'cold' // Use our new cold behavior
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to activate the Cold Fairy perk
window.activateColdFairy = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['COLD_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Create firing timer for the orbital using the generic function
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            6000 // cold is very powerful, so we won't have her shoot too often
        );
    }
};

// Register the Fun Fairy perk
OrbitalPerkRegistry.registerPerkOrbital('FUN_FAIRY', {
    getConfig: function () {
        return {
            symbol: '遊', // Kanji for "play/fun"
            color: '#FF55FF', // Pink color initially
            fontSize: 22, // Slightly larger than other fairies
            radius: 100, // Medium-far orbit radius as requested
            speed: 0.015, // Faster rotation as requested
            direction: 'clockwise',
            pattern: 'standard', // Standard circular orbit
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'fun' // Use our new fun behavior
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Function to activate the Fun Fairy perk
window.activateFunFairy = function () {
    // Get the current active scene
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['FUN_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Create firing timer for the orbital using the generic function
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            4000 // need high cd because the effect is 100%
        );

        // Add color-changing effect to the fairy kanji using the exported function
        orbital.colorTimer = setupFairyColorChanger(scene, orbital);
    }
};

OrbitalPerkRegistry.registerPerkOrbital('DEATH_FINGER', {
    getConfig: function () {
        return {
            symbol: '指', // Kanji for "finger"
            color: '#FF0000', // Red color
            fontSize: 16, // Small size
            radius: 32, // Close to player
            angle: 0, // Starting angle (will be updated by directionFollowing)
            speed: 0.1, // Speed for rotation
            direction: 'clockwise',
            pattern: 'directionFollowing', // Follows player movement direction
            collisionType: 'persistent', // Never dies from collisions
            damage: 0, // No contact damage
            damageInterval: 0, // Not used
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'deathFinger',
                oscillationSpeed: 0.01, // Control oscillation frequency
                oscillationAmount: 2 // Control oscillation amplitude
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Add this function to nexus.js
window.activateDeathFinger = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital to create the familiar
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['DEATH_FINGER'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Set up timer for the death finger to fire
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            1000
        );
    }
};

OrbitalPerkRegistry.registerPerkOrbital('FINGER_OF_DECAY', {
    getConfig: function () {
        return {
            symbol: '朽', // Kanji for "decay/rot" - single kanji for the orbital
            color: '#88AA22', // Sickly greenish-yellow color
            fontSize: 16, // Small size
            radius: 48, // Slightly larger than Death Finger
            angle: 0, // Starting angle (will be updated by directionFollowing)
            speed: 0.1, // Speed for rotation
            direction: 'clockwise',
            pattern: 'directionFollowing', // Follows player movement direction
            collisionType: 'persistent', // Never dies from collisions
            damage: 0, // No contact damage
            damageInterval: 0, // Not used
            lifespan: null, // Permanent
            options: {
                isFamiliar: true,
                familiarType: 'decayFinger', // Use our new decayFinger behavior
                oscillationSpeed: 0.01, // Control oscillation frequency
                oscillationAmount: 2 // Control oscillation amplitude
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

// Add this function to nexus.js
window.activateFingerOfDecay = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital to create the familiar
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['FINGER_OF_DECAY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Set up timer for the finger to fire (every 2000ms instead of 1000ms)
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            2000 // Fire every 2 seconds
        );
    }
};


OrbitalPerkRegistry.registerPerkOrbital('BRIGHT_LANCE', {
    getConfig: function () {
        return {
            symbol: '光槍', // Kanji for "Bright Lance"
            color: '#ffff00',
            fontSize: 32, // Standard size
            radius: 96, //
            angle: Math.random() * Math.PI * 2, // Random starting angle
            speed: 0.04, // Use this value as rotation speed factor for direction following
            direction: 'clockwise', // Not really used due to custom movement
            pattern: 'directionFollowing', // Use our custom pattern
            collisionType: 'persistent', // Stays after hitting enemies
            damage: playerDamage * 1, //
            damageInterval: 400, //
            lifespan: null, // Permanent
            options: {
                oscillationSpeed: 0.004, // Speed of the breathing effect
                oscillationAmount: 32 // Amplitude of oscillation
            }
        };
    },
    count: 1,
    activationMethod: 'immediate' // Create instantly when perk is acquired
});

window.activateBrightLance = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Apply the perk orbital
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'BRIGHT_LANCE');
};

// Updated HEALING_FAIRY registration in nexus.js
OrbitalPerkRegistry.registerPerkOrbital('HEALING_FAIRY', {
    getConfig: function () {
        return {
            symbol: '癒', // Kanji for "healing"
            color: '#00ff00', // Bright green color
            fontSize: 22, // Medium size
            radius: 100, // Medium orbit radius
            speed: 0.01, // Moderate speed
            pattern: 'oscillating', // More dynamic movement pattern
            collisionType: 'projectile', // Dies when hit by enemies
            damage: playerDamage * 0.1, // Very low contact damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: 20000, // 20 seconds lifespan
            options: {
                isFamiliar: true,
                familiarType: 'healer',
                wobbleFrequency: 3, // Control oscillation frequency
                wobbleAmplitude: 20 // Control oscillation amplitude
            }
        };
    },
    cooldown: 20000, // Fixed 20 second cooldown
    activationMethod: 'timer' // Create periodically on a timer
});

// Simplified activateHealingFairy function in nexus.js
window.activateHealingFairy = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create initial fairy immediately 
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['HEALING_FAIRY'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Set up timer for the fairy to fire healing projectiles
    if (orbital && orbital.options && orbital.options.isFamiliar) {
        orbital.firingTimer = FamiliarSystem.setupFamiliarFiringTimer(
            scene,
            orbital,
            orbital.options.familiarType,
            4000 // 4 seconds cooldown base (will scale with luck)
        );
    }

    // Apply the perk to set up automatic respawning through the registry system
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'HEALING_FAIRY');
}

// Add this to nexus.js
// Register the Lava Fairies perk
OrbitalPerkRegistry.registerPerkOrbital('LAVA_FAIRIES', {
    getConfig: function () {
        return {
            symbol: '溶', // Kanji for "melt/dissolve"
            color: '#FF6600', // Orange-red color for lava
            fontSize: 24, // Medium size
            radius: playerLuck * 16, // Radius scales with luck as requested
            speed: 0.012, // Moderate speed
            pattern: 'standard', // Standard circular pattern as requested
            collisionType: 'projectile', // Dies when hit enemies
            damage: playerDamage * 0.5, // Half player damage
            damageInterval: 500, // Half second between damage ticks
            lifespan: 16000, // 16 seconds lifespan
            options: {
                // Specify components to attach
                components: [
                    {
                        name: 'magmaDropEffect'
                    }
                ]
            }
        };
    },
    cooldown: 4000, // Fixed 4 second cooldown
    activationMethod: 'timer' // Create periodically
});

// Function to activate the Lava Fairies perk
window.activateLavaFairies = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create initial fairy immediately
    const orbitalConfig = OrbitalPerkRegistry.perkOrbitalConfigs['LAVA_FAIRIES'].getConfig();
    const orbital = OrbitalSystem.create(scene, orbitalConfig);

    // Apply the perk through the registry system for automatic spawning
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'LAVA_FAIRIES');
};

OrbitalPerkRegistry.registerPerkOrbital('WRECKING_BALL', {
    getConfig: function () {
        return {
            symbol: '球', // Kanji for "ball" as a clear visual representation
            color: '#777777', // Iron/steel gray color
            fontSize: 32, // Standard size for visibility
            radius: 192, //
            speed: 0.015, //
            direction: 'clockwise',
            pattern: 'figureEight', //
            collisionType: 'explosive', // Use the explosive collision behavior
            damage: playerDamage * 2,
            damageInterval: 0, // Not used for explosive behavior
            lifespan: null, // Permanent until hit
            options: {
                blastRadius: 128 //
            }
        };
    },
    cooldown: function () {
        // 16 second base cooldown that scales with sqrt of player luck
        return 16000 / (Math.sqrt(playerLuck / BASE_STATS.LUK));
    },
    activationMethod: 'timer' // Create periodically on a timer
});

window.activateWreckingBall = function () {
    const scene = game.scene.scenes[0];
    if (!scene) return;

    // Create a wrecking ball configuration
    const wreckingBallConfig = OrbitalPerkRegistry.perkOrbitalConfigs['WRECKING_BALL'].getConfig();

    // Create the first wrecking ball immediately
    OrbitalSystem.create(scene, wreckingBallConfig);

    // Apply the orbital perk for future wrecking balls
    OrbitalPerkRegistry.applyPerkOrbital(scene, 'WRECKING_BALL');
};

// Export the registry for use in other files
window.OrbitalPerkRegistry = OrbitalPerkRegistry;

// ======= onetime.js =======
// One-Time Effect System for Word Survivors
// Handles effects that occur once when a perk is acquired

// Registry of one-time effects
const OneTimeEffects = {
    // Renamed to 終焉 (The End/Final Catastrophe)
    // Renamed to 終焉 (The End/Final Catastrophe)
    shuuen: function (scene) {
        if (!scene) return;

        // Create visual effect first
        const flash = scene.add.rectangle(
            game.config.width / 2,
            game.config.height / 2,
            game.config.width,
            game.config.height,
            0xFFFFFF, 0.8
        );
        flash.setDepth(1000); // Ensure it appears on top

        // Flash animation
        scene.tweens.add({
            targets: flash,
            alpha: 0,
            duration: 500,
            onComplete: function () {
                flash.destroy();
            }
        });

        // Apply damage after a slight delay for visual effect
        scene.time.delayedCall(100, function () {
            // Get all active enemies on screen
            const allEnemies = EnemySystem.enemiesGroup.getChildren();
            if (!allEnemies || allEnemies.length === 0) return;

            // Calculate massive damage
            const megaDamage = playerDamage * 50; // Extremely high damage

            // Calculate shockwave origin (player position)
            const originX = player.x;
            const originY = player.y;

            // Create a unique damage source ID for this catastrophic event
            const catastropheId = `shuuen_${Date.now()}_${Math.random()}`;

            // Create shockwave visual
            const shockwave = scene.add.circle(originX, originY, 10, 0xFF3300, 0.7);

            // Expand shockwave
            scene.tweens.add({
                targets: shockwave,
                radius: Math.max(game.config.width, game.config.height) * 1.2, // 1.2x to ensure full coverage
                alpha: 0,
                duration: 1600,
                onComplete: function () {
                    shockwave.destroy();
                }
            });

            // Apply damage to all enemies with delay based on distance
            allEnemies.forEach(enemy => {
                if (!enemy.active) return;

                // Calculate distance from player
                const dx = enemy.x - originX;
                const dy = enemy.y - originY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Create a small delay based on distance for wave effect
                const delay = distance / 2; // 2 pixels per ms propagation

                // Apply damage after delay
                scene.time.delayedCall(delay, function () {
                    if (!enemy.active) return;

                    // Create a unique sub-ID for each enemy to ensure they all take damage
                    const enemySpecificId = `${catastropheId}_${enemy.x}_${enemy.y}`;

                    // Apply damage using the contact damage system
                    applyContactDamage.call(
                        scene,
                        {
                            damageSourceId: enemySpecificId,
                            damage: megaDamage,
                            active: true
                        },
                        enemy,
                        megaDamage,
                        0 // No cooldown needed for one-time catastrophic event
                    );

                    // The visual effects will still run regardless of whether the enemy dies
                    scene.tweens.add({
                        targets: enemy,
                        alpha: 0.2,
                        scale: 1.5,
                        duration: 200,
                        yoyo: true
                    });
                });

                // Create small explosion effect at each enemy
                scene.time.delayedCall(delay, function () {
                    if (!enemy.active) return;

                    const explosion = scene.add.circle(enemy.x, enemy.y, 30, 0xFF3300, 0.7);
                    scene.tweens.add({
                        targets: explosion,
                        radius: 60,
                        alpha: 0,
                        duration: 300,
                        onComplete: function () {
                            explosion.destroy();
                        }
                    });
                });
            });

            // Add dramatic sound effect text
            const boomText = scene.add.text(
                game.config.width / 2,
                game.config.height / 2,
                '終焉', {
                fontFamily: 'Arial',
                fontSize: '80px',
                color: '#FF3300',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);

            // Animate the text
            scene.tweens.add({
                targets: boomText,
                scale: 2,
                alpha: 0,
                duration: 1000,
                onComplete: function () {
                    boomText.destroy();
                }
            });
        });
    },

    // Purple Chaos effect - moved from perks.js
    purpleChaos: function (scene) {
        // Store current stat values
        const stats = {
            damage: playerDamage,
            health: maxPlayerHealth,
            luck: playerLuck,
            fireRate: playerFireRate
        };

        // Create an array of stat names
        const statNames = Object.keys(stats);

        // Shuffle the array
        for (let i = statNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [statNames[i], statNames[j]] = [statNames[j], statNames[i]];
        }

        // Create a shuffled mapping
        const newValues = {};
        const originalOrder = ['damage', 'health', 'luck', 'fireRate'];

        for (let i = 0; i < originalOrder.length; i++) {
            newValues[originalOrder[i]] = stats[statNames[i]];
        }

        // Apply the new values (need to reset first)
        window.modifyStat('damage', newValues.damage - playerDamage);
        window.modifyStat('health', newValues.health - maxPlayerHealth);
        window.modifyStat('luck', newValues.luck - playerLuck);
        window.modifyStat('fireRate', newValues.fireRate - playerFireRate);

        // Now add +2 to luck
        window.modifyStat('luck', 2);

        // Visual effect for chaos
        if (scene) {
            const chaosEffect = scene.add.text(player.x, player.y, '⚡ CHAOS! ⚡', {
                fontFamily: 'Arial',
                fontSize: '24px',
                color: '#9932cc',
                stroke: '#ffffff',
                strokeThickness: 2
            }).setOrigin(0.5);

            scene.tweens.add({
                targets: chaosEffect,
                alpha: { from: 1, to: 0 },
                y: chaosEffect.y - 50,
                scale: { from: 1, to: 2 },
                duration: 1500,
                onComplete: function () {
                    chaosEffect.destroy();
                }
            });
        }
    },

    oblivionBlossom: function (scene) {
        if (!scene) return;

        // Count current perks before removing them
        const perkCount = acquiredPerks.length;

        // Reset stats to base values
        playerDamage = BASE_STATS.POW;
        maxPlayerHealth = BASE_STATS.END;
        playerLuck = BASE_STATS.LUK;
        playerFireRate = BASE_STATS.AGI;

        // Also reset current health to match new max
        playerHealth = maxPlayerHealth;

        // Update UI to reflect new values
        GameUI.updateHealthBar(scene);
        LifeSystem.setupHealthRegeneration(scene);

        // Calculate total stat points (1.5 per perk, rounded up)
        const totalStatPoints = Math.ceil(perkCount * 1.5);

        // Distribute points randomly among all stats
        for (let i = 0; i < totalStatPoints; i++) {
            const statChoice = Math.floor(Math.random() * 4);
            switch (statChoice) {
                case 0:
                    window.modifyStat('damage', 1);
                    break;
                case 1:
                    window.modifyStat('health', 1);
                    break;
                case 2:
                    window.modifyStat('luck', 1);
                    break;
                case 3:
                    window.modifyStat('fireRate', 1);
                    break;
            }
        }

        // Create a visual effect for the transformation
        // Create a memory fade effect
        const forgottenText = scene.add.text(player.x, player.y, '忘', {
            fontFamily: 'Arial',
            fontSize: '64px',
            color: '#BBBBFF',
            stroke: '#000000',
            strokeThickness: 6
        }).setOrigin(0.5);

        // Animate the kanji for "forget"
        scene.tweens.add({
            targets: forgottenText,
            alpha: { from: 1, to: 0 },
            y: forgottenText.y - 100,
            scale: { from: 1, to: 3 },
            duration: 2000,
            onComplete: function () {
                forgottenText.destroy();
            }
        });

        // Create particle effects for each memory lost
        for (let i = 0; i < perkCount; i++) {
            const angle = (i / perkCount) * Math.PI * 2;
            const distance = 100;

            const memory = scene.add.text(
                player.x + Math.cos(angle) * distance,
                player.y + Math.sin(angle) * distance,
                '記憶', // Memory in kanji
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: '#DDDDFF'
                }
            ).setOrigin(0.5);

            // Animate memory particles fading away
            scene.tweens.add({
                targets: memory,
                scale: 0,
                alpha: 0,
                duration: 1500,
                delay: i * 100,
                onComplete: function () {
                    memory.destroy();
                }
            });
        }

        // Clear all perk effects
        window.clearAllPerkEffects();

        // Reset component systems
        PlayerComponentSystem.resetAll();
        OnHitEffectSystem.resetAll();
        OrbitalSystem.clearAll();
        DropperSystem.clearAll();

        // Add this line to reinitialize the player hit system:
        PlayerHitSystem.init(scene);

        // Set perk array to just this perk
        acquiredPerks = ['OBLIVION_BLOSSOM'];
    }

    // Add more one-time effects here as needed
};

// Main interface function to trigger one-time effects
window.triggerOneTimeEffect = function (effectName) {
    const scene = game.scene.scenes[0];

    // Check if the effect exists
    if (OneTimeEffects[effectName]) {
        // Call the effect function
        OneTimeEffects[effectName](scene);
        return true;
    }

    console.log(`One-time effect '${effectName}' not found`);
    return false;
};

// Export the effects registry if needed
window.OneTimeEffects = OneTimeEffects;

// ======= onhit.js =======
// On-Hit Effect System for Word Survivors
// Manages effects that trigger when the player is hit by enemies

// Component system for on-hit effects
const OnHitEffectSystem = {
    // Component definitions
    componentTypes: {},

    // Active components
    activeComponents: {},

    // Register a new component type
    registerComponent: function (name, componentDef) {
        this.componentTypes[name] = componentDef;
    },

    // Add a component to the system
    addComponent: function (componentName, config = {}) {
        // Skip if component already exists or type not registered
        if (this.activeComponents[componentName] || !this.componentTypes[componentName]) {
            return false;
        }

        // Create component from registered type
        const componentDef = this.componentTypes[componentName];
        const component = { ...componentDef };

        // Apply configuration
        Object.assign(component, config);

        // Store component reference
        this.activeComponents[componentName] = component;

        // Call initialize function if it exists
        if (component.initialize) {
            component.initialize();
        }

        return true;
    },

    getComponent: function (componentName) {
        // Return the component if it exists, or null if it doesn't
        return this.activeComponents[componentName] || null;
    },

    // Remove a component from the system
    removeComponent: function (componentName) {
        const component = this.activeComponents[componentName];
        if (!component) return false;

        // Call cleanup function if it exists
        if (component.cleanup) {
            component.cleanup();
        }

        // Remove the component
        delete this.activeComponents[componentName];
        return true;
    },

    // Process the player being hit
    processHit: function (scene, enemy) {
        // Call the onHit handler on each active component
        Object.values(this.activeComponents).forEach(component => {
            if (component.onHit) {
                component.onHit(scene, enemy);
            }
        });
    },

    // Check if a component is active
    hasComponent: function (componentName) {
        return !!this.activeComponents[componentName];
    },

    // Reset all components
    resetAll: function () {
        // Clean up each component
        Object.keys(this.activeComponents).forEach(name => {
            this.removeComponent(name);
        });

        // Ensure activeComponents is empty
        this.activeComponents = {};
    }
};

// Generalized defensive burst function that can be called from anywhere
window.createDefensiveBurst = function (scene, x, y, options = {}) {
    // Default options
    const defaults = {
        projectileCount: playerLuck * 2, // Default to 2 * LUCK projectiles
        color: '#9370db',                // Default purple color
        symbol: '★',                     // Default star symbol
        speed: 400,                      // Default speed
        damage: playerDamage,            // Default to player damage
        visualEffect: true               // Whether to show burst visual effect
    };

    // Merge provided options with defaults
    const config = { ...defaults, ...options };

    // Visual effect at the position
    if (config.visualEffect) {
        const burstEffect = scene.add.circle(x, y, 40, 0x9370db, 0.5);
        scene.tweens.add({
            targets: burstEffect,
            alpha: 0,
            scale: 2,
            duration: 300,
            onComplete: function () {
                burstEffect.destroy();
            }
        });
    }

    // Create each projectile in the burst
    const projectiles = [];
    for (let i = 0; i < config.projectileCount; i++) {
        // Calculate angle for even distribution (in radians)
        const angle = (i / config.projectileCount) * Math.PI * 2;

        // Create projectile using WeaponSystem
        const projectile = WeaponSystem.createProjectile(scene, {
            x: x,
            y: y,
            angle: angle,
            symbol: config.symbol,
            color: config.color,
            speed: config.speed,
            damage: config.damage,
            skipComponents: false // 
        });

        // Add special property
        projectile.isDefensiveBurst = true;

        // Add to return array
        projectiles.push(projectile);
    }

    // Return created projectiles for any additional processing
    return projectiles;
};

// Update the existing defensiveBurst component to use the new function
OnHitEffectSystem.registerComponent('defensiveBurst', {
    // No need to store state for this simple component
    onHit: function (scene, enemy) {
        // Simply call the generalized function at player position
        window.createDefensiveBurst(scene, player.x, player.y);
    }
});


// Registry for mapping perks to on-hit components
const OnHitPerkRegistry = {
    // Store perk-to-component mappings
    perkEffects: {},

    // Register a perk effect that applies an on-hit component
    registerPerkEffect: function (perkId, options) {
        this.perkEffects[perkId] = {
            componentName: options.componentName || null,
            configGenerator: options.configGenerator || null,
            condition: options.condition || null
        };
    },

    // Check and apply perk effects based on conditions
    checkAndApplyEffects: function () {
        // Process all registered perk effects
        Object.entries(this.perkEffects).forEach(([perkId, effectInfo]) => {
            // Check if player has this perk
            if (hasPerk(perkId)) {
                // Check if there's a condition function
                let conditionMet = true;
                if (effectInfo.condition) {
                    conditionMet = effectInfo.condition();
                }

                // Apply or remove component based on condition
                if (conditionMet) {
                    // Only add if it's not already active
                    if (!OnHitEffectSystem.hasComponent(effectInfo.componentName)) {
                        // Generate config if needed
                        let config = {};
                        if (effectInfo.configGenerator) {
                            config = effectInfo.configGenerator();
                        }

                        // Add the component
                        OnHitEffectSystem.addComponent(effectInfo.componentName, config);
                    }
                } else {
                    // Remove if active but condition no longer met
                    if (OnHitEffectSystem.hasComponent(effectInfo.componentName)) {
                        OnHitEffectSystem.removeComponent(effectInfo.componentName);
                    }
                }
            }
        });
    }
};

// Register the Purple Hedgehog perk effect
OnHitPerkRegistry.registerPerkEffect('PURPLE_HEDGEHOG', {
    componentName: 'defensiveBurst',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

OnHitEffectSystem.registerComponent('stormVengeanceEffect', {
    // Initialize component with default configuration
    initialize: function () {
        // Nothing needed here - configuration is set at creation time
    },

    // Handle the player being hit
    onHit: function (scene, enemy) {
        // Calculate number of lightning strikes based on player luck
        const strikeCount = playerLuck;

        // Create lightning strikes in a circle around the player
        this.createVengeanceStorm(scene, strikeCount);
    },

    // Helper method to create multiple lightning strikes in a circle
    createVengeanceStorm: function (scene, count) {
        // Define the radius of the lightning storm
        const radius = 192;

        // Create unique damage source ID for this storm
        const stormId = `vengeance_storm_${Date.now()}_${Math.random()}`;

        // Create lightning strikes at random positions within the circle
        for (let i = 0; i < count; i++) {
            // Calculate random angle and distance within the circle
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * radius;

            // Calculate position
            const x = player.x + Math.cos(angle) * distance;
            const y = player.y + Math.sin(angle) * distance;

            // Add a delay based on index to stagger the lightning strikes
            scene.time.delayedCall(i * 200, function () {
                // Create lightning strike using the existing function from hero.js
                createLightningStrike(scene, x, y, {
                    segmentCount: 4,
                });
            }, [], scene);
        }
    },

    // Clean up component
    cleanup: function () {
        // Nothing to clean up here
    }
});

OnHitPerkRegistry.registerPerkEffect('STORM_VENGEANCE', {
    componentName: 'stormVengeanceEffect',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});


// Centralized time dilation functionality
window.TimeDilationSystem = {
    // Current state tracking
    isActive: false,
    currentTimeScale: 1.0,
    playerSpeedFactor: 1.0,
    enemySlowdown: 1.0,
    originalPlayerSpeed: null,
    exitTimer: null,
    slowMoTween: null,
    isExiting: false,

    // Initialize the system
    initialize: function () {
        this.isActive = false;
        this.currentTimeScale = 1.0;
        this.playerSpeedFactor = 1.0;
        this.enemySlowdown = 1.0;
    },

    // Slow down the sound too
    applyMusicDilation: function (timeScale) {
        // Update music playback if system exists
        if (window.MusicSystem && window.MusicSystem.applyTimeDilation) {
            window.MusicSystem.applyTimeDilation(timeScale);
        }
    },

    // Function to enter slow motion gradually
    enterSlowMotion: function (scene, duration = null) {
        // Cancel any existing tween to avoid conflicts
        if (this.slowMoTween) {
            this.slowMoTween.stop();
        }

        // Reset the exiting flag
        this.isExiting = false;

        // Create tween to gradually slow down time
        this.slowMoTween = scene.tweens.add({
            targets: this,
            currentTimeScale: 0.5,    // Slow game to 50% speed
            playerSpeedFactor: 0.5,   // Player at 50% speed
            enemySlowdown: 0.25,      // Enemies at 25% speed
            duration: 500,
            ease: 'Sine.easeOut',
            onUpdate: () => {
                // Apply time scale to scene for timers and tweens
                scene.time.timeScale = this.currentTimeScale;

                // Slow music down
                this.applyMusicDilation(this.currentTimeScale);

                // Update the global enemy speed factor
                EnemySystem.setEnemySpeedFactor(this.enemySlowdown);

                // Update player speed
                playerSpeed = basePlayerSpeed * this.playerSpeedFactor;
            },
            onComplete: () => {
                this.isActive = true;

                // If duration is provided, set timer to exit slow motion
                if (duration !== null) {
                    this.setExitTimer(scene, duration);
                }
            }
        });
    },

    // Function to exit slow motion gradually
    exitSlowMotion: function (scene) {
        // Set the exiting flag
        this.isExiting = true;

        // Cancel any existing tween
        if (this.slowMoTween) {
            this.slowMoTween.stop();
        }

        // Create tween to restore normal time
        this.slowMoTween = scene.tweens.add({
            targets: this,
            currentTimeScale: 1.0,    // Return to normal speed
            playerSpeedFactor: 1.0,   // Return player speed to normal
            enemySlowdown: 1.0,       // Return enemy speed to normal
            duration: 500,
            ease: 'Sine.easeIn',
            onUpdate: () => {
                // Apply time scale to scene
                scene.time.timeScale = this.currentTimeScale;

                // Speed music back up
                this.applyMusicDilation(this.currentTimeScale);

                // Update the global enemy speed factor
                EnemySystem.setEnemySpeedFactor(this.enemySlowdown);

                // Update player speed
                playerSpeed = basePlayerSpeed * this.playerSpeedFactor;
            },
            onComplete: () => {
                this.isActive = false;
                this.isExiting = false; // Reset the exiting flag

                // Reset global enemy speed factor (redundant but safe)
                EnemySystem.setEnemySpeedFactor(this.enemySlowdown);

                // Ensure player speed is fully restored
                playerSpeed = basePlayerSpeed;
            }
        });
    },

    // Helper to set a timer for exiting slow motion
    setExitTimer: function (scene, duration) {
        // Clear existing exit timer if any
        if (this.exitTimer) {
            this.exitTimer.remove();
            this.exitTimer = null;
        }

        // Set timer to exit slow motion after duration - create a real-time timer
        const realTimeDuration = duration / this.currentTimeScale;
        this.exitTimer = scene.time.addEvent({
            delay: realTimeDuration,
            callback: () => { this.exitSlowMotion(scene); },
            callbackScope: this
        });

        // Register for cleanup
        registerTimer(this.exitTimer);
    },

    // Display visual effect (optional)
    showVisualEffect: function (scene) {
        const kanji = scene.add.text(player.x, player.y - 40, '異世界', {
            fontFamily: 'Arial',
            fontSize: '24px',
            color: '#00ffff',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5);

        scene.tweens.add({
            targets: kanji,
            y: kanji.y - 30,
            alpha: 0,
            scale: 1.5,
            duration: 1000,
            onComplete: function () {
                kanji.destroy();
            }
        });
    },

    // Clean up resources
    cleanup: function () {
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Reset time scale
        scene.time.timeScale = 1.0;

        // Reset enemy speed factor
        EnemySystem.setEnemySpeedFactor(this.enemySlowdown);

        // Clear any tween
        if (this.slowMoTween) {
            this.slowMoTween.stop();
            this.slowMoTween = null;
        }

        // Clear exit timer
        if (this.exitTimer) {
            this.exitTimer.remove();
            this.exitTimer = null;
        }

        this.isActive = false;
        this.currentTimeScale = 1.0;
        this.playerSpeedFactor = 1.0;
        this.enemySlowdown = 1.0;
    }
};

// Add a public function to activate time dilation from anywhere
window.activateTimeDilation = function (duration = null, showVisualEffect = true) {
    const scene = game.scene.scenes[0];
    if (!scene) return false;

    // Calculate duration based on luck if none provided
    const actualDuration = duration ?? Math.sqrt(playerLuck / BASE_STATS.LUK) * 1000;

    // Initialize the system if needed
    if (!window.TimeDilationSystem.isActive && !window.TimeDilationSystem.isExiting) {
        window.TimeDilationSystem.initialize();
    }

    // If we're in the process of exiting, we want to restart the slow motion effect
    if (window.TimeDilationSystem.isExiting) {
        // Cancel any exit tweens and start a fresh slow motion effect
        window.TimeDilationSystem.enterSlowMotion(scene, actualDuration);
    }
    // If already active (but not exiting), just extend the timer
    else if (window.TimeDilationSystem.isActive) {
        // Clear existing exit timer
        if (window.TimeDilationSystem.exitTimer) {
            window.TimeDilationSystem.exitTimer.remove();
            window.TimeDilationSystem.exitTimer = null;
        }

        // Set a new exit timer with the full duration
        window.TimeDilationSystem.setExitTimer(scene, actualDuration);
    }
    // Not active at all, start a fresh effect
    else {
        window.TimeDilationSystem.enterSlowMotion(scene, actualDuration);
    }

    // Show visual effect if requested
    if (showVisualEffect) {
        window.TimeDilationSystem.showVisualEffect(scene);
    }

    return true;
};

// Modified timeDilationEffect component - now only handles on-hit triggering
OnHitEffectSystem.registerComponent('timeDilationEffect', {
    // Initialize component
    initialize: function () {
        // Nothing needed here - system will be initialized when activated
    },

    // Handle player being hit
    onHit: function (scene, enemy) {
        // Calculate slow motion duration based on luck
        const baseSlowdownDuration = Math.sqrt(playerLuck / BASE_STATS.LUK) * 1000;

        // Activate time dilation with the calculated duration
        window.activateTimeDilation(baseSlowdownDuration);
    },

    // Clean up component
    cleanup: function () {
        // Cleanup the time dilation system
        window.TimeDilationSystem.cleanup();
    }
});

// Register the perk with the OnHitPerkRegistry
OnHitPerkRegistry.registerPerkEffect('ALIEN_WORLD', {
    componentName: 'timeDilationEffect',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Register component for Flawless Fight ability
OnHitEffectSystem.registerComponent('flawlessFightEffect', {
    // Store component state
    stepTimer: null,
    stepCount: 0,
    maxSteps: 10, // 10 steps of 5% = 50% max boost
    stepInterval: 4000, // 4 seconds between steps
    stepSize: 0.05, // 5% increase per step
    // Store contribution from this perk
    berserkContribution: 0,
    archerContribution: 0,

    // Initialize component
    initialize: function () {
        // Reset contributions
        this.berserkContribution = 0;
        this.archerContribution = 0;
        this.stepCount = 0;

        // Start the step timer
        this.startStepTimer();
    },

    // Handle player being hit
    onHit: function (scene, enemy) {
        // Reset step counter
        this.stepCount = 0;

        // Remove our contribution from the global multipliers
        berserkMultiplier -= this.berserkContribution;
        archerMultiplier -= this.archerContribution;

        // Reset our contributions
        this.berserkContribution = 0;
        this.archerContribution = 0;

        // Restart the timer after being hit
        this.restartStepTimer(scene);

        // Update UI to reflect new damage values
        GameUI.updateStatCircles(scene);
    },

    // Start/restart the step timer
    startStepTimer: function () {
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Clear existing timer if any
        this.clearStepTimer();

        // Create new timer
        this.stepTimer = scene.time.addEvent({
            delay: this.stepInterval,
            callback: this.incrementStep,
            callbackScope: this,
            loop: true
        });

        // Register for cleanup
        window.registerEffect('timer', this.stepTimer);
    },

    // Restart the timer (convenience method)
    restartStepTimer: function (scene) {
        this.clearStepTimer();
        this.startStepTimer();
    },

    // Clear the step timer
    clearStepTimer: function () {
        if (this.stepTimer) {
            this.stepTimer.remove();
            this.stepTimer = null;
        }
    },

    // Increment the step counter and boost multipliers
    incrementStep: function () {
        // Skip if game is over or paused
        if (gameOver || gamePaused) return;

        // Only increase if below max steps
        if (this.stepCount < this.maxSteps) {
            // Increment step count
            this.stepCount++;

            // Remove previous contribution
            berserkMultiplier -= this.berserkContribution;
            archerMultiplier -= this.archerContribution;

            // Calculate new contributions
            this.berserkContribution = this.stepCount * this.stepSize;
            this.archerContribution = this.stepCount * this.stepSize;

            // Apply to global multipliers
            berserkMultiplier += this.berserkContribution;
            archerMultiplier += this.archerContribution;

            // Get scene for visual effects
            const scene = game.scene.scenes[0];
            if (scene && player && player.active) {
                // Store original color
                const originalColor = player.style.color || '#ffffff';

                // Create a smooth glowing animation
                const glowTween = scene.tweens.add({
                    targets: { value: 0 },
                    value: 1,
                    duration: 600,
                    yoyo: true, // Important for smooth pulse
                    onUpdate: function (tween) {
                        if (!player || !player.active) return;

                        // Get the tween progress (0 to 1, then back to 0)
                        const value = tween.getValue();

                        // Create a blended color that shifts between blue and original
                        // Convert blue components to RGB
                        const blueR = 0x00;
                        const blueG = 0x88;
                        const blueB = 0xFF;

                        // Simple way to get RGB from original color (this works with hex strings)
                        let origR = 255, origG = 255, origB = 255; // Default to white
                        if (originalColor.startsWith('#')) {
                            // Parse hex color
                            const hex = originalColor.slice(1);
                            if (hex.length >= 6) {
                                origR = parseInt(hex.slice(0, 2), 16);
                                origG = parseInt(hex.slice(2, 4), 16);
                                origB = parseInt(hex.slice(4, 6), 16);
                            }
                        }

                        // Blend colors based on tween value
                        // Use more blue at the peak of the tween (value=1)
                        const r = Math.floor(origR * (1 - value) + blueR * value);
                        const g = Math.floor(origG * (1 - value) + blueG * value);
                        const b = Math.floor(origB * (1 - value) + blueB * value);

                        // Set the blended color
                        const blendedColor = `rgb(${r},${g},${b})`;
                        player.setColor(blendedColor);
                    },
                    onComplete: function () {
                        // Ensure color is reset to original when complete
                        if (player && player.active) {
                            player.setColor(originalColor);
                        }
                    }
                });

                // Update UI to reflect new damage values
                GameUI.updateStatCircles(scene);
            }
        }
    },

    // Clean up component
    cleanup: function () {
        // Remove our contribution from the global multipliers
        berserkMultiplier -= this.berserkContribution;
        archerMultiplier -= this.archerContribution;

        // Clear timer
        this.clearStepTimer();

        // Update the game UI if possible
        const scene = game.scene.scenes[0];
        if (scene) {
            GameUI.updateStatCircles(scene);
        }
    }
});

// Register the perk with the OnHitPerkRegistry
OnHitPerkRegistry.registerPerkEffect('FLAWLESS_FIGHT', {
    componentName: 'flawlessFightEffect',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Register component for Anger Rising ability
OnHitEffectSystem.registerComponent('angerRisingEffect', {
    // Track the multiplier contribution from this perk
    multiplierContribution: 0,
    maxMultiplier: 1.0,
    multiplierStep: 0.1,
    decayTimer: null,
    decayInterval: 30000, // 30 seconds between decay steps
    originalColor: null,   // Store the player's original color

    // Initialize component
    initialize: function () {
        this.multiplierContribution = 0;

        // Store player's original color
        this.originalColor = player.style ? player.style.color : '#ffffff';

        // Start the decay timer
        this.startDecayTimer();
    },

    // Start the decay timer with fixed interval
    startDecayTimer: function () {
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Create a timer that decreases rage over time with fixed interval
        this.decayTimer = scene.time.addEvent({
            delay: this.decayInterval,
            callback: this.decayRage,
            callbackScope: this,
            loop: true
        });

        // Register for cleanup
        window.registerEffect('timer', this.decayTimer);
    },

    // Decrease rage by one step
    decayRage: function () {
        if (this.multiplierContribution <= 0) return;

        // Get scene for visual effects
        const scene = game.scene.scenes[0];
        if (!scene) return;

        // Decrease by one step
        this.multiplierContribution -= this.multiplierStep;
        berserkMultiplier -= this.multiplierStep;

        // Ensure we don't go negative
        if (this.multiplierContribution < 0) {
            berserkMultiplier -= this.multiplierContribution; // Correct any overshoot
            this.multiplierContribution = 0;
        }

        // Update player color to reflect rage level
        this.updatePlayerColor();

        // Update UI to reflect new damage values
        GameUI.updateStatCircles(scene);
    },

    // Handle the player being hit
    onHit: function (scene, enemy) {
        // Only increase if below max
        if (this.multiplierContribution < this.maxMultiplier) {
            // Increase our contribution
            this.multiplierContribution += this.multiplierStep;

            // Apply to global berserkMultiplier
            berserkMultiplier += this.multiplierStep;

            // Cap at our maximum contribution
            if (this.multiplierContribution > this.maxMultiplier) {
                const excess = this.multiplierContribution - this.maxMultiplier;
                this.multiplierContribution = this.maxMultiplier;
                berserkMultiplier -= excess;
            }

            // Flash the player to indicate hit
            scene.tweens.add({
                targets: player,
                alpha: 0.6,
                scale: 1.1,
                duration: 100,
                yoyo: true,
                onComplete: () => {
                    // Update player color to new rage level
                    this.updatePlayerColor();
                }
            });

            // Update UI to reflect new damage values
            GameUI.updateStatCircles(scene);
        }
    },

    // Update player color based on current rage level
    updatePlayerColor: function () {
        if (!player || !player.active) return;

        // No color change if no rage built up
        if (this.multiplierContribution <= 0) {
            // Reset to original color
            player.setColor(this.originalColor);
            return;
        }

        // Calculate color based on rage level - white to orange to red
        // Start with pure white (255, 255, 255)
        // Full rage will be bright orange-red (255, 100, 0)

        // Calculate green component (255 → 100 as rage increases)
        const greenValue = Math.floor(255 - (155 * (this.multiplierContribution / this.maxMultiplier)));

        // Calculate blue component (255 → 0 as rage increases)
        const blueValue = Math.floor(255 - (255 * (this.multiplierContribution / this.maxMultiplier)));

        // Create the color string
        const rageColor = `rgb(255,${greenValue},${blueValue})`;

        // Apply the color to the player
        player.setColor(rageColor);
    },

    // Clean up component
    cleanup: function () {
        // Remove decay timer if it exists
        if (this.decayTimer) {
            this.decayTimer.remove();
            this.decayTimer = null;
        }

        // Remove our contribution from the global multiplier
        berserkMultiplier -= this.multiplierContribution;

        // Ensure multiplier doesn't go below 1.0
        if (berserkMultiplier < 1.0) {
            berserkMultiplier = 1.0;
        }

        // Reset player color to original
        if (player && player.active && this.originalColor) {
            player.setColor(this.originalColor);
        }

        this.multiplierContribution = 0;
    }
});

// Register the perk with the OnHitPerkRegistry
OnHitPerkRegistry.registerPerkEffect('ANGER_RISING', {
    componentName: 'angerRisingEffect',
    condition: function () {
        // Always active when perk is acquired
        return true;
    }
});

// Main handler for player hit events - coordinates the entire hit response
function handlePlayerHit(scene, enemy) {
    // First trigger any on-hit effects that should happen regardless of shields
    // (like the Purple Hedgehog defensive burst)
    processPlayerHit(scene, enemy);

    // Check if shield is active
    if (window.isShieldActive()) {
        // Shield absorbs the hit - this will handle cooldown for permanent shields
        window.triggerShieldHit();

        // Flash the shield effect
        scene.tweens.add({
            targets: player,
            alpha: 0.5,
            scale: 1.2,
            duration: 100,
            yoyo: true,
            repeat: 1
        });

        // Return true to indicate hit was absorbed by shield
        return true;
    }

    // If we reach here, no shield was active
    // Return false to indicate hit should apply damage
    return false;
}

// Process on-hit effects (doesn't handle shield or damage)
function processPlayerHit(scene, enemy) {
    // Process all registered on-hit effects
    OnHitEffectSystem.processHit(scene, enemy);
}

// Function to reset the system (call during game restart)
function resetOnHitEffects() {
    OnHitEffectSystem.resetAll();
}

// Call this during the game update loop to ensure perk effects are applied/removed as needed
function updateOnHitEffects() {
    // Skip if game is over or paused
    if (gameOver || gamePaused) return;

    // Check perk conditions and apply/remove components
    OnHitPerkRegistry.checkAndApplyEffects();
}

// Export API for use in other files
window.OnHitEffectSystem = OnHitEffectSystem;
window.OnHitPerkRegistry = OnHitPerkRegistry;
window.handlePlayerHit = handlePlayerHit;
window.processPlayerHit = processPlayerHit;
window.resetOnHitEffects = resetOnHitEffects;
window.updateOnHitEffects = updateOnHitEffects;

// ======= orbitals.js =======
// Orbital Component System for Word Survivors
// Manages orbital entities that circle around the player with various movement patterns

// Global list to store all orbital entities
const orbitals = [];

// Movement pattern implementations
const MovementPatterns = {
    // Standard circular orbit
    standard: function (orbital, time) {
        // Update the orbit angle based on speed
        orbital.angle += orbital.speed * (orbital.direction === 'clockwise' ? 1 : -1);

        // Calculate new position based on player position and orbit angle
        const x = player.x + Math.cos(orbital.angle) * orbital.radius;
        const y = player.y + Math.sin(orbital.angle) * orbital.radius;

        // Update orbital position
        orbital.entity.setPosition(x, y);
    },

    // Elliptical orbit (stretched circle)
    elliptical: function (orbital, time) {
        // Update the orbit angle based on speed
        orbital.angle += orbital.speed * (orbital.direction === 'clockwise' ? 1 : -1);

        // Calculate position with horizontal stretch
        const stretchX = orbital.options.stretchX ?? 1.5;
        const stretchY = orbital.options.stretchY ?? 1;

        const x = player.x + Math.cos(orbital.angle) * orbital.radius * stretchX;
        const y = player.y + Math.sin(orbital.angle) * orbital.radius * stretchY;

        // Update orbital position
        orbital.entity.setPosition(x, y);
    },

    // Figure-8 movement pattern
    figureEight: function (orbital, time) {
        // Update the orbit angle based on speed
        orbital.angle += orbital.speed * (orbital.direction === 'clockwise' ? 1 : -1);

        // Calculate figure-8 pattern using lemniscate of Bernoulli
        const scale = orbital.radius;
        const t = orbital.angle;
        const denominator = 1 + Math.sin(t) * Math.sin(t);

        const x = player.x + scale * Math.cos(t) / denominator;
        const y = player.y + scale * Math.sin(t) * Math.cos(t) / denominator;

        // Update orbital position
        orbital.entity.setPosition(x, y);
    },

    // Spiral in and out
    spiral: function (orbital, time) {
        // Update the orbit angle based on speed
        orbital.angle += orbital.speed * (orbital.direction === 'clockwise' ? 1 : -1);

        // Calculate pulsing radius
        const pulseSpeed = orbital.options.pulseSpeed ?? 0.02;
        const minRadius = orbital.options.minRadius ?? orbital.radius * 0.5;
        const maxRadius = orbital.options.maxRadius ?? orbital.radius * 1.5;

        // Use sine wave to oscillate between min and max radius
        const currentRadius = minRadius + (Math.sin(time * pulseSpeed) + 1) / 2 * (maxRadius - minRadius);

        // Calculate new position
        const x = player.x + Math.cos(orbital.angle) * currentRadius;
        const y = player.y + Math.sin(orbital.angle) * currentRadius;

        // Update orbital position
        orbital.entity.setPosition(x, y);
    },

    // Oscillating orbit (wobbles in and out while orbiting)
    oscillating: function (orbital, time) {
        // Update the orbit angle based on speed
        orbital.angle += orbital.speed * (orbital.direction === 'clockwise' ? 1 : -1);

        // Calculate wobbling radius
        const wobbleFrequency = orbital.options.wobbleFrequency ?? 5;
        const wobbleAmplitude = orbital.options.wobbleAmplitude ?? orbital.radius * 0.2;
        const baseRadius = orbital.radius;

        const currentRadius = baseRadius + Math.sin(orbital.angle * wobbleFrequency) * wobbleAmplitude;

        // Calculate new position
        const x = player.x + Math.cos(orbital.angle) * currentRadius;
        const y = player.y + Math.sin(orbital.angle) * currentRadius;

        // Update orbital position
        orbital.entity.setPosition(x, y);
    },

    directionFollowing: function (orbital, time) {
        // Skip if player is destroyed or has no velocity
        if (!player || !player.body || !player.active) return;

        // Get player velocity
        const velocity = player.body.velocity;

        // Only update angle if player is actually moving
        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const movementThreshold = 10; // Minimum velocity to consider player moving

        if (speed > movementThreshold) {
            // Calculate angle from velocity
            const newAngle = Math.atan2(velocity.y, velocity.x);

            // If we haven't stored a previous angle, initialize it
            if (orbital.lastAngle === undefined) {
                orbital.lastAngle = newAngle;
            }

            // Normalize both angles to 0-2π range for consistent comparison
            const normalizedCurrent = orbital.lastAngle % (Math.PI * 2);
            const normalizedNew = newAngle % (Math.PI * 2);

            // Ensure positive values (0 to 2π)
            const currentAngle = normalizedCurrent >= 0 ? normalizedCurrent : normalizedCurrent + Math.PI * 2;
            const targetAngle = normalizedNew >= 0 ? normalizedNew : normalizedNew + Math.PI * 2;

            // Calculate both possible rotation directions
            const clockwiseDiff = (targetAngle <= currentAngle) ?
                (targetAngle + Math.PI * 2) - currentAngle :
                targetAngle - currentAngle;

            const counterClockwiseDiff = (targetAngle >= currentAngle) ?
                (currentAngle + Math.PI * 2) - targetAngle :
                currentAngle - targetAngle;

            // Choose the smaller angle difference and correct sign
            let angleDiff = (clockwiseDiff <= counterClockwiseDiff) ?
                clockwiseDiff : -counterClockwiseDiff;

            // Apply smooth rotation using orbital.speed as the rotation speed factor
            orbital.lastAngle += angleDiff * orbital.speed;

            // Keep lastAngle in reasonable range to prevent floating point issues over time
            orbital.lastAngle = orbital.lastAngle % (Math.PI * 2);

            // Store last computed angle to use as the facing direction
            orbital.angle = orbital.lastAngle;
        }

        // Calculate new position based on player position and orbit angle
        // Add a small oscillation on the radius to make it "breathe"
        const oscillationSpeed = orbital.options.oscillationSpeed ?? 0.002;
        const oscillationAmount = orbital.options.oscillationAmount ?? 20;
        const oscillation = Math.sin(time * oscillationSpeed) * oscillationAmount;
        const currentRadius = orbital.radius + oscillation;

        const x = player.x + Math.cos(orbital.angle) * currentRadius;
        const y = player.y + Math.sin(orbital.angle) * currentRadius;

        // Update orbital position
        orbital.entity.setPosition(x, y);

        // Rotate the text to match the direction
        orbital.entity.setAngle((orbital.angle * 180 / Math.PI));
    }
};

// Helper function to process component events during collision
function processOrbitalComponentEvent(scene, orbital, enemy, eventName) {
    // Skip if entity doesn't exist or has no components
    if (!orbital.entity || !orbital.entity.components) return;

    // Process event for all components
    Object.values(orbital.entity.components).forEach(component => {
        if (component[eventName]) {
            component[eventName](orbital.entity, enemy, scene);
        }
    });
}

// Collision behavior implementations
const CollisionBehaviors = {
    // Persistent orbital that deals contact damage and stays after hitting enemies
    persistent: function (scene, orbital, enemy) {
        // Process onhit components if any
        processOrbitalComponentEvent(scene, orbital, enemy, 'onHit');

        // Apply contact damage with the specified cooldown interval
        applyContactDamage.call(
            scene,
            orbital.entity,
            enemy,
            orbital.entity.damage,
            orbital.damageInterval
        );
    },

    // Projectile-like orbital that deals damage once and is destroyed on impact
    projectile: function (scene, orbital, enemy) {
        // Process onhit components if any
        processOrbitalComponentEvent(scene, orbital, enemy, 'onHit');

        // Apply damage using the contact damage system
        applyContactDamage.call(
            scene,
            orbital.entity,
            enemy,
            orbital.entity.damage,
            0 // No cooldown for single-hit projectiles
        );

        // Destroy the orbital
        destroyOrbital(orbital);
    },

    // Explosive orbital that deals area damage and is destroyed on impact
    explosive: function (scene, orbital, enemy) {
        // Process onhit components if any
        processOrbitalComponentEvent(scene, orbital, enemy, 'onHit');

        // Get position of impact (where the enemy was hit)
        const centerX = enemy.x;
        const centerY = enemy.y;

        // Get blast radius from options or use default
        const blastRadius = orbital.options.blastRadius ?? 128;

        // Create a unique explosion ID for this blast
        const explosionId = `orbital_explosion_${Date.now()}_${Math.random()}`;

        // Get all active enemies
        const allEnemies = EnemySystem.enemiesGroup.getChildren();

        // Apply damage to all enemies in blast radius
        allEnemies.forEach(nearbyEnemy => {
            if (!nearbyEnemy.active) return;

            // Calculate distance from explosion
            const dx = nearbyEnemy.x - centerX;
            const dy = nearbyEnemy.y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If within blast radius, apply damage
            if (distance <= blastRadius) {
                // Create a unique ID for each affected enemy
                const enemySpecificExplosionId = `${explosionId}_${nearbyEnemy.x}_${nearbyEnemy.y}`;

                // Apply damage using the contact damage system
                applyContactDamage.call(
                    scene,
                    {
                        damageSourceId: enemySpecificExplosionId,
                        damage: orbital.entity.damage,
                        active: true
                    },
                    nearbyEnemy,
                    orbital.entity.damage,
                    0 // No cooldown for explosion effects
                );
            }
        });

        // Create explosion effect with converted color
        const explosionColor = VisualEffects.convertToColorValue(orbital.entity.style.color);
        VisualEffects.createExplosion(scene, centerX, centerY, blastRadius, explosionColor, {
            startScale: 0.2
        });

        // Destroy the orbital
        destroyOrbital(orbital);
    }
};

// Helper function to destroy an orbital
function destroyOrbital(orbital) {
    if (orbital.entity && orbital.entity.active) {
        // Process onDestroy event for components if they exist
        if (orbital.entity.components) {
            const scene = game.scene.scenes[0];
            if (scene) {
                Object.values(orbital.entity.components).forEach(component => {
                    if (component.onDestroy) {
                        component.onDestroy(orbital.entity, scene);
                    }
                });
            }
        }

        // Destroy the entity
        orbital.entity.destroy();
    }

    // Mark as destroyed
    orbital.destroyed = true;
}

// Main Orbital System
const OrbitalSystem = {
    // Initialize the system
    init: function () {
        // Clear any existing orbitals
        this.clearAll();
        console.log("Orbital system initialized");
    },

    // Create a new orbital entity
    // Create a new orbital entity
    create: function (scene, config) {
        // Default configuration with fallbacks
        const defaults = {
            symbol: '★',                 // Text symbol to display
            color: '#ffff00',            // Color of the orbital
            fontSize: 32,                // Size of the font
            radius: 80,                  // Distance from player
            angle: Math.random() * Math.PI * 2, // Starting angle (random by default)
            speed: 0.02,                 // Rotation speed
            direction: 'clockwise',      // Direction of rotation ('clockwise' or 'counterclockwise')
            pattern: 'standard',         // Movement pattern
            collisionType: 'persistent', // Collision behavior type ('persistent', 'projectile', 'explosive')
            damage: playerDamage,        // Damage dealt to enemies
            damageInterval: 500,         // Minimum time between damage instances in ms
            colliderSize: 0.8,           // Size multiplier for collision detection
            lifespan: null,              // Time in ms before auto-destruction (null for permanent)
            options: {}                  // Additional options for specific movement patterns and collision behavior
        };

        // Merge provided config with defaults
        const orbitalConfig = { ...defaults, ...config };

        // Create the orbital entity as a text object
        const entity = scene.add.text(
            player.x + Math.cos(orbitalConfig.angle) * orbitalConfig.radius,
            player.y + Math.sin(orbitalConfig.angle) * orbitalConfig.radius,
            orbitalConfig.symbol,
            {
                fontFamily: 'Arial',
                fontSize: `${orbitalConfig.fontSize}px`,
                color: orbitalConfig.color,
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);

        // Add physics to the orbital for enemy overlap detection
        scene.physics.world.enable(entity);
        entity.body.setSize(entity.width * orbitalConfig.colliderSize, entity.height * orbitalConfig.colliderSize);

        // Store unique ID for damage source (used for cooldown tracking)
        entity.damageSourceId = `orbital_${Date.now()}_${Math.random()}`;

        // Store damage value on the entity
        entity.damage = orbitalConfig.damage;

        // Initialize components object if components are specified
        if (orbitalConfig.options && orbitalConfig.options.components) {
            entity.components = {};

            // Add each specified component to the entity
            orbitalConfig.options.components.forEach(component => {
                if (component.name && ProjectileComponentSystem.componentTypes[component.name]) {
                    // Add the component to the entity
                    ProjectileComponentSystem.addComponent(
                        entity,
                        component.name,
                        component.config || {}
                    );
                }
            });
        }

        // Create the orbital object that tracks all properties
        const orbital = {
            entity: entity,
            radius: orbitalConfig.radius,
            angle: orbitalConfig.angle,
            speed: orbitalConfig.speed,
            direction: orbitalConfig.direction,
            pattern: orbitalConfig.pattern,
            collisionType: orbitalConfig.collisionType,
            damageInterval: orbitalConfig.damageInterval,
            createdAt: scene.time.now,
            lifespan: orbitalConfig.lifespan,
            options: orbitalConfig.options,
            lastUpdate: 0,               // Timestamp of last update
            destroyed: false             // Flag to mark for cleanup
        };

        // Add to global list
        orbitals.push(orbital);

        // Register for cleanup
        window.registerEffect('entity', entity);

        // Get the appropriate collision behavior function
        const collisionBehavior = CollisionBehaviors[orbitalConfig.collisionType] ?? CollisionBehaviors.persistent;

        // Add overlap with enemies
        scene.physics.add.overlap(entity, EnemySystem.enemiesGroup, function (orbitalEntity, enemy) {
            // Skip if orbital is already marked as destroyed
            if (orbital.destroyed) return;

            // Call the appropriate collision behavior function
            collisionBehavior(scene, orbital, enemy);
        }, null, scene);

        // Visual effect when spawning
        scene.tweens.add({
            targets: entity,
            scale: { from: 0, to: 1 },
            duration: 500,
            ease: 'Back.out'
        });

        // Set up auto-destruction timer if lifespan is specified
        if (orbital.lifespan !== null) {
            const timer = scene.time.delayedCall(orbital.lifespan, function () {
                // Create a fade-out effect
                scene.tweens.add({
                    targets: entity,
                    alpha: 0,
                    scale: 0,
                    duration: 300,
                    onComplete: function () {
                        destroyOrbital(orbital);
                    }
                });
            });

            // Register the timer for cleanup
            window.registerEffect('timer', timer);
        }

        return orbital;
    },

    // Update all orbitals
    update: function (scene, time) {
        // Skip if no orbitals or game state prevents updates
        if (gameOver || gamePaused || orbitals.length === 0) return;

        // Update each orbital
        orbitals.forEach(orbital => {
            // Skip if the entity was destroyed
            if (orbital.destroyed || !orbital.entity || !orbital.entity.active) return;

            // Get the movement function based on pattern
            const movementFn = MovementPatterns[orbital.pattern] ?? MovementPatterns.standard;

            // Update orbital position
            movementFn(orbital, time);

            // Update the last update time
            orbital.lastUpdate = time;
        });

        // Clean up destroyed orbitals
        this.cleanupInactive();
    },

    // Clean up inactive orbitals
    cleanupInactive: function () {
        for (let i = orbitals.length - 1; i >= 0; i--) {
            const orbital = orbitals[i];
            if (orbital.destroyed || !orbital.entity || !orbital.entity.active) {
                orbitals.splice(i, 1);
            }
        }
    },

    // Clear all orbitals
    clearAll: function () {
        // Destroy all orbital entities
        orbitals.forEach(orbital => {
            // Clean up firing timer if it exists
            if (orbital.firingTimer) {
                CooldownManager.removeTimer(orbital.firingTimer);
                orbital.firingTimer = null;
            }

            // Destroy the entity
            if (orbital.entity && orbital.entity.active) {
                orbital.entity.destroy();
            }
        });

        // Clear the array
        orbitals.length = 0;
    },

    // Get all active orbitals
    getAll: function () {
        return orbitals.filter(orbital => !orbital.destroyed && orbital.entity && orbital.entity.active);
    },

    // Get count of active orbitals
    getCount: function () {
        return this.getAll().length;
    },

    // Create multiple orbitals at once with even angle distribution
    createMultiple: function (scene, count, config) {
        const createdOrbitals = [];

        for (let i = 0; i < count; i++) {
            // Calculate evenly distributed angles
            const angle = (i / count) * Math.PI * 2;

            // Create the orbital with the calculated angle
            const orbitalConfig = { ...config, angle: angle };
            const orbital = this.create(scene, orbitalConfig);
            createdOrbitals.push(orbital);
        }

        return createdOrbitals;
    }
};

// Export the system for use in other files
window.OrbitalSystem = OrbitalSystem;

// ======= pause.js =======
// Pause System namespace
const PauseSystem = {
    // UI elements
    elements: {
        pauseScreen: null,
        resumeButton: null,
        pauseMessage: null,
        perkIcons: [],
        paginationControls: [],
        activePerkCard: null,
        pausePerksContainer: null,
        statsContainer: null,
        statCircles: []
    },

    // State tracking
    currentPerkPage: 0,
    isInitialized: false,

    // Initialize the pause system
    init: function (scene) {
        // Make sure we have a valid scene
        if (!scene || !scene.add) {
            console.error("Cannot initialize PauseSystem: Invalid scene provided");
            return;
        }

        // Create pause overlay elements (initially hidden)
        this.createPauseScreen(scene);

        // Setup pause key (P)
        const pauseKeyP = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
        pauseKeyP.on('down', function () {
            if (!gameOver) {
                if (gamePaused) {
                    PauseSystem.resumeGame();
                } else {
                    PauseSystem.pauseGameWithOverlay();
                }
            }
        });

        // Setup visibility change detection
        document.addEventListener('visibilitychange', function () {
            if (document.hidden && !gameOver && !gamePaused) {
                // Tab/window is hidden, pause the game
                PauseSystem.pauseGameWithOverlay();
            }
            // We don't auto-resume when tab becomes visible again
        });

        // Mark as initialized
        this.isInitialized = true;

        console.log("Pause system initialized successfully");
    },

    // Create the pause screen UI elements
    createPauseScreen: function (scene) {
        // Safety check
        if (!scene || !scene.add) {
            console.error("Cannot create pause screen: Invalid scene");
            return;
        }

        const centerX = game.config.width / 2;
        const centerY = game.config.height / 2;

        // Create semi-transparent background
        this.elements.pauseScreen = scene.add.rectangle(
            centerX,
            centerY,
            game.config.width,
            game.config.height,
            0x000000, 0.7
        );
        this.elements.pauseScreen.setVisible(false);
        this.elements.pauseScreen.setDepth(1000); // Make sure it appears on top

        // Create pause message
        this.elements.pauseMessage = scene.add.text(
            centerX,
            game.config.height * 0.125, // 100/800 = 0.125
            'GAME PAUSED',
            { fontFamily: 'Arial', fontSize: '40px', color: '#ffffff', fontStyle: 'bold' }
        ).setOrigin(0.5);
        this.elements.pauseMessage.setVisible(false);
        this.elements.pauseMessage.setDepth(1001);

        // Create resume button
        this.elements.resumeButton = scene.add.text(
            centerX,
            game.config.height * 0.875, // 700/800 = 0.875
            'RESUME GAME',
            {
                fontFamily: 'Arial',
                fontSize: '36px',
                color: '#ffffff',
                backgroundColor: '#008800',
                padding: { left: 15, right: 15, top: 10, bottom: 10 }
            }
        ).setOrigin(0.5);
        this.elements.resumeButton.setVisible(false);
        this.elements.resumeButton.setDepth(1001);
        this.elements.resumeButton.setInteractive();

        // Add resume button functionality - important! Use a direct function reference, not a method
        this.elements.resumeButton.on('pointerdown', function () {
            // Call resumeGame directly using the PauseSystem namespace
            PauseSystem.resumeGame();
        });

        this.elements.resumeButton.on('pointerover', function () {
            this.setStyle({ backgroundColor: '#00aa00' });
        });

        this.elements.resumeButton.on('pointerout', function () {
            this.setStyle({ backgroundColor: '#008800' });
        });

        // Create container for perks display
        this.elements.pausePerksContainer = scene.add.container(0, 0);
        this.elements.pausePerksContainer.setDepth(1001);
        this.elements.pausePerksContainer.setVisible(false);

        // Create container for stats display (used in kajisuli mode)
        this.elements.statsContainer = scene.add.container(0, 0);
        this.elements.statsContainer.setDepth(1001);
        this.elements.statsContainer.setVisible(false);

        // Create perks title (adjusted for kajisuli mode to make room for stats)
        const perksTitleY = KAJISULI_MODE ?
            game.config.height * 0.32 : // Move down in kajisuli mode
            game.config.height * 0.25;  // Standard position

        const perksTitle = scene.add.text(
            centerX,
            perksTitleY,
            'MY PERKS',
            { fontFamily: 'Arial', fontSize: '32px', color: '#ffffff', fontStyle: 'bold' }
        ).setOrigin(0.5);

        // Add to container
        this.elements.pausePerksContainer.add(perksTitle);

        console.log("Pause screen elements created successfully");
    },

    // Check if the system is properly initialized
    ensureInitialized: function () {
        if (!this.isInitialized || !this.elements.pauseScreen) {
            console.warn("PauseSystem not fully initialized, attempting to initialize now");
            const scene = game.scene.scenes[0];
            if (scene) {
                this.init(scene);
            } else {
                console.error("Cannot initialize PauseSystem: No active scene available");
                return false;
            }
        }
        return true;
    },

    // Pause the game
    pauseGame: function (isLevelUpPause = false) {
        // Set the flag
        gamePaused = true;

        // Pause physics
        const activeScene = game.scene.scenes[0];
        if (activeScene && activeScene.physics) {
            activeScene.physics.pause();
        }
        if (activeScene.tweens) {
            activeScene.tweens.pauseAll();
        }

        // Pause all registered timers
        gameTimers.forEach(timer => {
            if (timer && timer.paused !== undefined) {
                timer.paused = true;
            }
        });

        // Pause all effect timers
        activeEffects.timers.forEach(timer => {
            if (timer && timer.paused !== undefined) {
                timer.paused = true;
            }
        });

        // Pause music
        if (window.MusicSystem) {
            window.MusicSystem.onGamePause();
        }
    },

    // Resume the game and hide overlay
    resumeGame: function () {
        if (gameOver) return;

        // If level up is in progress, don't resume
        if (levelUpCards && levelUpCards.length > 0) {
            console.log("Cannot resume, level up screen is active");
            return;
        }

        // Set pause flag
        gamePaused = false;

        // Resume physics
        const activeScene = game.scene.scenes[0];
        if (activeScene && activeScene.physics) {
            activeScene.physics.resume();
        }
        if (activeScene.tweens) {
            activeScene.tweens.resumeAll();
        }

        // Resume all registered timers
        gameTimers.forEach(timer => {
            if (timer && timer.paused !== undefined) {
                timer.paused = false;
            }
        });

        // Resume all effect timers
        activeEffects.timers.forEach(timer => {
            if (timer && timer.paused !== undefined) {
                timer.paused = false;
            }
        });

        // Resume music
        if (window.MusicSystem) {
            window.MusicSystem.onGameResume();
        }

        // Check if we have valid UI elements before trying to hide them
        if (!this.elements.pauseScreen) {
            return;
        }

        // Hide pause screen elements
        this.elements.pauseScreen.setVisible(false);
        this.elements.pauseMessage.setVisible(false);
        this.elements.resumeButton.setVisible(false);

        // Hide perks container
        if (this.elements.pausePerksContainer) {
            this.elements.pausePerksContainer.setVisible(false);
        }

        // Hide stats container if it exists
        if (this.elements.statsContainer) {
            this.elements.statsContainer.setVisible(false);
        }

        console.log("Game resumed");
    },

    // Pause game and show overlay
    pauseGameWithOverlay: function () {
        if (gameOver) return;

        // Check initialization before proceeding
        if (!this.elements.pauseScreen) {
            console.warn("Pause UI elements not initialized, recreating...");
            const scene = game.scene.scenes[0];
            if (scene) {
                this.createPauseScreen(scene);
            } else {
                console.error("Cannot access scene to create pause elements");
                return;
            }
        }

        // Pause game systems
        this.pauseGame();

        // Show pause screen elements
        this.elements.pauseScreen.setVisible(true);
        this.elements.pauseMessage.setVisible(true);
        this.elements.resumeButton.setVisible(true);

        // Get the active scene
        const scene = game.scene.scenes[0];
        if (scene) {
            // In kajisuli mode, show stats before perks
            if (KAJISULI_MODE) {
                this.showStatsDisplay(scene);
            }

            // Update and show perks
            this.updatePauseScreenPerks(scene);
        }

        console.log("Game paused with overlay");
    },

    // Create and show stats display (for kajisuli mode)
    showStatsDisplay: function (scene, options = {}) {
        // Default options that preserve original pause screen behavior
        const config = {
            container: options.container ?? this.elements.statsContainer,
            positionY: options.positionY ?? game.config.height * 0.2,
            storeInElements: options.storeInElements ?? true, // Original behavior stores in elements
            clearContainer: options.clearContainer ?? true,
            setVisible: options.setVisible ?? true
        };

        // Clear any existing stats display if requested (original behavior)
        if (config.clearContainer && config.container) {
            config.container.removeAll(true);
        }

        // Define stat info with kanji and values (same as original)
        const stats = [
            { symbol: UI.statDisplay.symbols.POW, value: getEffectiveDamage(), color: UI.statDisplay.symbolColors.POW },
            { symbol: UI.statDisplay.symbols.AGI, value: getEffectiveFireRate(), color: UI.statDisplay.symbolColors.AGI },
            { symbol: UI.statDisplay.symbols.LUK, value: playerLuck, color: UI.statDisplay.symbolColors.LUK },
            { symbol: UI.statDisplay.symbols.END, value: maxPlayerHealth, color: UI.statDisplay.symbolColors.END }
        ];

        // Get center X position
        const centerX = game.config.width / 2;

        // Use provided Y position
        const statsY = config.positionY;

        // Set container position and visibility if using the original container
        if (config.container === this.elements.statsContainer) {
            config.container.setPosition(0, 0);
            if (config.setVisible) {
                config.container.setVisible(true);
            }
        }

        // Calculate spacing and box dimensions (same as original)
        const boxWidth = game.config.width * 0.15;    // 15% of screen width per box
        const boxHeight = game.config.height * 0.05;  // 5% of screen height
        const spacing = game.config.width * 0.06;     // 6% of screen width between boxes
        const totalWidth = (boxWidth * stats.length) + (spacing * (stats.length - 1));
        const startX = centerX - (totalWidth / 2) + (boxWidth / 2);

        // Store created elements for return (new functionality)
        const createdElements = [];

        // Add each stat in its own gold-bordered box (same as original)
        stats.forEach((stat, index) => {
            // Calculate x position with even spacing
            const x = startX + (spacing + boxWidth) * index;

            // Create gold border for this stat
            const border = scene.add.rectangle(
                x, statsY,
                boxWidth, boxHeight,
                UI.colors.gold
            );

            // Create inner black background
            const background = scene.add.rectangle(
                x, statsY,
                boxWidth - 4, boxHeight - 4,
                0x000000
            );

            // Create the stat text: kanji and value on the same line
            const statText = scene.add.text(
                x, statsY,
                `${stat.symbol} ${Math.floor(stat.value)}`,
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: stat.color,
                    fontStyle: 'bold'
                }
            ).setOrigin(0.5);

            // Store elements for return
            const statGroup = { border, background, statText };
            createdElements.push(statGroup);

            // Add all elements to the container (original behavior)
            if (config.container) {
                config.container.add([border, background, statText]);
            }
        });

        // Return created elements for external use (new functionality)
        return createdElements;
    },

    // Update perks display in pause screen
    updatePauseScreenPerks: function (scene) {
        // Check initialization before proceeding
        if (!this.elements.pausePerksContainer) {
            console.warn("Pause perks container not initialized");
            return;
        }

        const centerX = game.config.width / 2;

        // Clear existing perk icons first
        if (this.elements.perkIcons) {
            this.elements.perkIcons.forEach(icon => {
                if (icon && icon.destroy) {
                    icon.destroy();
                }
            });
        }
        this.elements.perkIcons = [];

        // Clear existing perk card if any
        if (this.elements.activePerkCard) {
            this.elements.activePerkCard.forEach(element => {
                if (element && element.destroy) {
                    element.destroy();
                }
            });
            this.elements.activePerkCard = null;
        }

        // Clear pagination controls if they exist
        if (this.elements.paginationControls) {
            this.elements.paginationControls.forEach(control => {
                if (control && control.destroy) {
                    control.destroy();
                }
            });
        }
        this.elements.paginationControls = [];

        // Set container visible
        this.elements.pausePerksContainer.setVisible(true);

        // If no perks, show a message
        if (acquiredPerks.length === 0) {
            const noPerkText = scene.add.text(
                centerX,
                game.config.height * 0.4375, // 350/800 = 0.4375
                'No perks acquired yet',
                { fontFamily: 'Arial', fontSize: '20px', color: '#aaaaaa' }
            ).setOrigin(0.5);
            this.elements.perkIcons.push(noPerkText);
            this.elements.pausePerksContainer.add(noPerkText);
            return;
        }

        // Create temporary text objects to measure each kanji's width
        const measurements = [];
        acquiredPerks.forEach(perkId => {
            const perk = PERKS[perkId];
            if (!perk) return;

            // Create temp text for measurement
            const tempText = scene.add.text(0, 0, perk.kanji, {
                fontFamily: 'Arial',
                fontSize: '32px',
                fontStyle: 'bold'
            });

            // Store the width and perk info
            measurements.push({
                perkId: perkId,
                width: tempText.width
            });

            // Remove the temp text
            tempText.destroy();
        });

        // Configuration for paginated layout - adjust for kajisuli mode
        const perksPerRow = KAJISULI_MODE ? 4 : 8; // Fewer perks per row in kajisuli mode 
        const rowsPerPage = KAJISULI_MODE ? 5 : 4; // More rows in kajisuli mode due to taller screen
        const perksPerPage = perksPerRow * rowsPerPage;

        // Adjust spacing and positioning for different screen sizes
        const spacing = game.config.width * 0.04; // Relative spacing
        const rowHeight = game.config.height * 0.075; // Relative row height

        // Adjust startY based on kajisuli mode and stats display
        const startY = KAJISULI_MODE ?
            game.config.height * 0.4 : // Higher in kajisuli mode to make room for stats
            game.config.height * 0.35; // Normal position

        // Calculate total number of pages
        const totalPages = Math.ceil(measurements.length / perksPerPage);

        // Ensure current page is valid
        this.currentPerkPage = Math.min(this.currentPerkPage, totalPages - 1);
        this.currentPerkPage = Math.max(0, this.currentPerkPage);

        // Get perks for the current page
        const startIndex = this.currentPerkPage * perksPerPage;
        const currentPagePerks = measurements.slice(startIndex, startIndex + perksPerPage);

        // Split current page perks into rows
        const rows = [];
        for (let i = 0; i < currentPagePerks.length; i += perksPerRow) {
            rows.push(currentPagePerks.slice(i, i + perksPerRow));
        }

        // Process each row
        rows.forEach((row, rowIndex) => {
            // Calculate total width of this row with spacing
            const rowWidth = row.reduce((sum, item) => sum + item.width, 0) +
                (spacing * (row.length - 1));

            // Calculate starting X position to center this row
            let currentX = centerX - (rowWidth / 2);
            const y = startY + (rowIndex * rowHeight);

            // Create perk icons for this row
            row.forEach(item => {
                const perkId = item.perkId;
                const perk = PERKS[perkId];

                // Position this kanji centered on its width
                const centerX = currentX + (item.width / 2);

                // Create the perk icon (kanji) with improved visual styling
                const perkIcon = scene.add.text(
                    centerX, y,
                    perk.kanji,
                    {
                        fontFamily: 'Arial',
                        fontSize: '32px',
                        color: perk.color,
                        fontStyle: 'bold',
                        stroke: '#000000',
                        strokeThickness: 4
                    }
                ).setOrigin(0.5);

                // Make interactive
                perkIcon.setInteractive({ useHandCursor: true });

                // Add enhanced hover effects
                perkIcon.on('pointerover', function () {
                    // Scale effect on hover
                    this.setScale(1.2);

                    // Always place card below, regardless of row position
                    // Adjust card position for kajisuli mode
                    const cardY = KAJISULI_MODE ?
                        Math.min(y + game.config.height * 0.15, game.config.height * 0.7) : // Keep within bounds
                        y + game.config.height * 0.1875; // Normal position

                    PauseSystem.showPerkCard(scene, perkId, centerX, cardY);
                });

                perkIcon.on('pointerout', function () {
                    // Reset scale
                    this.setScale(1);
                    PauseSystem.hidePerkCard(scene);
                });

                // Store reference
                this.elements.perkIcons.push(perkIcon);

                // Add to container
                this.elements.pausePerksContainer.add(perkIcon);

                // Move currentX position for the next kanji
                currentX += item.width + spacing;
            });
        });

        // Only show pagination if we have multiple pages
        if (totalPages > 1) {
            // Adjust pagination position for kajisuli mode
            const paginationY = KAJISULI_MODE ?
                game.config.height * 0.8 : // Lower in kajisuli mode
                game.config.height * 0.725; // Normal position

            // Create left arrow (if not on first page)
            if (this.currentPerkPage > 0) {
                const leftArrow = scene.add.text(
                    centerX - game.config.width * 0.15, // Relative positioning
                    paginationY,
                    '◀',
                    {
                        fontFamily: 'Arial',
                        fontSize: '48px',
                        color: '#ffffff'
                    }
                ).setOrigin(0.5);

                leftArrow.setInteractive({ useHandCursor: true });

                leftArrow.on('pointerdown', () => {
                    this.currentPerkPage--;
                    this.updatePauseScreenPerks(scene);
                });

                // Enhanced hover effects
                leftArrow.on('pointerover', function () {
                    this.setColor('#aaffaa');
                    // Scale effect
                    this.setScale(1.2);
                });

                leftArrow.on('pointerout', function () {
                    this.setColor('#ffffff');
                    // Reset scale
                    this.setScale(1);
                });

                this.elements.paginationControls.push(leftArrow);
                this.elements.pausePerksContainer.add(leftArrow);
            }

            // Create page counter
            const pageCounter = scene.add.text(
                centerX,
                paginationY,
                `${this.currentPerkPage + 1}/${totalPages}`,
                {
                    fontFamily: 'Arial',
                    fontSize: '40px',
                    color: '#ffffff'
                }
            ).setOrigin(0.5);

            this.elements.paginationControls.push(pageCounter);
            this.elements.pausePerksContainer.add(pageCounter);

            // Create right arrow (if not on last page)
            if (this.currentPerkPage < totalPages - 1) {
                const rightArrow = scene.add.text(
                    centerX + game.config.width * 0.15, // Relative positioning
                    paginationY,
                    '▶',
                    {
                        fontFamily: 'Arial',
                        fontSize: '48px',
                        color: '#ffffff'
                    }
                ).setOrigin(0.5);

                rightArrow.setInteractive({ useHandCursor: true });

                rightArrow.on('pointerdown', () => {
                    this.currentPerkPage++;
                    this.updatePauseScreenPerks(scene);
                });

                // Enhanced hover effects
                rightArrow.on('pointerover', function () {
                    this.setColor('#aaffaa');
                    // Scale effect
                    this.setScale(1.2);
                });

                rightArrow.on('pointerout', function () {
                    this.setColor('#ffffff');
                    // Reset scale
                    this.setScale(1);
                });

                this.elements.paginationControls.push(rightArrow);
                this.elements.pausePerksContainer.add(rightArrow);
            }
        }
    },

    // Show detailed perk card
    showPerkCard: function (scene, perkId, x, y) {
        // Clear any existing perk card
        this.hidePerkCard(scene);

        // Create card elements using the shared function with better styling
        this.elements.activePerkCard = window.CardSystem.createPerkCard(perkId, x, y, {
            container: this.elements.pausePerksContainer,
            backgroundColor: 0x333333,
            strokeWidth: 3,
            strokeColor: 0xeeeeee,
            // Adjust card size for kajisuli mode
            scale: KAJISULI_MODE ? 0.85 : 1 // Slightly smaller in kajisuli mode
        });
    },

    // Hide perk card
    hidePerkCard: function (scene) {
        if (this.elements.activePerkCard) {
            this.elements.activePerkCard.forEach(element => {
                if (element && element.destroy) {
                    element.destroy();
                }
            });
            this.elements.activePerkCard = null;
        }
    },

    // Cleanup all UI elements
    cleanup: function () {
        // Clean up all UI elements
        Object.values(this.elements).forEach(element => {
            if (element && element.destroy) {
                element.destroy();
            } else if (Array.isArray(element)) {
                element.forEach(item => {
                    if (item && item.destroy) {
                        item.destroy();
                    }
                });
            }
        });

        // Reset elements
        this.elements = {
            pauseScreen: null,
            resumeButton: null,
            pauseMessage: null,
            perkIcons: [],
            paginationControls: [],
            activePerkCard: null,
            pausePerksContainer: null,
            statsContainer: null
        };

        // Reset state
        this.currentPerkPage = 0;
        this.isInitialized = false;
    }
};

// Export the system for use in other files
window.PauseSystem = PauseSystem;

// ======= perks.js =======
// Map of all available perks
const PERKS = {
    // =========================================================================
    // ANIMAL-COLOR PERKS
    // =========================================================================
    "RED_DRAGON": {
        kanji: "赤竜",
        kana: "あかりゅう",
        romaji: "akaryuu",
        english: "Red Dragon",
        description: "+2 POW / -1 AGI",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 2);
            window.modifyStat('fireRate', -1);
        }
    },
    "BLUE_WHALE": {
        kanji: "青鯨",
        kana: "あおくじら",
        romaji: "aokujira",
        english: "Blue Whale",
        description: "Permanent Protection",
        color: "#3498db",
        hoverColor: 0x2980b9,
        onAcquire: function () {

        }
    },
    "FATED_SHIELD": {
        kanji: "運命の盾",
        kana: "うんめいのたて",
        romaji: "unmeinotate",
        english: "Fated Shield",
        description: "Auto Shield when at 1 HP",
        color: "#FF5555",
        hoverColor: 0xDD3333,
        onAcquire: function () {
            // The component is added through PlayerPerkRegistry
        }
    },
    "BLOOMING_FLOWER": {
        kanji: "花咲く",
        kana: "はなさく",
        romaji: "hanasaku",
        english: "Blooming Flower",
        description: "This flower attacks nearby enemies",
        color: "#FF66AA", // Pink color
        hoverColor: 0xDD4488,
        onAcquire: function () {
            window.activateBloomingFlower();
        }
    },
    "TEAL_OCTOPUS": {
        kanji: "青緑蛸",
        kana: "あおみどりたこ",
        romaji: "aomidoritako",
        english: "Teal Octopus",
        description: "Gain orbiting projectiles",
        color: "#008080",
        hoverColor: 0x005f5f,
        onAcquire: function () {
            window.activateOrbitingProjectile();
        }
    },
    "INVERTED_OCTOPUS": {
        kanji: "逆蛸",
        kana: "ぎゃくたこ",
        romaji: "gyakutako",
        english: "Inverted Octopus",
        description: "More orbiting projectiles",
        color: "#FF55FF", // Pink color
        hoverColor: 0xDD33DD,
        onAcquire: function () {
            window.activateInvertedOctopus();
        }
    },
    "TENTACLE_GRASP": {
        kanji: "触手",
        kana: "しょくしゅ",
        romaji: "shokushu",
        english: "Tentacle Grasp",
        description: "Tentacles extend in all directions",
        color: "#8800AA", // Purple color
        hoverColor: 0x660088,
        onAcquire: function () {
            window.activateTentacleGrasp();
        }
    },
    "GLASS_CANNON": {
        kanji: "硝子砲",
        kana: "がらすほう",
        romaji: "garasuhou",
        english: "Glass Cannon",
        description: "+5 POW / END reduced to 1",
        color: "#FF0000",
        hoverColor: 0xDD0000,
        onAcquire: function () {
            // Increase POW by 5
            window.modifyStat('damage', 5);

            // Simply use a large negative value, the minimum check will handle it
            window.modifyStat('health', -999);
        }
    },
    "DEATH_FINGER": {
        kanji: "死指",
        kana: "しゆび",
        romaji: "shiyubi",
        english: "Death Finger",
        description: "Those who stare death take damage",
        color: "#FF0000", // Red color
        hoverColor: 0xDD0000,
        onAcquire: function () {
            window.activateDeathFinger();
        }
    },
    "HEALING_FAIRY": {
        kanji: "癒精",
        kana: "いやせい",
        romaji: "iyasei",
        english: "Healing Fairy",
        description: "Protect her and stay close",
        color: "#7FFF7F", // Light green color
        hoverColor: 0x5FDF5F,
        onAcquire: function () {
            window.activateHealingFairy();
        }
    },
    "WRECKING_BALL": {
        kanji: "破球",
        kana: "はきゅう",
        romaji: "hakyuu",
        english: "Wrecking Ball",
        description: "Orbits and explodes",
        color: "#777777", // Iron/steel gray color
        hoverColor: 0x555555,
        onAcquire: function () {
            window.activateWreckingBall();
        }
    },
    "GOLD_FORTRESS": {
        kanji: "金城",
        kana: "きんじょう",
        romaji: "kinjou",
        english: "Gold Fortress",
        description: "-1 POW / -1 AGI / -1 LUK / +5 END",
        color: "#FFD700",        // Gold
        hoverColor: 0xB8860B,     // DarkGoldenRod (or 0xCCA700 if you prefer that shade)
        onAcquire: function () {
            window.modifyStat('damage', -1);    // -1 POW
            window.modifyStat('fireRate', -1);  // -1 AGI
            window.modifyStat('luck', -1);      // -1 LUK
            window.modifyStat('health', 5);     // +5 END
        }
    },
    "DENIAL_OF_FATE": {
        kanji: "運命否定",
        kana: "うんめいひてい",
        romaji: "unmeihitei",
        english: "Denial of Fate",
        description: "+3 POW / +3 AGI / -5 LUK",
        color: "#ff6600", // Orange-red color
        hoverColor: 0xdd4400,
        onAcquire: function () {
            window.modifyStat('damage', 2);
            window.modifyStat('fireRate', 2);
            window.modifyStat('luck', -3);
        }
    },
    "AMBER_BEETLE": {
        kanji: "琥珀甲虫",
        kana: "こはくこうちゅう",
        romaji: "kohakukouchuu",
        english: "Amber Beetle",
        description: "Drops projectiles that damage enemies",
        color: "#ffbf00",
        hoverColor: 0xbb8c00,
        onAcquire: function () {
            window.activateLandmines();
        }
    },
    "SNIPER_FAIRY": {
        kanji: "狙撃精", // Changed from "狙" to "狙撃精" (Sniper Fairy)
        kana: "そげきせい", // Changed from "ねらう" to "そげきせい"
        romaji: "sogeikisei", // Changed from "nerau" to "sogeikisei"
        english: "Sniper Fairy",
        description: "A fairy with slow but powerful long range shots",
        color: "#FF55AA",
        hoverColor: 0xDD3388,
        onAcquire: function () {
            window.activateSniperFairy();
        }
    },
    "WILD_FAIRY": {
        kanji: "野妖精",
        kana: "のようせい",
        romaji: "noyousei",
        english: "Wild Fairy",
        description: "This erratic fairy orbits at high speed and damages enemies",
        color: "#FF66CC", // Bright pink color
        hoverColor: 0xDD44AA,
        onAcquire: function () {
            window.activateWildFairy();
            window.modifyStat('luck', 1);
        }
    },
    "ANGEL_HONEY": {
        kanji: "天蜜",
        kana: "てんみつ",
        romaji: "tenmitsu",
        english: "Angel Honey",
        description: "Periodically spawns honey for a full heal",
        color: "#00CC00", // Green color
        hoverColor: 0x00AA00,
        onAcquire: function () {
            // The component is added through PlayerPerkRegistry
        }
    },

    // Food perks that increase max HP and heal the player
    "SUSHI": {
        kanji: "寿司",
        kana: "すし",
        romaji: "sushi",
        english: "Sushi",
        description: "+1 END, full heal",
        color: "#FFFFFF",
        hoverColor: 0xE0E0E0,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "RAMEN": {
        kanji: "拉麺",
        kana: "ラーメン",
        romaji: "raamen",
        english: "Ramen",
        description: "+1 END and temporary shield",
        color: "#FFA07A",
        hoverColor: 0xDD8866,
        onAcquire: function () {
            window.modifyStat('health', 1);
            ShieldSystem.activateShield();
        }
    },
    "ONIGIRI": {
        kanji: "御握り",
        kana: "おにぎり",
        romaji: "onigiri",
        english: "Rice Ball",
        description: "+1 END and fully heals",
        color: "#F5F5DC",
        hoverColor: 0xE5E5CC,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "MOCHI": {
        kanji: "餅",
        kana: "もち",
        romaji: "mochi",
        english: "Rice Cake",
        description: "+1 END and fully heals",
        color: "#FFE4E1",
        hoverColor: 0xEED4D1,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "DANGO": {
        kanji: "団子",
        kana: "だんご",
        romaji: "dango",
        english: "Dumpling",
        description: "+1 END and fully heals",
        color: "#F0E68C",
        hoverColor: 0xE0D67C,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "TEMPURA": {
        kanji: "天ぷら",
        kana: "てんぷら",
        romaji: "tenpura",
        english: "Tempura",
        description: "+1 END and fully heals",
        color: "#FFD700",
        hoverColor: 0xEEC700,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "UDON": {
        kanji: "饂飩",
        kana: "うどん",
        romaji: "udon",
        english: "Udon Noodles",
        description: "+1 END and fully heals",
        color: "#FAEBD7",
        hoverColor: 0xEADBc7,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "YAKITORI": {
        kanji: "焼鳥",
        kana: "やきとり",
        romaji: "yakitori",
        english: "Grilled Chicken",
        description: "+1 END and fully heals",
        color: "#CD853F",
        hoverColor: 0xBD752F,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "TAKOYAKI": {
        kanji: "蛸焼き",
        kana: "たこやき",
        romaji: "takoyaki",
        english: "Octopus Balls",
        description: "+1 END and fully heals",
        color: "#8B4513",
        hoverColor: 0x7B3503,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "GYOZA": {
        kanji: "餃子",
        kana: "ぎょうざ",
        romaji: "gyouza",
        english: "Dumplings",
        description: "+1 END and fully heals",
        color: "#D3D3D3",
        hoverColor: 0xC3C3C3,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "TAIYAKI": {
        kanji: "鯛焼き",
        kana: "たいやき",
        romaji: "taiyaki",
        english: "Fish-shaped Cake",
        description: "+1 END and fully heals",
        color: "#DEB887",
        hoverColor: 0xCEA877,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "BENTO": {
        kanji: "弁当",
        kana: "べんとう",
        romaji: "bentou",
        english: "Lunch Box",
        description: "+1 END and fully heals",
        color: "#FF6347",
        hoverColor: 0xEF5337,
        onAcquire: function () {
            window.modifyStat('health', 1);
            window.fullHeal();
        }
    },
    "GREEN_VENOM": {
        kanji: "緑毒",
        kana: "みどりどく",
        romaji: "midoridoku",
        english: "Green Venom",
        description: "Poisonous projectiles deal damage over time",
        color: "#2aad27",
        hoverColor: 0x1a8d17,
        onAcquire: function () {
        }
    },
    "AZURE_FORK": {
        kanji: "蒼の叉",
        kana: "あおのまた",
        romaji: "aonomata",
        english: "Azure Fork",
        description: "Chance to split in two when hitting enemies",
        color: "#1E90FF",
        hoverColor: 0x0070DD,
        onAcquire: function () {
            //
        }
    },
    "POISON_FLOWER": {
        kanji: "毒花",
        kana: "どくばな",
        romaji: "dokubana",
        english: "Poison Flower",
        description: "This flower pulses poison, damaging enemies over time",
        color: "#2aad27", // Green color matching the poison effect
        hoverColor: 0x1a8d17,
        onAcquire: function () {
            window.activatePoisonFlower();
        }
    },
    "COLD_FLOWER": {
        kanji: "冷花",
        kana: "れいばな",
        romaji: "reibana",
        english: "Frost Flower",
        description: "This flower slows down enemies",
        color: "#00ffff", // Cyan color matching the slow effect
        hoverColor: 0x00dddd,
        onAcquire: function () {
            window.activateColdFlower();
        }
    },
    "BRIGHT_LANCE": {
        kanji: "光槍",
        kana: "こうそう",
        romaji: "kousou",
        english: "Bright Lance",
        description: "A glowing lance that follows your movement direction",
        color: "#FFFF33", // Bright yellow color
        hoverColor: 0xDDDD00,
        onAcquire: function () {
            window.activateBrightLance();
        }
    },
    "LAVA_FAIRIES": {
        kanji: "溶岩精",
        kana: "ようがんせい",
        romaji: "yougansei",
        english: "Lava Fairies",
        description: "On death, they drop magma that damages enemies",
        color: "#FF6600", // Orange-red color for lava
        hoverColor: 0xDD4400,
        onAcquire: function () {
            window.activateLavaFairies();
        }
    },
    "TOXIC_TRAIL": {
        kanji: "毒痕",
        kana: "どくあと",
        romaji: "dokuato",
        english: "Toxic Trail",
        description: "Your sickness poisons those who follow",
        color: "#33cc33", // Green color for poison
        hoverColor: 0x22aa22, // Darker green for hover effect
        onAcquire: function () {
            window.activateToxicTrail();
            window.modifyStat('health', -1);
            window.modifyStat('damage', -1);
            window.modifyStat('fireRate', -1);
            window.modifyStat('luck', -1);
        }
    },
    "FINGER_OF_DECAY": {
        kanji: "朽指",
        kana: "くちゆび",
        romaji: "kuchiyubi",
        english: "Finger of Decay",
        description: "Those pointed at get sick",
        color: "#88AA22", // Sickly greenish-yellow color
        hoverColor: 0x668800,
        onAcquire: function () {
            window.activateFingerOfDecay();
        }
    },
    "STORM_CALLER": {
        kanji: "雷神",
        kana: "らいじん",
        romaji: "raijin",
        english: "Storm Caller",
        description: "Lightning strikes your enemies",
        color: "#FFDD00", // Bright yellow color
        hoverColor: 0xDDBB00,
        onAcquire: function () {
            window.activateStormCaller();
        }
    },
    "STORM_BRINGER": {
        kanji: "雷招",
        kana: "らいまねき",
        romaji: "raimaneki",
        english: "Storm Bringer",
        description: "Beacons bring down lightning",
        color: "#00DDFF", // Bright cyan color
        hoverColor: 0x00BBDD,
        onAcquire: function () {

        }
    },
    "STORM_VENGEANCE": {
        kanji: "雷怨",
        kana: "らいえん",
        romaji: "raien",
        english: "Storm Vengeance",
        description: "Lightning strikes back after a hit",
        color: "#FFAAFF", // Pinkish lightning color
        hoverColor: 0xDD88DD,
        onAcquire: function () {
            // The effect is handled by the OnHitEffectSystem
            // No additional implementation needed here
        }
    },
    "SCARLET_EMBER": {
        kanji: "緋炎",
        kana: "ひえん",
        romaji: "hien",
        english: "Scarlet Ember",
        description: "Fires burn enemies over time",
        color: "#FF4500",
        hoverColor: 0xCC3700,
        onAcquire: function () {
            //
        }
    },

    // Red animal perks (damage focused)
    "RED_TIGER": {
        kanji: "赤虎",
        kana: "あかとら",
        romaji: "akatora",
        english: "Red Tiger",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "RED_HAWK": {
        kanji: "赤鷹",
        kana: "あかたか",
        romaji: "akataka",
        english: "Red Hawk",
        description: "+1 POW / +1 AGI",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
            window.modifyStat('fireRate', 1);
        }
    },
    "RED_BEAR": {
        kanji: "赤熊",
        kana: "あかくま",
        romaji: "akakuma",
        english: "Red Bear",
        description: "+2 POW / -1 AGI",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 2);
            window.modifyStat('fireRate', -1);
        }
    },
    "RED_SCORPION": {
        kanji: "赤蠍",
        kana: "あかさそり",
        romaji: "akasasori",
        english: "Red Scorpion",
        description: "+2 POW / -1 LUK",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 2);
            window.modifyStat('luck', -1);
        }
    },
    "RED_FOX": {
        kanji: "赤狐",
        kana: "あかきつね",
        romaji: "akakitsune",
        english: "Red Fox",
        description: "+1 POW / +1 LUK",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
            window.modifyStat('luck', 1);
        }
    },
    "RED_WOLF": {
        kanji: "赤狼",
        kana: "あかおおかみ",
        romaji: "akaookami",
        english: "Red Wolf",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "RED_SNAKE": {
        kanji: "赤蛇",
        kana: "あかへび",
        romaji: "akahebi",
        english: "Red Snake",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "RED_MANTIS": {
        kanji: "赤蟷螂",
        kana: "あかかまきり",
        romaji: "akakamakiri",
        english: "Red Mantis",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "RED_LION": {
        kanji: "赤獅子",
        kana: "あかしし",
        romaji: "akashishi",
        english: "Red Lion",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "RED_FALCON": {
        kanji: "赤隼",
        kana: "あかはやぶさ",
        romaji: "akahayabusa",
        english: "Red Falcon",
        description: "+1 POW",
        color: "#ff3333",
        hoverColor: 0xbb2222,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },

    // Yellow animal perks (fire rate focused)
    "YELLOW_CHEETAH": {
        kanji: "黄豹",
        kana: "きひょう",
        romaji: "kihyou",
        english: "Yellow Cheetah",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_HUMMINGBIRD": {
        kanji: "黄蜂鳥",
        kana: "きはちどり",
        romaji: "kihachidori",
        english: "Yellow Hummingbird",
        description: "+4 AGI / -2 POW",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 4);
            window.modifyStat('damage', -2);
        }
    },
    "YELLOW_WASP": {
        kanji: "黄蜂",
        kana: "きばち",
        romaji: "kibachi",
        english: "Yellow Wasp",
        description: "+2 AGI / -2 END",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 2);
            window.modifyStat('health', -2);
        }
    },
    "YELLOW_JACKAL": {
        kanji: "黄豺",
        kana: "きやまいぬ",
        romaji: "kiyamainu",
        english: "Yellow Jackal",
        description: "+3 AGI / -1 POW / -1 END",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 3);
            window.modifyStat('damage', -1);
            window.modifyStat('health', -1);
        }
    },
    "YELLOW_CANARY": {
        kanji: "黄鳥",
        kana: "きどり",
        romaji: "kidori",
        english: "Yellow Canary",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_HORNET": {
        kanji: "黄雀蜂",
        kana: "きすずめばち",
        romaji: "kisuzumebachi",
        english: "Yellow Hornet",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_BEE": {
        kanji: "黄蜜蜂",
        kana: "きみつばち",
        romaji: "kimitsubachi",
        english: "Yellow Bee",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_FINCH": {
        kanji: "黄雀",
        kana: "きひわ",
        romaji: "kihiwa",
        english: "Yellow Finch",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_SQUIRREL": {
        kanji: "黄栗鼠",
        kana: "きりす",
        romaji: "kirisu",
        english: "Yellow Squirrel",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_CICADA": {
        kanji: "黄蝉",
        kana: "きせみ",
        romaji: "kisemi",
        english: "Yellow Cicada",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "YELLOW_CRICKET": {
        kanji: "黄蟋蟀",
        kana: "きこおろぎ",
        romaji: "kikoorogi",
        english: "Yellow Cricket",
        description: "+1 AGI",
        color: "#ffd700",
        hoverColor: 0xcca700,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },

    // Purple animal perks (luck focused)
    "PURPLE_MONKEY": {
        kanji: "紫猿",
        kana: "むらさきざる",
        romaji: "murasakizaru",
        english: "Purple Monkey",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_CAT": {
        kanji: "紫猫",
        kana: "むらさきねこ",
        romaji: "murasakineko",
        english: "Purple Cat",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_BUTTERFLY": {
        kanji: "紫蝶",
        kana: "むらさきちょう",
        romaji: "murasakichou",
        english: "Purple Butterfly",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_RABBIT": {
        kanji: "紫兎",
        kana: "むらさきうさぎ",
        romaji: "murasakiusagi",
        english: "Purple Rabbit",
        description: "+2 LUK / -1 END",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 2);
            window.modifyStat('health', -1);
        }
    },
    "PURPLE_OWL": {
        kanji: "紫梟",
        kana: "むらさきふくろう",
        romaji: "murasakifukurou",
        english: "Purple Owl",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_FOX": {
        kanji: "紫狐",
        kana: "むらさききつね",
        romaji: "murasakikitsune",
        english: "Purple Fox",
        description: "+3 LUK / -1 POW / -1 AGI",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 3);
            window.modifyStat('damage', -1);
            window.modifyStat('fireRate', -1);
        }
    },
    "PURPLE_LADYBUG": {
        kanji: "紫瓢虫",
        kana: "むらさきてんとうむし",
        romaji: "murasakitentoumushi",
        english: "Purple Ladybug",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_BAT": {
        kanji: "紫蝙蝠",
        kana: "むらさきこうもり",
        romaji: "murasakikoumori",
        english: "Purple Bat",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_HARE": {
        kanji: "紫野兎",
        kana: "むらさきのうさぎ",
        romaji: "murasakinousagi",
        english: "Purple Hare",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PURPLE_MOTH": {
        kanji: "紫蛾",
        kana: "むらさきが",
        romaji: "murasakiga",
        english: "Purple Moth",
        description: "+1 LUK",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "PIERCING_SHOTS": {
        kanji: "貫通",
        kana: "かんつう",
        romaji: "kantsuu",
        english: "Piercing Shot",
        description: "Pierce through enemies",
        color: "#00ff88",
        hoverColor: 0x00cc66,
        onAcquire: function () {
        }
    },
    "YELLOW_BOOMERANG": {
        kanji: "黄回",
        kana: "きかい",
        romaji: "kikai",
        english: "Yellow Boomerang",
        description: "Return with benefits",
        color: "#FFA500", // Orange color
        hoverColor: 0xDD8800,
        onAcquire: function () {
        }
    },
    "FINAL_CATASTROPHE": {
        kanji: "終焉",
        kana: "しゅうえん",
        romaji: "shuuen",
        english: "Final Catastrophe",
        description: "Apocalyptic blast damages all enemies",
        color: "#FF3300", // Bright red-orange
        hoverColor: 0xCC2200,
        onAcquire: function () {
            window.triggerOneTimeEffect('shuuen');
        }
    },
    "PURPLE_CHAOS": {
        kanji: "紫混沌",
        kana: "むらさきこんとん",
        romaji: "murasakikonton",
        english: "Purple Chaos",
        description: "Randomly rearranges all your stats, then +2 LUK",
        color: "#9932cc",
        hoverColor: 0x8822bc,
        onAcquire: function () {
            window.triggerOneTimeEffect('purpleChaos');
        }
    },
    "ANGER_RISING": {
        kanji: "怒上昇",
        kana: "いかりじょうしょう",
        romaji: "ikarijoushou",
        english: "Anger Rising",
        description: "Get hit, deal more damage (+10%, up to +100%)",
        color: "#FF4500", // Orange-red
        hoverColor: 0xDD3300,
        onAcquire: function () {
            // The effect is handled by the OnHitEffectSystem
        }
    },
    "ALIEN_MUSHROOM": {
        kanji: "異菇",
        kana: "いきのこ",
        romaji: "ikinoko",
        english: "Alien Mushroom",
        description: "+1 to all stats and a brief time dilation",
        color: "#9966FF", // Purple-blue color
        hoverColor: 0x7744DD,
        onAcquire: function () {
            // +1 to all stats
            window.modifyStat('damage', 1);
            window.modifyStat('fireRate', 1);
            window.modifyStat('luck', 1);
            window.modifyStat('health', 1);

            // Activate time dilation once (if available)
            if (window.TimeDilationSystem && window.activateTimeDilation) {
                window.activateTimeDilation(2000); // 4 seconds of time dilation (2s / 50%)
            }
        }
    },
    "MAGMA_FLOOR": {
        kanji: "熔地",
        kana: "ようち",
        romaji: "youchi",
        english: "Magma Floor",
        description: "Creates pools of magma that damage enemies",
        color: "#FF4400", // Orange-red color
        hoverColor: 0xDD2200,
        onAcquire: function () {
            window.activateMagmaFloor();
        }
    },
    "FROST_SHRAPNEL": {
        kanji: "氷片",
        kana: "ひょうへん",
        romaji: "hyouhen",
        english: "Frost Shrapnel",
        description: "Regularly drops ice shards that damage and slow enemies",
        color: "#00FFFF", // Cyan color
        hoverColor: 0x00DDDD,
        onAcquire: function () {
            window.activateFrostShrapnel();
        }
    },
    "OBLIVION_BLOSSOM": {
        kanji: "忘却の花",
        kana: "ぼうきゃくのはな",
        romaji: "boukyakunohana",
        english: "Oblivion Blossom",
        description: "Sacrifice all your perks, gaining permanent strength from each memory lost",
        color: "#BBBBFF", // Light purple/blue color
        hoverColor: 0x9999DD,
        onAcquire: function () {
            window.triggerOneTimeEffect('oblivionBlossom');
        }
    },
    "COPY_FAIRY": {
        kanji: "写精",
        kana: "うつしせい",
        romaji: "utsushisei",
        english: "Copy Fairy",
        description: "Your biggest fan",
        color: "#55FFAA", // Greenish color
        hoverColor: 0x33DD88,
        onAcquire: function () {
            window.activateCopyFairy();
        }
    },
    "FUN_FAIRY": {
        kanji: "遊精",
        kana: "ゆうせい",
        romaji: "yuusei",
        english: "Fun Fairy",
        description: "Full of tricks",
        color: "#FF55FF", // Pink color
        hoverColor: 0xDD33DD,
        onAcquire: function () {
            window.activateFunFairy();
        }
    },
    "COLD_FAIRY": {
        kanji: "冷精",
        kana: "れいせい",
        romaji: "reisei",
        english: "Cold Fairy",
        description: "Slow shots",
        color: "#00FFFF", // Cyan color
        hoverColor: 0x00DDDD,
        onAcquire: function () {
            window.activateColdFairy();
        }
    },
    "BERSERK_FAIRY": {
        kanji: "狂精",
        kana: "きょうせい",
        romaji: "kyousei",
        english: "Berserk Fairy",
        description: "Wild partner",
        color: "#FF5500", // Orange-red color
        hoverColor: 0xDD3300,
        onAcquire: function () {
            window.activateBerserkFairy();
        }
    },
    "FLAWLESS_FIGHT": {
        kanji: "完璧",
        kana: "かんぺき",
        romaji: "kanpeki",
        english: "Flawless Fight",
        description: "+POW/+AGI as long as you avoid hits",
        color: "#00FFFF", // Cyan color
        hoverColor: 0x00DDDD,
        onAcquire: function () {
            // The component is added through OnHitPerkRegistry
            // Nothing specific needed here as the registration is handled in onhit.js
        }
    },
    "GREEN_DEER": {
        kanji: "緑鹿",
        kana: "みどりしか",
        romaji: "midorishika",
        english: "Green Deer",
        description: "+2 END",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('health', 2);
        }
    },
    "GREEN_FROG": {
        kanji: "緑蛙",
        kana: "みどりかえる",
        romaji: "midorikaeru",
        english: "Green Frog",
        description: "+1 POW",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('damage', 1);
        }
    },
    "GREEN_GAZELLE": {
        kanji: "緑ガゼル",
        kana: "みどりガゼル",
        romaji: "midorigazeru",
        english: "Green Gazelle",
        description: "+2 AGI / -1 END",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 2);
            window.modifyStat('health', -1);
        }
    },
    "GREEN_HORSE": {
        kanji: "緑馬",
        kana: "みどりうま",
        romaji: "midoriuma",
        english: "Green Horse",
        description: "+3 AGI / -1 POW",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 3);
            window.modifyStat('damage', -1);
        }
    },
    "GREEN_CRICKET": {
        kanji: "緑蟋蟀",
        kana: "みどりこおろぎ",
        romaji: "midorikoorogi",
        english: "Green Cricket",
        description: "+1 LUK",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('luck', 1);
        }
    },
    "GREEN_RABBIT": {
        kanji: "緑兎",
        kana: "みどりうさぎ",
        romaji: "midoriusagi",
        english: "Green Rabbit",
        description: "+2 LUK / -1 AGI",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('luck', 2);
            window.modifyStat('fireRate', -1);
        }
    },
    "GREEN_LIZARD": {
        kanji: "緑蜥蜴",
        kana: "みどりとかげ",
        romaji: "midoritokage",
        english: "Green Lizard",
        description: "+1 AGI",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "GREEN_HUMMINGBIRD": {
        kanji: "緑蜂鳥",
        kana: "みどりはちどり",
        romaji: "midorihachidori",
        english: "Green Hummingbird",
        description: "+1 AGI / +1 POW",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
            window.modifyStat('damage', 1);
        }
    },
    "GREEN_DOLPHIN": {
        kanji: "緑海豚",
        kana: "みどりいるか",
        romaji: "midoriiruka",
        english: "Green Dolphin",
        description: "+2 AGI / -1 END",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 2);
            window.modifyStat('health', -1);
        }
    },
    "GREEN_GRASSHOPPER": {
        kanji: "緑飛蝗",
        kana: "みどりばった",
        romaji: "midoribatta",
        english: "Green Grasshopper",
        description: "+1 AGI / +1 LUK",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
            window.modifyStat('luck', 1);
        }
    },
    "GREEN_SNAKE": {
        kanji: "緑蛇",
        kana: "みどりへび",
        romaji: "midorihebi",
        english: "Green Snake",
        description: "+1 AGI",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.modifyStat('fireRate', 1);
        }
    },
    "GREEN_DREAM": {
        kanji: "緑の夢",
        kana: "みどりのゆめ",
        romaji: "midorinoyume",
        english: "Green Dream",
        description: "Creates after-images that damage enemies",
        color: "#00cc66",
        hoverColor: 0x00aa44,
        onAcquire: function () {
            window.activateAfterImages();
        }
    },
    "PURPLE_OWL": {
        kanji: "紫梟",
        kana: "むらさきふくろう",
        romaji: "murasakifukurou",
        english: "Purple Owl",
        description: "Chance to fire a second projectile",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            // logic in index.html
        }
    },
    "ALIEN_WORLD": {
        kanji: "異世界",
        kana: "いせかい",
        romaji: "isekai",
        english: "Alien World",
        description: "When hit, the streams of time shift",
        color: "#00ffff", // Cyan color
        hoverColor: 0x00dddd,
        onAcquire: function () {
            // The effect is handled by the OnHitEffectSystem
        }
    },
    "ALIEN_CLOCK": {
        kanji: "時の砂",
        kana: "ときのすな",
        romaji: "tokinosuna",
        english: "Alien Clock",
        description: "Time moves differently on pickup",
        color: "#00ffff", // Cyan color like ALIEN_WORLD
        hoverColor: 0x00dddd,
        onAcquire: function () {
            // The effect is handled by the PlayerComponentSystem
            window.activateAlienClock();
        }
    },
    "PURPLE_HEDGEHOG": {
        kanji: "紫針鼠",
        kana: "むらさきはりねずみ",
        romaji: "murasakiharinezumi",
        english: "Purple Hedgehog",
        description: "Release projectiles in all directions when hit",
        color: "#9370db",
        hoverColor: 0x7350bb,
        onAcquire: function () {
            window.modifyStat('health', 1);
        }
    },
    "CRIMSON_SCATTER": {
        kanji: "紅散弾",
        kana: "べにさんだん",
        romaji: "benisandan",
        english: "Crimson Scatter",
        description: "Higher damage at short range",
        color: "#FF3030",
        hoverColor: 0xC02020,
        onAcquire: function () {
        }
    },
    "CRIMSON_FURY": {
        kanji: "紅の怒り",
        kana: "くれないのいかり",
        romaji: "kurenainoikari",
        english: "Crimson Fury",
        description: "Double damage when below 25% health",
        color: "#FF0000",
        hoverColor: 0xCC0000,
        onAcquire: function () {
            // The effect is handled by a state monitor system
            // We'll implement this in the update function
        }
    },
    "IMMORTAL_ARM": {
        kanji: "不死の腕",
        kana: "ふしのうで",
        romaji: "fushinoude",
        english: "Immortal Arm",
        description: "Summons an arm that orbits you and damages enemies",
        color: "#9932CC", // A deep purple color
        hoverColor: 0x7922BC,
        onAcquire: function () {
            window.activateImmortalArm();
        }
    },
    "IMMORTAL_HEAD": {
        kanji: "不死の頭",
        kana: "ふしのあたま",
        romaji: "fushinoatama",
        english: "Immortal Head",
        description: "Summons a head that orbits close to you and damages enemies",
        color: "#9932CC", // Deep purple color
        hoverColor: 0x7922BC,
        onAcquire: function () {
            window.activateImmortalHead();
        }
    },
    "IMMORTAL_LEG": {
        kanji: "不死の脚",
        kana: "ふしのあし",
        romaji: "fushinoashi",
        english: "Immortal Leg",
        description: "Summons a leg that orbits far from you and damages enemies",
        color: "#9932CC", // Deep purple color
        hoverColor: 0x7922BC,
        onAcquire: function () {
            window.activateImmortalLeg();
        }
    },
    "GOD_HAMMER": {
        kanji: "神の鎚",
        kana: "かみのつち",
        romaji: "kaminotsuchi",
        english: "God Hammer",
        description: "Periodically drops a divine hammer on enemies",
        color: "#FFD700",
        hoverColor: 0xDAA520,
        onAcquire: function () {
            // component added in hero.js
        }
    },
    "ETERNAL_RHYTHM": {
        kanji: "永遠の律動",
        kana: "えいえんのりつどう",
        romaji: "eiennoritsudou",
        english: "Eternal Rhythm",
        description: "While moving, gradually increases fire rate up to 2x",
        color: "#FFDD00",
        hoverColor: 0xDDBB00,
        onAcquire: function () {
            // The component is added by the PlayerPerkRegistry system
        }
    },
    "AMBER_NOVA": {
        kanji: "琥珀爆",
        kana: "こはくばく",
        romaji: "kohakubaku",
        english: "Amber Nova",
        description: "Projectiles explode on impact, damaging nearby enemies",
        color: "#FF9500", // Amber/orange color
        hoverColor: 0xDD7000,
        onAcquire: function () {
            // Logic is handled by the component system
        }
    },
    "TITAN_STOMP": {
        kanji: "巨踏",
        kana: "きょとう",
        romaji: "kyotou",
        english: "Titan Stomp",
        description: "Chance to create shockwaves around you when firing",
        color: "#8B4513", // Brown color
        hoverColor: 0x6B3503,
        onAcquire: function () {
            // The logic is handled by ProjectilePerkRegistry
        }
    },
    "AZURE_FROST": {
        kanji: "蒼霜",
        kana: "あおしも",
        romaji: "aoshimo",
        english: "Azure Frost",
        description: "Projectiles may slow enemies upon impact",
        color: "#00ffff", // Cyan color
        hoverColor: 0x00dddd,
        onAcquire: function () {
            // The SLOW_SHOT effect is already registered in ballistics.js
            // No additional implementation needed here
        }
    },
    "DIVINE_BEACON": {
        kanji: "天の標",
        kana: "てんのしるべ",
        romaji: "tennoshirube",
        english: "Divine Beacon",
        description: "Heavenly markers summon God Hammers when collected",
        color: "#FFD700",
        hoverColor: 0xDEB887,
        onAcquire: function () {
            // The component is added through PlayerPerkRegistry
        }
    }
};

// Helper functions for the perk system
const PerkSystem = {
    // Get all available perks
    getAllPerks: function () {
        return Object.keys(PERKS).map(key => ({
            id: key,
            ...PERKS[key]
        }));
    },

    // Get perks by category
    getPerksByCategory: function (category) {
        return Object.keys(PERKS)
            .filter(key => PERKS[key].category === category)
            .map(key => ({
                id: key,
                ...PERKS[key]
            }));
    },

    // Get a single perk by ID
    getPerkById: function (perkId) {
        if (!PERKS[perkId]) return null;
        return {
            id: perkId,
            ...PERKS[perkId]
        };
    },

    // Get random perks (avoiding duplicates)
    getRandomPerks: function (count, excludeIds = []) {
        const availablePerks = Object.keys(PERKS)
            .filter(key => !excludeIds.includes(key))
            .map(key => ({
                id: key,
                ...PERKS[key]
            }));

        // Shuffle the array
        for (let i = availablePerks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePerks[i], availablePerks[j]] = [availablePerks[j], availablePerks[i]];
        }

        return availablePerks.slice(0, count);
    },

    // Apply a perk to the game
    applyPerk: function (scene, perkId) {
        const perk = PERKS[perkId];
        if (!perk) return false;

        console.log("Applying perk:", perkId);

        // Call the onAcquire function
        perk.onAcquire();

        return true;
    }
};

// ======= playerhit.js =======
// playerhit.js - Player damage handling and visual effects

// Track whether player is currently invincible (to prevent multiple rapid hits)
let playerInvincible = false;
let playerInvincibilityDuration = 960;

// Visual effect elements
let damageVignette = null;

// Initialize the player hit system
function initPlayerHitSystem(scene) {
    // Cleanup any existing vignette elements
    cleanupDamageEffects();

    // Create the vignette container (invisible by default)
    createDamageVignette(scene);

    console.log("Player hit system initialized");
}

// Create the blood vignette effect (initially invisible)
function createDamageVignette(scene) {
    // Create a container for all vignette elements
    damageVignette = scene.add.container(0, 0);
    damageVignette.setDepth(900); // High depth to appear over game but under UI
    damageVignette.setAlpha(0); // Start invisible

    // Get screen dimensions from config
    const screenWidth = game.config.width; // 1200
    const screenHeight = game.config.height; // 800

    // Create more rectangles for a smoother gradient
    const totalBands = 10; // Keeping the same number of bands

    // Create bands with smooth alpha transition
    for (let i = 0; i < totalBands; i++) {
        // Calculate percentage of edge (0.05 to 0.4 - from 5% to 40% of the screen)
        const percent = (0.20 * i / (totalBands - 1));

        // Calculate alpha (0.6 for outermost to 0.01 for innermost)
        const alpha = 0.5 * (1 - (i / totalBands));

        const thickness = percent * Math.min(screenWidth, screenHeight) / 2;
        const bandThickness = (0.35 / totalBands) * Math.min(screenWidth, screenHeight) / 2;

        // Top edge - FULL WIDTH
        const topRect = scene.add.rectangle(
            screenWidth / 2, thickness - bandThickness / 2,
            screenWidth,
            bandThickness,
            0xff0000, alpha
        );
        topRect.setOrigin(0.5, 0.5);
        damageVignette.add(topRect);

        // Bottom edge - FULL WIDTH
        const bottomRect = scene.add.rectangle(
            screenWidth / 2, screenHeight - (thickness - bandThickness / 2),
            screenWidth,
            bandThickness,
            0xff0000, alpha
        );
        bottomRect.setOrigin(0.5, 0.5);
        damageVignette.add(bottomRect);

        // Left edge - FULL HEIGHT
        const leftRect = scene.add.rectangle(
            thickness - bandThickness / 2, screenHeight / 2,
            bandThickness,
            screenHeight, // Full height now
            0xff0000, alpha
        );
        leftRect.setOrigin(0.5, 0.5);
        damageVignette.add(leftRect);

        // Right edge - FULL HEIGHT
        const rightRect = scene.add.rectangle(
            screenWidth - (thickness - bandThickness / 2), screenHeight / 2,
            bandThickness,
            screenHeight, // Full height now
            0xff0000, alpha
        );
        rightRect.setOrigin(0.5, 0.5);
        damageVignette.add(rightRect);
    }

    // Register for cleanup
    window.registerEffect('entity', damageVignette);
}

// Show damage vignette with animation - keeping the same timing logic
function showDamageVignette(scene, intensity = 1.0) {
    if (!damageVignette) {
        createDamageVignette(scene);
    }

    // Cancel any existing tween
    if (damageVignette.fadeTween) {
        damageVignette.fadeTween.stop();
    }

    // Immediately set alpha based on intensity
    damageVignette.setAlpha(0.9 * intensity);

    // Create fade-out animation that matches invincibility duration
    damageVignette.fadeTween = scene.tweens.add({
        targets: damageVignette,
        alpha: 0,
        duration: playerInvincibilityDuration * 0.95, // Slightly shorter than invincibility for safety
        ease: 'Sine.easeOut',
        onComplete: function () {
            // Ensure we're completely invisible
            damageVignette.setAlpha(0);
        }
    });
}

// Clean up visual effects
function cleanupDamageEffects() {
    if (damageVignette) {
        // Stop any running tweens
        if (damageVignette.fadeTween) {
            damageVignette.fadeTween.stop();
            damageVignette.fadeTween = null;
        }

        // Destroy the container and all children
        if (damageVignette.destroy) {
            damageVignette.destroy();
        }
        damageVignette = null;
    }
}

// Main function called when player is hit by an enemy
function playerIsHit(player, enemy) {
    const scene = this;

    // Check if player is already invincible from a recent hit
    if (playerInvincible) return;

    // Make the player invincible to damage while flashing
    playerInvincible = true;

    // Flash the player when hit (visual feedback)
    scene.tweens.add({
        targets: player,
        alpha: 0.5,
        scale: 1.2,
        duration: playerInvincibilityDuration / 6,
        yoyo: true,
        repeat: 6,
        onComplete: function () {
            // Ensure alpha and scale are reset properly
            player.alpha = 1;
            player.scale = 1;
        }
    });

    // Remove invincibility after a while
    scene.time.delayedCall(playerInvincibilityDuration, function () {
        playerInvincible = false;

        // Double-check alpha is reset even if tween was interrupted
        if (player.active) {
            player.alpha = 1;
            player.scale = 1;
        }
    });

    // Handle hit effects including shield check
    // If hit was absorbed by shield, skip damage application
    if (window.handlePlayerHit(scene, enemy)) {
        return;
    }

    // Apply damage to player
    const damageAmount = enemy.damage ?? 1;
    playerHealth -= damageAmount;

    // Show damage vignette effect
    showDamageVignette(scene, 1);

    // Update health text and bar
    window.GameUI.updateHealthBar(scene);

    // Check if player is dead
    if (playerHealth < 1) {
        // Pass the enemy that killed the player to playerDeath
        playerDeath.call(scene, enemy);
    }
}

// Handle player death
function playerDeath(killerEnemy) {
    // Set game over state
    gameOver = true;

    // Pause the game physics to stop all movement
    PauseSystem.pauseGame();

    // Resume music to normal if we were in boss mode
    MusicSystem.removeBossFightEffect();

    // Get the scene
    const scene = this;

    // Get the kanji of the enemy that killed the player
    const enemyKanji = killerEnemy ? killerEnemy.text : null;

    // Show game over screen with the enemy kanji
    window.GameEndMenu.showDefeatScreen(scene, enemyKanji);

    // Old code - legacy support for direct DOM elements
    // This can be removed once the new GameEndMenu is fully integrated
    if (typeof gameOverText !== 'undefined' && gameOverText.setVisible) {
        gameOverText.setVisible(false);
    }
    if (typeof restartButton !== 'undefined' && restartButton.setVisible) {
        restartButton.setVisible(false);
    }
}


// Reset the player hit system (call during game restart)
function resetPlayerHitSystem() {
    playerInvincible = false;
    cleanupDamageEffects();
}

// Export API
window.PlayerHitSystem = {
    init: initPlayerHitSystem,
    playerIsHit: playerIsHit,
    playerDeath: playerDeath,
    reset: resetPlayerHitSystem
};

// ======= score.js =======
// score.js - Score calculation and animation system for Word Survivors
// Handles score calculation and animated display on game end screens

// Score System namespace
const ScoreSystem = {
    // Calculate final score based on game outcome (victory or defeat)
    calculateScore: function (isVictory) {
        // Get boss spawn time from global configuration
        const bossSpawnTime = rankEnemyStartTimes[BOSS_CONFIG.max_rank] || 1200; // Default to 20 minutes (1200 seconds)
        const maximumScoreTime = bossSpawnTime * 2; // Cap at twice the boss spawn time

        let finalScore;

        if (isVictory) {
            // For victory:
            // 1. Calculate maximum possible points (time-capped score * 3)
            const maximumPoints = maximumScoreTime * 3;

            // 2. Subtract 1 point for each second on the timer (faster = better)
            // But ensure we don't go below 2x the maximum death score
            const timeDeduction = Math.min(elapsedTime - bossSpawnTime, maximumScoreTime);

            finalScore = Math.floor(maximumPoints - timeDeduction);
        } else {
            // For defeat: 1 point per second survived, capped at twice boss spawn time
            const cappedTime = Math.min(elapsedTime, maximumScoreTime);
            finalScore = Math.floor(cappedTime);
        }

        // Debug log the calculation
        console.log(
            "Score calculation:",
            isVictory ? "Victory" : "Defeat",
            "Boss spawn time:", bossSpawnTime,
            "Maximum score time:", maximumScoreTime,
            "Elapsed time:", elapsedTime,
            "Final score:", finalScore
        );

        return finalScore;
    },

    // Animate the score with a counting effect where digits animate at different speeds
    animateScoreReveal: function (scene, statsText, finalScore) {
        if (!scene || !statsText) {
            console.error("Missing scene or statsText in animateScoreReveal");
            return;
        }

        // Ensure we have a valid score to animate to
        if (typeof finalScore !== 'number' || isNaN(finalScore)) {
            console.error("Invalid finalScore:", finalScore);
            finalScore = 0;
        }

        console.log("Starting score animation with finalScore:", finalScore);

        // Store original text info
        const originalText = statsText.text;
        const originalX = statsText.x;
        const originalY = statsText.y;
        const originalDepth = statsText.depth || 0;
        const originalContainer = statsText.parentContainer;

        // Parse the text to get the two segments (survived/in time and defeated/freed count)
        const textParts = originalText.split(/\s{2,}/); // Split on multiple spaces
        if (textParts.length !== 2) {
            console.error("Stats text doesn't have expected format:", originalText);
            return;
        }

        // Create two separate text objects for the stats (time and kills)
        const leftSegment = scene.add.text(
            originalX - 150, // Position left of center
            originalY,
            textParts[0],
            {
                fontFamily: 'Arial',
                fontSize: statsText.style.fontSize,
                color: '#FFD700' // Gold color
            }
        ).setOrigin(0.5);

        const rightSegment = scene.add.text(
            originalX + 150, // Position right of center
            originalY,
            textParts[1],
            {
                fontFamily: 'Arial',
                fontSize: statsText.style.fontSize,
                color: '#FFD700' // Gold color
            }
        ).setOrigin(0.5);

        // Set depth and add to container if needed
        leftSegment.setDepth(originalDepth);
        rightSegment.setDepth(originalDepth);

        if (originalContainer) {
            originalContainer.add(leftSegment);
            originalContainer.add(rightSegment);
        }

        // Hide the original text
        statsText.setVisible(false);

        // Store references to all created objects
        const createdObjects = [leftSegment, rightSegment];

        // Animate the two segments toward the center
        scene.tweens.add({
            targets: leftSegment,
            x: originalX,
            alpha: 0,
            duration: 1000,
            delay: 500 // Wait half a second before starting
        });

        scene.tweens.add({
            targets: rightSegment,
            x: originalX,
            alpha: 0,
            duration: 1000,
            delay: 500, // Wait half a second before starting
            onComplete: () => {
                // Both segments now merged and faded out
                console.log("Segments merged, creating score text");

                // Create score text with larger font
                const scoreText = scene.add.text(
                    originalX,
                    originalY,
                    "0", // Start with 0
                    {
                        fontFamily: 'Arial',
                        fontSize: parseInt(statsText.style.fontSize) * 2, // Twice as large
                        color: '#FFD700', // Gold color
                        fontStyle: 'bold'
                    }
                ).setOrigin(0.5).setAlpha(0);

                // Add to our cleanup array
                createdObjects.push(scoreText);

                // Set depth and add to container if needed
                scoreText.setDepth(originalDepth);
                if (originalContainer) {
                    originalContainer.add(scoreText);
                }

                // Fade in the score text
                scene.tweens.add({
                    targets: scoreText,
                    alpha: 1,
                    duration: 500,
                    onComplete: () => {
                        console.log("Score text fade-in complete, starting counter animation");

                        // Use a simple tween to count up from 0 to finalScore
                        this.animateScoreCounter(scene, scoreText, finalScore, createdObjects);
                    }
                });
            }
        });
    },

    // Add this property to track active animations:
    activeAnimation: null,

    // Add this helper method for showing final score with celebration effect:
    showFinalScore: function (scene, textObject, finalScore) {
        if (!scene || !textObject || textObject.active === false) return;

        // Set the final score immediately
        textObject.setText(finalScore.toString());

        // Add celebration effect (scaling pulse)
        scene.tweens.add({
            targets: textObject,
            scale: 1.2,
            duration: 200,
            yoyo: true
        });
    },

    // Method to skip directly to the end result
    skipToFinalScore: function (scene) {
        // If no active animation, do nothing
        if (!this.activeAnimation) {
            return false;
        }

        // Stop the active tween
        if (this.activeAnimation.tween) {
            this.activeAnimation.tween.stop();
        }

        // Show the final score with celebration
        this.showFinalScore(
            scene,
            this.activeAnimation.textObject,
            this.activeAnimation.finalScore
        );

        // Clear animation reference
        this.activeAnimation = null;

        return true;
    },

    // Simplified animateScoreCounter that uses the shared showFinalScore method
    animateScoreCounter: function (scene, textObject, finalScore, createdObjects) {
        if (!scene || !textObject) {
            console.error("Missing scene or textObject in animateScoreCounter");
            return;
        }

        // Round finalScore to an integer
        finalScore = Math.floor(finalScore);
        console.log("Starting counter animation to:", finalScore);

        // Create counter object and configure animation
        const counter = { value: 0 };
        const duration = Math.min(2000, 1000 + finalScore * 10);

        // Create the tween
        const scoreTween = scene.tweens.add({
            targets: counter,
            value: finalScore,
            duration: duration,
            ease: 'Linear',
            onUpdate: function () {
                // Only update if the text object is still valid
                if (textObject && textObject.active !== false) {
                    const currentValue = Math.floor(counter.value);
                    textObject.setText(currentValue.toString());
                }
            },
            onComplete: () => {
                console.log("Counter animation complete!");

                // Clear the active animation reference
                this.activeAnimation = null;

                // Show final score with celebration effect
                this.showFinalScore(scene, textObject, finalScore);
            }
        });

        // Store animation details for potential skipping
        this.activeAnimation = {
            tween: scoreTween,
            textObject: textObject,
            finalScore: finalScore
        };

        return scoreTween;
    },

    // Cleanup method to destroy all created objects
    cleanup: function (createdObjects) {
        if (!createdObjects || !Array.isArray(createdObjects)) return;

        createdObjects.forEach(obj => {
            if (obj && obj.destroy) {
                obj.destroy();
            }
        });
    }
};

// Export the score system for use in other files
window.ScoreSystem = ScoreSystem;

// ======= visuals.js =======
// visuals.js - Simple visual effects for Word Survivors
// Provides reusable visual effects to reduce code duplication

// Define a namespace for all visual effects
const VisualEffects = {
    // Create an explosion/pulse visual effect
    createExplosion: function (scene, x, y, radius, color = 0xFFFF00, options = {}) {
        // Default options
        const duration = options.duration ?? 1000;
        const startScale = options.startScale ?? 0.01;
        const strokeWidth = options.strokeWidth ?? 4;
        const alpha = options.alpha ?? 1;

        // Create the pulse circle with no fill by default
        const pulse = scene.add.circle(x, y, radius * 1, color, 0);

        // Set a stroke (outline) instead of a fill
        pulse.setStrokeStyle(strokeWidth, color, alpha);

        // Start with a very small scale
        pulse.setScale(startScale);

        // Animate from small to full size with fade-out
        scene.tweens.add({
            targets: pulse,
            scale: 1, // Expand to exactly the intended radius
            alpha: 0, // Fade out as it reaches full size
            duration: duration,
            ease: 'Power2', // Physics feel to the expansion
            onComplete: function () {
                pulse.destroy();
            }
        });

        // Return the pulse object for further customization if needed
        return pulse;
    },

    // Create a pulsing animation effect (for beacons, items, etc.)
    createPulsing: function (scene, target, options = {}) {
        // Default options
        const scaleFrom = options.scaleFrom ?? 0.9;
        const scaleTo = options.scaleTo ?? 1.1;
        const duration = options.duration ?? 1000;
        const yoyo = options.yoyo ?? true;
        const repeat = options.repeat ?? -1; // -1 means infinite loop
        const ease = options.ease ?? 'Sine.InOut';
        const delay = options.delay ?? 0;

        // Create the tween
        const tween = scene.tweens.add({
            targets: target,
            scale: { from: scaleFrom, to: scaleTo },
            duration: duration,
            yoyo: yoyo,
            repeat: repeat,
            ease: ease,
            delay: delay
        });

        // Return the tween in case the caller wants to modify it
        return tween;
    },

    createDamageFlash: function (scene, entity) {
        if (!entity || !entity.active) return;

        // Store original alpha if not already stored
        if (entity.originalAlpha === undefined) {
            entity.originalAlpha = entity.alpha;
        }

        // If there's already a damage animation in progress, stop it and reset alpha
        if (entity.damageAnimation && !entity.damageAnimation.isDestroyed) {
            entity.damageAnimation.stop();
            // Important: Reset alpha before starting new animation
            entity.alpha = entity.originalAlpha;
        }

        // Create a flash animation
        entity.damageAnimation = scene.tweens.add({
            targets: entity,
            alpha: { from: entity.originalAlpha, to: 0.3 },
            duration: 100,  // Faster fade-out
            yoyo: true,    // Return to original
            repeat: 1,     // Single blink
            onComplete: function () {
                // Ensure alpha is reset properly
                if (entity.active && !entity.alphaControlledByEffect) {
                    entity.alpha = entity.originalAlpha;
                }
                entity.damageAnimation = null;
            },
            onStop: function () {
                // Also handle alpha reset if animation is stopped prematurely
                if (entity.active && !entity.alphaControlledByEffect) {
                    entity.alpha = entity.originalAlpha;
                }
            }
        });

        return entity.damageAnimation;
    },

    // Add this to the VisualEffects object in visuals.js
    createLightningFlash: function (scene, x, y, options = {}) {
        // Default options
        const radius = options.radius ?? 48;  // 96px circle by default
        const color = options.color ?? 0xFFFF66; // Yellow-white color
        const alpha = options.alpha ?? 0.5;
        const duration = options.duration ?? 1000;

        // Create flash effect as a circle
        const flash = scene.add.circle(x, y, radius, color, alpha);

        // Animate fade-out with expansion
        scene.tweens.add({
            targets: flash,
            alpha: 0,
            radius: radius * 1.5, // Expand slightly
            duration: duration,
            onComplete: function () {
                flash.destroy();
            }
        });

        return flash;
    },

    // Add this to the VisualEffects object in visuals.js
    createLightningStrike: function (scene, x, y, options = {}) {
        // Default options
        const damage = options.damage ?? playerDamage;
        const color = options.color ?? '#FFDD00';
        const size = options.size ?? 32;
        const symbol = options.symbol ?? '雷';

        // Create the lightning bolt starting above the target
        const lightning = scene.add.text(x, y - 300, symbol, {
            fontFamily: 'Arial',
            fontSize: `${size}px`,
            color: color,
            fontStyle: 'bold'
        }).setOrigin(0.5);

        // Add falling animation
        scene.tweens.add({
            targets: lightning,
            y: y,
            duration: 500,
            ease: 'Bounce.easeOut',
            onComplete: function () {
                // Create flash effect on impact
                VisualEffects.createLightningFlash(scene, x, y);

                // Create the actual dropper
                const dropConfig = {
                    symbol: symbol,
                    color: color,
                    fontSize: size,
                    x: x,
                    y: y,
                    behaviorType: 'persistent',
                    damage: damage,
                    damageInterval: 1000,
                    lifespan: 1000
                };

                DropperSystem.create(scene, dropConfig);

                // Remove the falling lightning
                lightning.destroy();
            }
        });

        return lightning;
    },

    convertToColorValue: function (color) {
        // If it's already a number, return it directly
        if (typeof color === 'number') {
            return color;
        }

        // If it's a string in hex format (e.g., '#FF0000' or 'FF0000')
        if (typeof color === 'string') {
            // Remove # prefix if present
            const hex = color.startsWith('#') ? color.substring(1) : color;
            // Convert hex string to number
            return parseInt(hex, 16);
        }

        // Default to white if conversion fails
        return 0xFFFFFF;
    }

    // Additional visual effects can be added here
};

// Export the entire namespace to window
window.VisualEffects = VisualEffects;

// ======= weapons.js =======
// Updated weapons.js with consolidated collision handling

const WeaponSystem = {
    // Currently active weapon type
    activeWeaponType: 'BASIC_PROJECTILE',

    // Firing timer reference
    weaponTimer: null,

    // Physics groups
    projectilesGroup: null,
    piercingProjectilesGroup: null,

    // Initialize the system
    initialize: function (scene) {
        console.log("Initializing weapon system");

        // Create physics groups
        this.initPhysicsGroups(scene);

        // Create the firing timer
        this.createWeaponTimer(scene);

        return this;
    },

    // Initialize physics groups
    initPhysicsGroups: function (scene) {
        // Create regular projectiles group (instead of using global projectiles)
        this.projectilesGroup = scene.physics.add.group();

        // Create piercing projectiles group
        this.piercingProjectilesGroup = scene.physics.add.group();

        // Make global references available for backward compatibility
        window.projectiles = this.projectilesGroup;
        window.piercingProjectiles = this.piercingProjectilesGroup;

        // Set up collisions for regular projectiles
        scene.physics.add.collider(
            this.projectilesGroup,
            EnemySystem.enemiesGroup,
            this.projectileHitEnemy,
            null,
            scene
        );

        // Set up overlap for piercing projectiles
        scene.physics.add.overlap(
            this.piercingProjectilesGroup,
            EnemySystem.enemiesGroup,
            this.projectileHitEnemy,
            null,
            scene
        );
    },

    // Handle projectile collision with enemy
    projectileHitEnemy: function (projectile, enemy) {
        // "this" is the scene due to the function context in physics.add.collider
        const scene = this;

        // Skip if projectile is already destroyed
        if (!projectile.active || !enemy.active) return;

        // Ensure projectile has a damage source ID
        if (!projectile.damageSourceId) {
            projectile.damageSourceId = `proj_${Date.now()}_${Math.random()}`;
        }

        // Process hit event for all components
        if (projectile.components) {
            ProjectileComponentSystem.processEvent(projectile, 'onHit', enemy, scene);
        }

        // Apply damage using the contact damage system with a very short cooldown
        // (Regular projectiles are destroyed on hit, so cooldown is mostly irrelevant)
        applyContactDamage.call(scene, projectile, enemy, projectile.damage, 1000);

        // Destroy non-piercing projectiles after hit
        if (!projectile.piercing) {
            projectile.destroy();
        }
    },

    // Create the weapon firing timer
    createWeaponTimer: function (scene) {
        // Remove existing timer if any
        if (this.weaponTimer) {
            this.weaponTimer.remove();
        }

        // Calculate firing interval based on current stats
        const firingDelay = this.calculateFiringDelay();

        // Create timer for automatic firing
        this.weaponTimer = registerTimer(scene.time.addEvent({
            delay: firingDelay,
            callback: function () {
                if (gameOver || gamePaused) return;
                WeaponSystem.fireWeapon(this);
            },
            callbackScope: scene,
            loop: true
        }));

        console.log(`Weapon timer created with delay: ${firingDelay}ms`);
    },

    // Calculate firing delay based on player stats
    calculateFiringDelay: function () {
        return shootingDelay / getEffectiveFireRate();
    },

    // Update the firing rate when stats change
    updateFiringRate: function (scene) {
        if (!this.weaponTimer) return;

        // Calculate new delay
        const newDelay = this.calculateFiringDelay();

        // Only update if significant change (>10%)
        const currentDelay = this.weaponTimer.delay;
        if (Math.abs(currentDelay - newDelay) > (currentDelay * 0.1)) {
            // Remember elapsed time to preserve firing cycle
            const elapsed = this.weaponTimer.elapsed;
            const progress = elapsed / currentDelay;

            // Update timer with new delay
            this.weaponTimer.delay = newDelay;
            this.weaponTimer.reset({
                delay: newDelay,
                callback: function () {
                    if (gameOver || gamePaused) return;
                    WeaponSystem.fireWeapon(this);
                },
                callbackScope: scene,
                loop: true
            });

            // Restore progress to avoid reset
            this.weaponTimer.elapsed = progress * newDelay;

            console.log(`Firing rate updated: ${currentDelay}ms -> ${newDelay}ms`);
        }
    },

    updateProjectiles: function (scene) {
        // Process both regular and piercing projectiles
        this.updateProjectileGroup(this.projectilesGroup);
        this.updateProjectileGroup(this.piercingProjectilesGroup);
    },

    // Helper method to update a projectile group
    updateProjectileGroup: function (group) {
        if (!group) return;

        group.getChildren().forEach(projectile => {
            // Skip if destroyed during processing
            if (!projectile || !projectile.active) return;

            // Check if out of bounds
            if (projectile.y < -50 || projectile.y > game.config.height + 50 ||
                projectile.x < -50 || projectile.x > game.config.width + 50) {
                projectile.destroy();
                return;
            }

            // Process component updates
            if (projectile.components && Object.keys(projectile.components).length > 0) {
                if (projectile.components.boomerangEffect) {
                    console.log("Processing boomerang update"); // Debug log
                }
                ProjectileComponentSystem.processEvent(projectile, 'update');
            }
        });
    },

    // Fire the current weapon
    fireWeapon: function (scene) {
        // Find the closest enemy
        distance = (Math.sqrt(playerFireRate / BASE_STATS.AGI)) * 400;
        const closestEnemy = this.findClosestEnemy(scene, distance);

        if (closestEnemy) {
            // Calculate direction to the enemy
            const angle = Phaser.Math.Angle.Between(
                player.x, player.y,
                closestEnemy.x, closestEnemy.y
            );

            // Fire projectile based on active weapon type
            if (this.activeWeaponType === 'BASIC_PROJECTILE') {
                this.fireBasicProjectile(scene, angle);
            }
        }
    },

    // Fire a basic projectile
    fireBasicProjectile: function (scene, angle) {
        // Create the projectile
        const projectile = this.createProjectile(scene, {
            x: player.x,
            y: player.y,
            angle: angle
        });

        return projectile;
    },

    // Create a projectile with the appropriate properties
    createProjectile: function (scene, config) {
        const defaults = {
            x: player.x,
            y: player.y,
            symbol: '★',
            color: '#ffff00',
            angle: 0,
            speed: 400,
            damage: getEffectiveDamage(),
            fontSize: getEffectiveSize(), // Add fontSize with getEffectiveSize
            skipComponents: false
        };

        // Merge config with defaults
        const projConfig = { ...defaults, ...config };

        // Create the projectile text object
        const projectile = scene.add.text(
            projConfig.x,
            projConfig.y,
            projConfig.symbol,
            {
                fontFamily: 'Arial',
                fontSize: `${projConfig.fontSize}px`, // Use the calculated or provided fontSize
                color: projConfig.color,
                fontStyle: 'bold'
            }
        ).setOrigin(0.5);

        // Default to non-piercing
        projectile.piercing = false;

        // Initialize empty components object
        projectile.components = {};

        // Apply perk effects before adding to physics group
        if (!projConfig.skipComponents) {
            // Apply all registered perk effects
            ProjectilePerkRegistry.applyPerkEffects(projectile, scene);
        }

        // Add to the appropriate physics group based on piercing status
        if (projectile.piercing) {
            this.piercingProjectilesGroup.add(projectile);
        } else {
            this.projectilesGroup.add(projectile);
        }

        // NOW we can safely set physics body properties
        projectile.body.setSize(projectile.width / 2, projectile.height / 2);
        projectile.damage = projConfig.damage;

        // Set velocity based on angle
        projectile.body.setVelocity(
            Math.cos(projConfig.angle) * projConfig.speed,
            Math.sin(projConfig.angle) * projConfig.speed
        );

        // Process onFire event if needed
        if (projectile.needsOnFireEvent && projectile.components) {
            Object.values(projectile.components).forEach(component => {
                if (component.onFire) {
                    component.onFire(projectile, scene, projConfig.angle);
                }
            });
        }

        return projectile;
    },

    // Find the closest enemy within range
    findClosestEnemy: function (scene, maxDistance) {
        if (!EnemySystem.enemiesGroup || EnemySystem.enemiesGroup.getChildren().length === 0) {
            return null;
        }

        let closestEnemy = null;
        let closestDistance = maxDistance;

        EnemySystem.enemiesGroup.getChildren().forEach(enemy => {
            if (!enemy || !enemy.active) return;

            const distance = Phaser.Math.Distance.Between(
                player.x, player.y,
                enemy.x, enemy.y
            );

            if (distance < closestDistance) {
                closestDistance = distance;
                closestEnemy = enemy;
            }
        });

        return closestEnemy;
    },

    // Reset the weapon system
    reset: function (scene) {
        // Remove weapon timer
        if (this.weaponTimer) {
            this.weaponTimer.remove();
            this.weaponTimer = null;
        }

        // Clear the projectile groups
        if (this.projectilesGroup) {
            this.projectilesGroup.clear(true, true);
        }

        if (this.piercingProjectilesGroup) {
            this.piercingProjectilesGroup.clear(true, true);
        }

        // Reset to default weapon
        this.activeWeaponType = 'BASIC_PROJECTILE';

        console.log("Weapon system reset");
    }
};

// Export the weapon system
window.WeaponSystem = WeaponSystem;


</script><style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #game-container {
            width: 100%;
            /* Change from fixed 1200px to 100% */
            height: 100vh;
            /* Use viewport height instead of fixed 800px */
            position: relative;
            margin: 0 auto;
            max-width: 1200px;
            /* Optional: keep a maximum width */
            max-height: 800px;
            /* Optional: keep a maximum height */
        }

        @media (max-width: 768px) {
            body {
                padding: 0;
                margin: 0;
            }

            #game-container {
                width: 100%;
                height: 100vh;
                max-width: none;
                /* Allow full width on mobile */
                max-height: none;
                /* Allow full height on mobile */
            }

            /* Adjust border decorations for smaller screens */
            .border-decoration {
                display: none;
                /* Optional: hide decorations on small screens */
            }
        }

        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            z-index: 10;
            pointer-events: none;
            font-size: 14px;
        }

        /* Game border decorations */
        .border-decoration {
            position: absolute;
            background-color: transparent;
            border-style: solid;
            border-color: #FFD700;
            /* Golden color */
            z-index: 5;
        }

        /* Top-left L */
        #border-top-left {
            top: -8px;
            left: -8px;
            width: 200px;
            height: 100px;
            border-width: 8px 0 0 8px;
        }

        /* Top-right L */
        #border-top-right {
            top: -8px;
            right: -8px;
            width: 100px;
            height: 200px;
            border-width: 8px 8px 0 0;
        }

        /* Bottom-left L */
        #border-bottom-left {
            bottom: -8px;
            left: -8px;
            width: 100px;
            height: 200px;
            border-width: 0 0 8px 8px;
        }

        /* Bottom-right L */
        #border-bottom-right {
            bottom: -8px;
            right: -8px;
            width: 200px;
            height: 100px;
            border-width: 0 8px 8px 0;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <!-- L-shaped border decorations -->
        <div id="border-top-left" class="border-decoration"></div>
        <div id="border-top-right" class="border-decoration"></div>
        <div id="border-bottom-left" class="border-decoration"></div>
        <div id="border-bottom-right" class="border-decoration"></div>
    </div>

    <script>
        const KAJISULI_MODE = true;

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: KAJISULI_MODE ? 500 : 1200,
            height: KAJISULI_MODE ? 1000 : 800,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: KAJISULI_MODE ? 500 : 1200,
                height: KAJISULI_MODE ? 1000 : 800,
                parent: 'game-container',
                // This is important - it ensures the canvas actually resizes
                // when the browser window changes
                expandParent: false
            }
        };

        // Game variables
        let player;
        let cursors;
        let wasdKeys;
        let keyboardLayout = 'qwerty'; // Default to QWERTY

        // Global variables for pause system
        let pauseScreen = null;
        let resumeButton = null;
        let pauseMessage = null;
        let pauseKeyP = null;

        // Add these variables for stats tracking
        let statsText = null;
        let statsVisible = false;
        let debugModeEnabled = false;

        // Store all game timers in a central array
        let gameTimers = [];

        // Register a timer with the central system
        function registerTimer(timer) {
            if (timer && timer instanceof Phaser.Time.TimerEvent) {
                gameTimers.push(timer);
                // If game is currently paused, pause the new timer too
                if (gamePaused && timer.paused !== undefined) {
                    timer.paused = true;
                }
            }
            return timer; // Return the timer for convenience
        }

        // Clean up timers that are no longer active
        function cleanupTimers() {
            gameTimers = gameTimers.filter(timer =>
                timer && !timer.hasOwnProperty('removed') && !timer.removed);
        }

        let activeEffects = {
            timers: [],         // Store all active timers
            entities: [],       // Store all entities created by perks 
            activePerks: []     // Store all acquired perks
        };

        // Initial player stats
        let basePlayerSpeed = 8;
        let baseProcChance = 0.2;
        let baseShootingDelay = 2000;
        let baseHeroExpToLevel = 5;
        let acquiredPerks = [];
        let playerHealth = BASE_STATS.END;
        let maxPlayerHealth = BASE_STATS.END;
        let playerSpeed = basePlayerSpeed;
        let playerDamage = BASE_STATS.POW;
        let playerLuck = BASE_STATS.LUK;
        let shootingDelay = baseShootingDelay; // ms between shots
        let playerFireRate = BASE_STATS.AGI; // Multiplier for shooting rate
        let projectileSizeFactor = 4; // Multiply player damage by this to get proj size
        let berserkMultiplier = 1.0;
        let archerMultiplier = 1.0;
        let score = 0;
        let level = 1;
        let touchInput = { x: 0, y: 0, isActive: false };
        let gameOver = false;
        let gameOverText;
        let restartButton;

        // Track elapsed time
        let elapsedTime = 0; // in seconds

        // Hero experience system
        let playerLevel = 1;
        let heroExp = 0;
        let levelUpCards = [];
        let gamePaused = false;
        let levelUpInProgress = false;

        // Perk system variables
        let playerPerks = {};
        let shieldVisual = null;
        let healthRegenTimer = null;

        // Format time to hh:mm:ss
        function formatTime(seconds) {
            if (seconds < 3600) {
                // Under 1 hour, use mm:ss format
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                // Over 1 hour, use hh:mm format (no seconds)
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
        }

        // Helper function to calculate XP needed for next level
        function xpForNextLevel(heroLevel) {
            return Math.ceil(baseHeroExpToLevel * Math.pow(1.2, heroLevel - 1));
        }

        // Effective Damage
        function getEffectiveDamage() {
            return playerDamage * berserkMultiplier;
        }

        // Function to calculate the effective fire rate
        function getEffectiveFireRate() {
            return playerFireRate * archerMultiplier;
        }

        // Calculate effective projectile size based on damage
        function getEffectiveSize(baseFontSize, damageValue) {
            // If no base size provided, use the global projectileSizeFactor
            const baseSize = baseFontSize ?? projectileSizeFactor;

            // Use provided damage or default to getEffectiveDamage()
            const damage = damageValue ?? getEffectiveDamage();

            // Get the scaling factor using square root approach
            const scalingFactor = Math.sqrt(damage / BASE_STATS.POW);

            // Apply scaling to base size with the multiplier of 4
            return baseSize * scalingFactor * 4;
        }

        // Proc chance
        function calculateProcChance(luck, baseChance) {
            return baseChance * Math.sqrt(luck / BASE_STATS.LUK);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Add this helper function to register effects
        window.registerEffect = function (type, item) {
            if (type === 'timer' && item) {
                activeEffects.timers.push(item);
                // If game is paused, also pause the new timer
                if (gamePaused && item.paused !== undefined) {
                    item.paused = true;
                }
            } else if (type === 'entity' && item) {
                activeEffects.entities.push(item);
            }
        };

        // Perk system helper functions
        function initializePerks() {
            playerPerks = {};
        }

        // Update the acquirePerk function to register perks
        function acquirePerk(scene, perkId) {
            // Skip if already acquired
            if (acquiredPerks.includes(perkId)) return false;

            // Add to acquired perks list
            acquiredPerks.push(perkId);
            activeEffects.activePerks.push(perkId);

            // Apply the perk
            return PerkSystem.applyPerk(scene, perkId);
        }

        // Add this cleanup function to your startGame function
        function clearAllPerkEffects() {
            // Clear all timers
            activeEffects.timers.forEach(timer => {
                if (timer) {
                    timer.remove();
                }
            });

            // Clear all entities
            activeEffects.entities.forEach(entity => {
                if (entity && entity.active) {
                    entity.destroy();
                }
            });

            // Reset active effects
            activeEffects.timers = [];
            activeEffects.entities = [];
            activeEffects.activePerks = [];

            // Make sure time flows
            window.TimeDilationSystem.cleanup();
        }

        function resetAllPerks() {
            // Call onReset for all perks that were acquired
            for (const perkId in playerPerks) {
                if (perkRegistry[perkId] && perkRegistry[perkId].onReset) {
                    perkRegistry[perkId].onReset();
                }
            }
            // Reset the perks object
            playerPerks = {};
        }

        function hasPerk(perkId) {
            return acquiredPerks.includes(perkId);
        }

        // Create the game instance
        const game = new Phaser.Game(config);

        function preload() {
            // No image assets to preload
        }

        function create() {
            // Listen for the Phaser-specific resize event which is more reliable
            this.scale.on('resize', (gameSize, baseSize, displaySize, resolution) => {
                console.log(`Game resized: ${displaySize.width}x${displaySize.height}`);

                // Update UI with the new dimensions
                setTimeout(() => {
                    // Get the active scene
                    const activeScene = this;
                    if (activeScene) {
                        // Refresh the UI with the new dimensions
                        GameUI.resize(activeScene);
                    }
                }, 100);
            });

            // Initialize perk system first
            initializePerks();

            // Record game start time for difficulty scaling
            gameStartTime = this.time.now;

            // Detect keyboard layout
            detectKeyboardLayout.call(this);

            // Initialize our new systems
            RomajiChallengeSystem.init(this);
            PauseSystem.init(this);
            DebugSystem.init(this);
            LifeSystem.initialize(this);
            WeaponSystem.initialize(this);
            PlayerHitSystem.init(this);
            InputSystem.setupCursorHiding(this);
            BackgroundAnimationSystem.init(this);

            // Initialize music system
            if (window.MusicSystem) {
                MusicSystem.initialize(this);
                MusicSystem.preload(this);

                // Create music tracks once preload is complete
                this.load.once('complete', function () {
                    MusicSystem.create(this);
                    MusicSystem.start();
                }, this);

                // Start loading
                this.load.start();
            }

            // Create player text - using kanji character
            player = this.add.text(game.config.width / 2, game.config.height / 2, HERO_CHARACTER, {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ffffff',
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(50);

            // Store all language and educational properties
            player.kana = HERO_KANA;
            player.romaji = HERO_ROMAJI;
            player.english = HERO_ENGLISH;

            // Add physics to player
            this.physics.world.enable(player);
            player.body.setCollideWorldBounds(true);

            GameUI.createUI(this);
            OrbitalSystem.init();

            // Create shield visual (initially invisible)
            shieldVisual = this.add.circle(player.x, player.y, 30, 0x3498db, 0.4);
            shieldVisual.setStrokeStyle(3, 0x0088ff);
            shieldVisual.setVisible(false);

            // Add health regeneration
            LifeSystem.setupHealthRegeneration(this);

            // Create enemy group
            EnemySystem.initialize(this);

            // Create projectile group
            projectiles = this.physics.add.group();

            // Set up collision between player and EnemySystem.enemiesGroup
            this.physics.add.overlap(player, EnemySystem.enemiesGroup, PlayerHitSystem.playerIsHit, null, this);

            // Set up cursor keys for movement
            cursors = this.input.keyboard.createCursorKeys();

            // Set up WASD keys for movement based on detected layout
            updateWASDKeys.call(this);

            // Set up touch controls
            this.input.on('pointerdown', (pointer) => {
                touchInput.isActive = true;
                touchInput.x = pointer.x;
                touchInput.y = pointer.y;
            });

            this.input.on('pointermove', (pointer) => {
                if (touchInput.isActive) {
                    touchInput.x = pointer.x;
                    touchInput.y = pointer.y;
                }
            });

            this.input.on('pointerup', () => {
                touchInput.isActive = false;
            });

            // Create the game over screen (hidden initially)
            gameOverText = this.add.text(game.config.width / 2, game.config.height / 2,
                'GAME OVER',
                { fontFamily: 'Arial', fontSize: '40px', color: '#ff0000', fontStyle: 'bold' }
            ).setOrigin(0.5).setVisible(false);

            // Create restart button (hidden initially)
            restartButton = this.add.text(game.config.width / 2, game.config.height * 0.75,
                'PLAY AGAIN',
                { fontFamily: 'Arial', fontSize: '24px', color: '#ffffff', backgroundColor: '#880000', padding: { left: 15, right: 15, top: 10, bottom: 10 } }
            ).setOrigin(0.5).setVisible(false).setInteractive();

            // Add restart button functionality
            restartButton.on('pointerdown', startGame, this);

            // Create learning feedback text (initially empty)
            this.learningFeedback = this.add.text(game.config.width / 2, game.config.height * 0.9625, '', {
                fontFamily: 'Arial',
                fontSize: '32px',
                color: '#ffffff',
                stroke: '#000000', // Add stroke for better readability with different colors
                strokeThickness: 2,
                align: 'center'
            }
            ).setOrigin(0.5).setDepth(100); // Ensure it displays above other elements

            // Start the game by calling startGame (replaces the need for duplicate initialization)
            startGame.call(this);
        }

        // Add this to your update function
        function update(time, delta) {
            if (gameOver) return;
            if (gamePaused) return; // Skip updates when game is paused for level up

            if (window.BackgroundAnimationSystem && BackgroundAnimationSystem.isInitialized) {
                BackgroundAnimationSystem.update(time, delta);
            }

            DebugSystem.updatePerformanceStats(this, time, delta);
            updatePlayerStatus();
            updateOnHitEffects();

            // Increment elapsed time
            elapsedTime += (delta / 1000) * this.time.timeScale;

            // Update weapon firing rate if needed
            WeaponSystem.updateFiringRate(this);
            WeaponSystem.updateProjectiles(this);

            // Update the level display to show time survived
            GameUI.updateStatusDisplay(this, elapsedTime, score);

            // Player movement with keyboard
            player.body.setVelocity(0);

            if (cursors.left.isDown || wasdKeys.left.isDown) {
                player.body.setVelocityX(-playerSpeed * 50);
            } else if (cursors.right.isDown || wasdKeys.right.isDown) {
                player.body.setVelocityX(playerSpeed * 50);
            }

            if (cursors.up.isDown || wasdKeys.up.isDown) {
                player.body.setVelocityY(-playerSpeed * 50);
            } else if (cursors.down.isDown || wasdKeys.down.isDown) {
                player.body.setVelocityY(playerSpeed * 50);
            }

            // Player movement with touch
            if (touchInput.isActive) {
                // Calculate direction vector
                const dx = touchInput.x - player.x;
                const dy = touchInput.y - player.y;

                // Normalize and scale
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) {  // Add a small threshold to prevent jitter
                    player.body.setVelocityX((dx / distance) * playerSpeed * 50);
                    player.body.setVelocityY((dy / distance) * playerSpeed * 50);
                }
            }

            // Update enemies
            EnemySystem.updateEnemies();

            // Update enemy spawners
            EnemySystem.updateEnemySpawners();

            // Keep shield visual positioned on player
            if (shieldVisual) {
                shieldVisual.x = player.x;
                shieldVisual.y = player.y;
            }


            // Updated projectile processing
            projectiles.getChildren().forEach(projectile => {
                // Check if out of bounds
                if (projectile.y < -50 || projectile.y > game.config.height + 50 ||
                    projectile.x < -50 || projectile.x > game.config.width + 50) {
                    projectile.destroy();
                    return;
                }

                // Process component updates
                if (projectile.components && Object.keys(projectile.components).length > 0) {
                    ProjectileComponentSystem.processEvent(projectile, 'update');
                }
            });

            // Update health bar
            GameUI.updateHealthBar(this);
            GameUI.updateExpBar(this);


            // Update orbitals
            OrbitalSystem.update(this, time);
            DropperSystem.update(this, time);

            if (window.MusicSystem) {
                MusicSystem.update(time, delta);
            }

            // Calculate difficulty scaling based on elapsed time instead of raw time
            const minutesElapsed = elapsedTime / 60;

            // Update player stats text
            GameUI.updateStatCircles(this);

            // Update player level
            if (heroExp >= xpForNextLevel(playerLevel)) {
                levelUp.call(this);
            }
        }

        function levelUp() {
            // Calculate excess XP
            const excessXP = heroExp - xpForNextLevel(playerLevel);

            // Increase player level
            playerLevel++;

            // Set XP to excess amount (instead of resetting to 0)
            heroExp = Math.max(0, excessXP);

            // Update the XP bar with new values
            GameUI.updateExpBar(this);

            CardSystem.showLevelUpScreen(this);
        }

        function detectKeyboardLayout() {
            // Check if we're running locally
            const isLocalEnvironment =
                window.location.hostname === 'localhost' ||
                window.location.hostname === '127.0.0.1' ||
                window.location.protocol === 'file:'; // For direct file access

            // Default to AZERTY for local development, QWERTY otherwise
            keyboardLayout = isLocalEnvironment ? 'azerty' : 'qwerty';

            console.log(`Keyboard layout set to ${keyboardLayout} (${isLocalEnvironment ? 'local environment' : 'remote environment'})`);

            // Try the API detection if we're in a secure context and not local
            if (window.isSecureContext && !isLocalEnvironment && navigator.keyboard && navigator.keyboard.getLayoutMap) {
                navigator.keyboard.getLayoutMap()
                    .then(keyboardLayoutMap => {
                        const qKey = keyboardLayoutMap.get('KeyQ');
                        if (qKey === 'a' || qKey === 'A') {
                            keyboardLayout = 'azerty';
                            updateWASDKeys.call(this);
                            console.log("AZERTY keyboard detected via API");
                        }
                    })
                    .catch(error => {
                        console.log('Error in keyboard API detection:', error);
                    });
            }

            // Update keys based on our determined layout
            updateWASDKeys.call(this);

            // Always add a keyboard shortcut to toggle layout if needed
            this.input.keyboard.once('keydown-L', function () {
                keyboardLayout = keyboardLayout === 'qwerty' ? 'azerty' : 'qwerty';
                updateWASDKeys.call(this);

                // Show confirmation
                const confirmation = this.add.text(
                    game.config.width / 2,
                    game.config.height / 2,
                    `Switched to ${keyboardLayout.toUpperCase()} layout`,
                    {
                        fontFamily: 'Arial',
                        fontSize: '24px',
                        color: '#ffffff',
                        backgroundColor: '#333333',
                        padding: { x: 10, y: 5 }
                    }
                ).setOrigin(0.5).setDepth(1000);

                // Fade out
                this.tweens.add({
                    targets: confirmation,
                    alpha: 0,
                    y: confirmation.y - 30,
                    duration: 2000,
                    onComplete: function () { confirmation.destroy(); }
                });

                // Add another listener for additional toggles
                this.input.keyboard.once('keydown-L', arguments.callee, this);
            }, this);
        }

        function updateWASDKeys() {
            // Update keys based on detected layout
            if (keyboardLayout === 'azerty') {
                // AZERTY layout uses ZQSD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.Z,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.Q,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            } else {
                // QWERTY layout uses WASD for movement
                wasdKeys = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.W,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.A,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
            }
        }

        // Updated modifyStat function that handles negative values
        window.modifyStat = function (statName, amount) {
            const scene = game.scene.scenes[0];
            if (!scene) return;

            switch (statName) {
                case 'damage':
                    playerDamage += amount;
                    // Ensure damage doesn't go below 1
                    playerDamage = Math.max(1, playerDamage);
                    break;
                case 'speed':
                    playerSpeed += amount;
                    // Ensure speed doesn't go below 1
                    playerSpeed = Math.max(1, playerSpeed);
                    break;
                case 'health':
                    maxPlayerHealth += amount;
                    // Ensure maxHealth doesn't go below 1
                    maxPlayerHealth = Math.max(1, maxPlayerHealth);
                    // If reducing max health, also cap current health
                    if (amount < 0 && playerHealth > maxPlayerHealth) {
                        playerHealth = maxPlayerHealth;
                    } else if (amount > 0) {
                        // If increasing max health, also increase current health
                        playerHealth += amount;
                    }
                    LifeSystem.setupHealthRegeneration(scene);
                    break;
                case 'luck':
                    playerLuck += amount;
                    // Ensure luck doesn't go below 1
                    playerLuck = Math.max(1, playerLuck);
                    break;
                case 'fireRate':
                    playerFireRate += amount;

                    // Ensure fire rate doesn't go below 1
                    playerFireRate = Math.max(1, playerFireRate);
                    break;
            }
            // Update UI
            GameUI.updateStatCircles(this);
        };

        function startGame() {


            // Reset game state variables
            gameOver = false;
            gamePaused = false;
            levelUpInProgress = false;
            elapsedTime = 0;
            score = 0;
            level = 1;

            // Clean up game end screens if they exist
            if (window.GameEndMenu) {
                window.GameEndMenu.destroy();
            }

            // Reset player status components
            resetPlayerStatus();
            CooldownManager.initialize();
            PlayerHitSystem.reset();

            // Reset enemy system
            EnemySystem.reset();

            // Initialize enemy spawners
            EnemySystem.initializeEnemySpawners();

            // Initialize enemy tiers with dynamic assignments
            initializeEnemyTiers();

            // Reset and initialize weapon system
            WeaponSystem.reset(this);
            WeaponSystem.initialize(this);

            resetOnHitEffects();

            // Clean up old timers
            cleanupTimers();

            // Reset our new systems (quick pause/unpause hack to clean tweens)
            if (PauseSystem) {
                PauseSystem.pauseGame(false);
                PauseSystem.resumeGame();
                PauseSystem.cleanup();
            }

            // Ensure music is playing when game restarts
            if (window.MusicSystem && !MusicSystem.currentTrack) {
                MusicSystem.start();
            }

            if (RomajiChallengeSystem) {
                RomajiChallengeSystem.resetState();
            }

            // Hide pause screen if it was visible
            if (pauseScreen) pauseScreen.setVisible(false);
            if (pauseMessage) pauseMessage.setVisible(false);
            if (resumeButton) resumeButton.setVisible(false);

            // Hide legacy game over elements if they exist
            if (typeof gameOverText !== 'undefined' && gameOverText.setVisible) {
                gameOverText.setVisible(false);
            }
            if (typeof restartButton !== 'undefined' && restartButton.setVisible) {
                restartButton.setVisible(false);
            }

            // Reset player stats to base values
            playerHealth = BASE_STATS.END;
            maxPlayerHealth = BASE_STATS.END;
            playerSpeed = basePlayerSpeed;
            playerDamage = BASE_STATS.POW;
            playerLuck = BASE_STATS.LUK;
            playerFireRate = BASE_STATS.AGI;

            // Reset XP and level
            heroExp = 0;
            playerLevel = 1;

            // Reset player position
            player.x = game.config.width / 2;
            player.y = game.config.height / 2;

            // Reset UI
            player.setFontSize(32);
            GameUI.updateHealthBar(this);
            GameUI.updateExpBar(this);

            // Reset all perk effects
            clearAllPerkEffects();
            acquiredPerks = [];

            // Clear learning feedback
            if (this.learningFeedback) {
                this.learningFeedback.setText('');
            }

            // Restart health regeneration
            LifeSystem.setupHealthRegeneration(this);

            // Reset difficulty scaling
            gameStartTime = this.time.now;

            // Clear projectiles
            projectiles.clear(true, true);

            // Resume physics
            this.physics.resume();

            // Reset perks system
            resetAllPerks();
            // If using the new perks system
            if (typeof acquiredPerks !== 'undefined') {
                acquiredPerks = [];
            }

            // Update player stats text
            GameUI.updateStatCircles(this);
        }</script>
</body>

</html>